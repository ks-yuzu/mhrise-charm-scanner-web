
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function (cv) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var cv__default = /*#__PURE__*/_interopDefaultLegacy(cv);

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.38.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* node_modules/svelte-lightbox/src/LightboxThumbnail.svelte generated by Svelte v3.38.2 */
    const file$z = "node_modules/svelte-lightbox/src/LightboxThumbnail.svelte";

    function create_fragment$E(ctx) {
    	let div1;
    	let div0;
    	let div0_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*thumbnailClasses*/ ctx[0]) + " svelte-1u332e1"));
    			attr_dev(div0, "style", /*thumbnailStyle*/ ctx[1]);
    			toggle_class(div0, "svelte-lightbox-unselectable", /*protect*/ ctx[2]);
    			add_location(div0, file$z, 10, 4, 290);
    			attr_dev(div1, "class", "clickable svelte-1u332e1");
    			add_location(div1, file$z, 9, 0, 225);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*thumbnailClasses*/ 1 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*thumbnailClasses*/ ctx[0]) + " svelte-1u332e1"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty & /*thumbnailStyle*/ 2) {
    				attr_dev(div0, "style", /*thumbnailStyle*/ ctx[1]);
    			}

    			if (dirty & /*thumbnailClasses, protect*/ 5) {
    				toggle_class(div0, "svelte-lightbox-unselectable", /*protect*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LightboxThumbnail", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { thumbnailClasses = "" } = $$props;
    	let { thumbnailStyle = "" } = $$props;
    	let { protect = false } = $$props;
    	const writable_props = ["thumbnailClasses", "thumbnailStyle", "protect"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LightboxThumbnail> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => dispatch("click");

    	$$self.$$set = $$props => {
    		if ("thumbnailClasses" in $$props) $$invalidate(0, thumbnailClasses = $$props.thumbnailClasses);
    		if ("thumbnailStyle" in $$props) $$invalidate(1, thumbnailStyle = $$props.thumbnailStyle);
    		if ("protect" in $$props) $$invalidate(2, protect = $$props.protect);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		thumbnailClasses,
    		thumbnailStyle,
    		protect
    	});

    	$$self.$inject_state = $$props => {
    		if ("thumbnailClasses" in $$props) $$invalidate(0, thumbnailClasses = $$props.thumbnailClasses);
    		if ("thumbnailStyle" in $$props) $$invalidate(1, thumbnailStyle = $$props.thumbnailStyle);
    		if ("protect" in $$props) $$invalidate(2, protect = $$props.protect);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		thumbnailClasses,
    		thumbnailStyle,
    		protect,
    		dispatch,
    		$$scope,
    		slots,
    		click_handler
    	];
    }

    class LightboxThumbnail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
    			thumbnailClasses: 0,
    			thumbnailStyle: 1,
    			protect: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LightboxThumbnail",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get thumbnailClasses() {
    		throw new Error("<LightboxThumbnail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnailClasses(value) {
    		throw new Error("<LightboxThumbnail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumbnailStyle() {
    		throw new Error("<LightboxThumbnail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnailStyle(value) {
    		throw new Error("<LightboxThumbnail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get protect() {
    		throw new Error("<LightboxThumbnail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set protect(value) {
    		throw new Error("<LightboxThumbnail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    /* node_modules/svelte-lightbox/src/Modal/LightboxHeader.svelte generated by Svelte v3.38.2 */
    const file$y = "node_modules/svelte-lightbox/src/Modal/LightboxHeader.svelte";

    function create_fragment$D(ctx) {
    	let div;
    	let button;
    	let t;
    	let button_class_value;
    	let div_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t = text("×");
    			attr_dev(button, "size", /*size*/ ctx[0]);
    			attr_dev(button, "style", /*style*/ ctx[1]);
    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*buttonClasses*/ ctx[3]) + " svelte-12yipzn"));
    			add_location(button, file$y, 11, 4, 304);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty("svelte-lightbox-header " + /*headerClasses*/ ctx[2]) + " svelte-12yipzn"));
    			add_location(div, file$y, 10, 0, 244);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*size*/ 1) {
    				attr_dev(button, "size", /*size*/ ctx[0]);
    			}

    			if (dirty & /*style*/ 2) {
    				attr_dev(button, "style", /*style*/ ctx[1]);
    			}

    			if (dirty & /*buttonClasses*/ 8 && button_class_value !== (button_class_value = "" + (null_to_empty(/*buttonClasses*/ ctx[3]) + " svelte-12yipzn"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (dirty & /*headerClasses*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty("svelte-lightbox-header " + /*headerClasses*/ ctx[2]) + " svelte-12yipzn"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LightboxHeader", slots, []);
    	const dispatch = createEventDispatcher();
    	let { size = "xs" } = $$props;
    	let { style = "" } = $$props;
    	let { headerClasses = "" } = $$props;
    	let { buttonClasses = "" } = $$props;
    	const writable_props = ["size", "style", "headerClasses", "buttonClasses"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LightboxHeader> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => dispatch("close");

    	$$self.$$set = $$props => {
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("headerClasses" in $$props) $$invalidate(2, headerClasses = $$props.headerClasses);
    		if ("buttonClasses" in $$props) $$invalidate(3, buttonClasses = $$props.buttonClasses);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		size,
    		style,
    		headerClasses,
    		buttonClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("headerClasses" in $$props) $$invalidate(2, headerClasses = $$props.headerClasses);
    		if ("buttonClasses" in $$props) $$invalidate(3, buttonClasses = $$props.buttonClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, style, headerClasses, buttonClasses, dispatch, click_handler];
    }

    class LightboxHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			size: 0,
    			style: 1,
    			headerClasses: 2,
    			buttonClasses: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LightboxHeader",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get size() {
    		throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerClasses() {
    		throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerClasses(value) {
    		throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttonClasses() {
    		throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonClasses(value) {
    		throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-lightbox/src/Modal/LightboxBody.svelte generated by Svelte v3.38.2 */

    const file$x = "node_modules/svelte-lightbox/src/Modal/LightboxBody.svelte";

    // (10:4) {:else}
    function create_else_block$b(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "svelte-x9zrc7");
    			toggle_class(div, "svelte-lightbox-image-portrait", /*portrait*/ ctx[2]);
    			add_location(div, file$x, 10, 8, 318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			if (dirty & /*portrait*/ 4) {
    				toggle_class(div, "svelte-lightbox-image-portrait", /*portrait*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(10:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (8:4) {#if image.src}
    function create_if_block$f(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_style_value;
    	let img_class_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = /*image*/ ctx[0].src)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*image*/ ctx[0].alt);
    			attr_dev(img, "style", img_style_value = /*image*/ ctx[0].style);
    			attr_dev(img, "class", img_class_value = /*image*/ ctx[0].class);
    			add_location(img, file$x, 8, 8, 220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*image*/ 1 && img.src !== (img_src_value = /*image*/ ctx[0].src)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*image*/ 1 && img_alt_value !== (img_alt_value = /*image*/ ctx[0].alt)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*image*/ 1 && img_style_value !== (img_style_value = /*image*/ ctx[0].style)) {
    				attr_dev(img, "style", img_style_value);
    			}

    			if (dirty & /*image*/ 1 && img_class_value !== (img_class_value = /*image*/ ctx[0].class)) {
    				attr_dev(img, "class", img_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(8:4) {#if image.src}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*image*/ ctx[0].src) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "svelte-lightbox-body svelte-x9zrc7");
    			toggle_class(div, "svelte-lightbox-unselectable", /*protect*/ ctx[1]);
    			add_location(div, file$x, 6, 0, 112);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (dirty & /*protect*/ 2) {
    				toggle_class(div, "svelte-lightbox-unselectable", /*protect*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LightboxBody", slots, ['default']);
    	let { image = {} } = $$props;
    	let { protect = false } = $$props;
    	let { portrait = false } = $$props;
    	const writable_props = ["image", "protect", "portrait"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LightboxBody> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("image" in $$props) $$invalidate(0, image = $$props.image);
    		if ("protect" in $$props) $$invalidate(1, protect = $$props.protect);
    		if ("portrait" in $$props) $$invalidate(2, portrait = $$props.portrait);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ image, protect, portrait });

    	$$self.$inject_state = $$props => {
    		if ("image" in $$props) $$invalidate(0, image = $$props.image);
    		if ("protect" in $$props) $$invalidate(1, protect = $$props.protect);
    		if ("portrait" in $$props) $$invalidate(2, portrait = $$props.portrait);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [image, protect, portrait, $$scope, slots];
    }

    class LightboxBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { image: 0, protect: 1, portrait: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LightboxBody",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get image() {
    		throw new Error("<LightboxBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set image(value) {
    		throw new Error("<LightboxBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get protect() {
    		throw new Error("<LightboxBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set protect(value) {
    		throw new Error("<LightboxBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get portrait() {
    		throw new Error("<LightboxBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set portrait(value) {
    		throw new Error("<LightboxBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-lightbox/src/Modal/LightboxFooter.svelte generated by Svelte v3.38.2 */

    const file$w = "node_modules/svelte-lightbox/src/Modal/LightboxFooter.svelte";

    // (18:4) {#if galleryLength}
    function create_if_block$e(ctx) {
    	let p;
    	let t0;
    	let t1_value = /*activeImage*/ ctx[3] + 1 + "";
    	let t1;
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text("Image ");
    			t1 = text(t1_value);
    			t2 = text(" of ");
    			t3 = text(/*galleryLength*/ ctx[2]);
    			add_location(p, file$w, 18, 8, 373);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*activeImage*/ 8 && t1_value !== (t1_value = /*activeImage*/ ctx[3] + 1 + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*galleryLength*/ 4) set_data_dev(t3, /*galleryLength*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(18:4) {#if galleryLength}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let h2;
    	let t0;
    	let h5;
    	let t1;
    	let div_class_value;
    	let if_block = /*galleryLength*/ ctx[2] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h2 = element("h2");
    			t0 = space();
    			h5 = element("h5");
    			t1 = space();
    			if (if_block) if_block.c();
    			add_location(h2, file$w, 11, 4, 257);
    			add_location(h5, file$w, 14, 4, 298);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty("svelte-lightbox-footer " + /*classes*/ ctx[4]) + " svelte-1u8lh7d"));
    			attr_dev(div, "style", /*style*/ ctx[5]);
    			add_location(div, file$w, 10, 0, 195);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h2);
    			h2.innerHTML = /*title*/ ctx[0];
    			append_dev(div, t0);
    			append_dev(div, h5);
    			h5.innerHTML = /*description*/ ctx[1];
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*title*/ 1) h2.innerHTML = /*title*/ ctx[0];			if (dirty & /*description*/ 2) h5.innerHTML = /*description*/ ctx[1];
    			if (/*galleryLength*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty("svelte-lightbox-footer " + /*classes*/ ctx[4]) + " svelte-1u8lh7d"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*style*/ 32) {
    				attr_dev(div, "style", /*style*/ ctx[5]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LightboxFooter", slots, []);
    	let { title = "" } = $$props;
    	let { description = "" } = $$props;
    	let { galleryLength } = $$props;
    	let { activeImage } = $$props;
    	let { classes = "" } = $$props;
    	let { style = "" } = $$props;
    	const writable_props = ["title", "description", "galleryLength", "activeImage", "classes", "style"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LightboxFooter> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("description" in $$props) $$invalidate(1, description = $$props.description);
    		if ("galleryLength" in $$props) $$invalidate(2, galleryLength = $$props.galleryLength);
    		if ("activeImage" in $$props) $$invalidate(3, activeImage = $$props.activeImage);
    		if ("classes" in $$props) $$invalidate(4, classes = $$props.classes);
    		if ("style" in $$props) $$invalidate(5, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		title,
    		description,
    		galleryLength,
    		activeImage,
    		classes,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("description" in $$props) $$invalidate(1, description = $$props.description);
    		if ("galleryLength" in $$props) $$invalidate(2, galleryLength = $$props.galleryLength);
    		if ("activeImage" in $$props) $$invalidate(3, activeImage = $$props.activeImage);
    		if ("classes" in $$props) $$invalidate(4, classes = $$props.classes);
    		if ("style" in $$props) $$invalidate(5, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, description, galleryLength, activeImage, classes, style];
    }

    class LightboxFooter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
    			title: 0,
    			description: 1,
    			galleryLength: 2,
    			activeImage: 3,
    			classes: 4,
    			style: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LightboxFooter",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*galleryLength*/ ctx[2] === undefined && !("galleryLength" in props)) {
    			console.warn("<LightboxFooter> was created without expected prop 'galleryLength'");
    		}

    		if (/*activeImage*/ ctx[3] === undefined && !("activeImage" in props)) {
    			console.warn("<LightboxFooter> was created without expected prop 'activeImage'");
    		}
    	}

    	get title() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get galleryLength() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set galleryLength(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeImage() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeImage(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-lightbox/src/Modal/Index.svelte generated by Svelte v3.38.2 */
    const file$v = "node_modules/svelte-lightbox/src/Modal/Index.svelte";

    // (43:12) <Body bind:image={image} bind:protect={protect} bind:portrait={portrait}>
    function create_default_slot$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 33554432)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[25], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(43:12) <Body bind:image={image} bind:protect={protect} bind:portrait={portrait}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let header;
    	let t0;
    	let body;
    	let updating_image;
    	let updating_protect;
    	let updating_portrait;
    	let t1;
    	let footer;
    	let updating_title;
    	let updating_description;
    	let updating_galleryLength;
    	let updating_activeImage;
    	let div1_class_value;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;
    	header = new LightboxHeader({ $$inline: true });
    	header.$on("close", /*close_handler*/ ctx[15]);

    	function body_image_binding(value) {
    		/*body_image_binding*/ ctx[16](value);
    	}

    	function body_protect_binding(value) {
    		/*body_protect_binding*/ ctx[17](value);
    	}

    	function body_portrait_binding(value) {
    		/*body_portrait_binding*/ ctx[18](value);
    	}

    	let body_props = {
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	if (/*image*/ ctx[2] !== void 0) {
    		body_props.image = /*image*/ ctx[2];
    	}

    	if (/*protect*/ ctx[3] !== void 0) {
    		body_props.protect = /*protect*/ ctx[3];
    	}

    	if (/*portrait*/ ctx[4] !== void 0) {
    		body_props.portrait = /*portrait*/ ctx[4];
    	}

    	body = new LightboxBody({ props: body_props, $$inline: true });
    	binding_callbacks.push(() => bind(body, "image", body_image_binding));
    	binding_callbacks.push(() => bind(body, "protect", body_protect_binding));
    	binding_callbacks.push(() => bind(body, "portrait", body_portrait_binding));

    	function footer_title_binding(value) {
    		/*footer_title_binding*/ ctx[19](value);
    	}

    	function footer_description_binding(value) {
    		/*footer_description_binding*/ ctx[20](value);
    	}

    	function footer_galleryLength_binding(value) {
    		/*footer_galleryLength_binding*/ ctx[21](value);
    	}

    	function footer_activeImage_binding(value) {
    		/*footer_activeImage_binding*/ ctx[22](value);
    	}

    	let footer_props = {};

    	if (/*actualTitle*/ ctx[7] !== void 0) {
    		footer_props.title = /*actualTitle*/ ctx[7];
    	}

    	if (/*actualDescription*/ ctx[8] !== void 0) {
    		footer_props.description = /*actualDescription*/ ctx[8];
    	}

    	if (/*gallery*/ ctx[0].length !== void 0) {
    		footer_props.galleryLength = /*gallery*/ ctx[0].length;
    	}

    	if (/*activeImage*/ ctx[1] !== void 0) {
    		footer_props.activeImage = /*activeImage*/ ctx[1];
    	}

    	footer = new LightboxFooter({ props: footer_props, $$inline: true });
    	binding_callbacks.push(() => bind(footer, "title", footer_title_binding));
    	binding_callbacks.push(() => bind(footer, "description", footer_description_binding));
    	binding_callbacks.push(() => bind(footer, "galleryLength", footer_galleryLength_binding));
    	binding_callbacks.push(() => bind(footer, "activeImage", footer_activeImage_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(header.$$.fragment);
    			t0 = space();
    			create_component(body.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div0, "class", "svelte-lightbox svelte-tpon2m");
    			add_location(div0, file$v, 38, 8, 1218);
    			attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(/*allModalClasses*/ ctx[9]) + " svelte-tpon2m"));
    			attr_dev(div1, "style", /*modalStyle*/ ctx[5]);
    			add_location(div1, file$v, 36, 4, 1067);
    			attr_dev(div2, "class", "cover clearfix svelte-tpon2m");
    			add_location(div2, file$v, 34, 0, 1033);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(header, div0, null);
    			append_dev(div0, t0);
    			mount_component(body, div0, null);
    			append_dev(div0, t1);
    			mount_component(footer, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[23], false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[24], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const body_changes = {};

    			if (dirty & /*$$scope*/ 33554432) {
    				body_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_image && dirty & /*image*/ 4) {
    				updating_image = true;
    				body_changes.image = /*image*/ ctx[2];
    				add_flush_callback(() => updating_image = false);
    			}

    			if (!updating_protect && dirty & /*protect*/ 8) {
    				updating_protect = true;
    				body_changes.protect = /*protect*/ ctx[3];
    				add_flush_callback(() => updating_protect = false);
    			}

    			if (!updating_portrait && dirty & /*portrait*/ 16) {
    				updating_portrait = true;
    				body_changes.portrait = /*portrait*/ ctx[4];
    				add_flush_callback(() => updating_portrait = false);
    			}

    			body.$set(body_changes);
    			const footer_changes = {};

    			if (!updating_title && dirty & /*actualTitle*/ 128) {
    				updating_title = true;
    				footer_changes.title = /*actualTitle*/ ctx[7];
    				add_flush_callback(() => updating_title = false);
    			}

    			if (!updating_description && dirty & /*actualDescription*/ 256) {
    				updating_description = true;
    				footer_changes.description = /*actualDescription*/ ctx[8];
    				add_flush_callback(() => updating_description = false);
    			}

    			if (!updating_galleryLength && dirty & /*gallery*/ 1) {
    				updating_galleryLength = true;
    				footer_changes.galleryLength = /*gallery*/ ctx[0].length;
    				add_flush_callback(() => updating_galleryLength = false);
    			}

    			if (!updating_activeImage && dirty & /*activeImage*/ 2) {
    				updating_activeImage = true;
    				footer_changes.activeImage = /*activeImage*/ ctx[1];
    				add_flush_callback(() => updating_activeImage = false);
    			}

    			footer.$set(footer_changes);

    			if (!current || dirty & /*allModalClasses*/ 512 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*allModalClasses*/ ctx[9]) + " svelte-tpon2m"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*modalStyle*/ 32) {
    				attr_dev(div1, "style", /*modalStyle*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(body.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: /*transitionDuration*/ ctx[6] }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(body.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: /*transitionDuration*/ ctx[6] }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(header);
    			destroy_component(body);
    			destroy_component(footer);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let allModalClasses;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Index", slots, ['default']);
    	const dispatch = createEventDispatcher();
    	let { modalClasses = "" } = $$props;
    	let { modalStyle = "" } = $$props;
    	let { transitionDuration = 500 } = $$props;
    	let { image = {} } = $$props;
    	let { protect = false } = $$props;
    	let { portrait = false } = $$props;
    	let { title = "" } = $$props;
    	let { description = "" } = $$props;
    	let { gallery } = $$props;
    	let { activeImage } = $$props;
    	let actualTitle;
    	let actualDescription;

    	const writable_props = [
    		"modalClasses",
    		"modalStyle",
    		"transitionDuration",
    		"image",
    		"protect",
    		"portrait",
    		"title",
    		"description",
    		"gallery",
    		"activeImage"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	const close_handler = () => dispatch("close");

    	function body_image_binding(value) {
    		image = value;
    		$$invalidate(2, image);
    	}

    	function body_protect_binding(value) {
    		protect = value;
    		$$invalidate(3, protect);
    	}

    	function body_portrait_binding(value) {
    		portrait = value;
    		$$invalidate(4, portrait);
    	}

    	function footer_title_binding(value) {
    		actualTitle = value;
    		(((($$invalidate(7, actualTitle), $$invalidate(12, title)), $$invalidate(0, gallery)), $$invalidate(13, description)), $$invalidate(1, activeImage));
    	}

    	function footer_description_binding(value) {
    		actualDescription = value;
    		(((($$invalidate(8, actualDescription), $$invalidate(13, description)), $$invalidate(0, gallery)), $$invalidate(12, title)), $$invalidate(1, activeImage));
    	}

    	function footer_galleryLength_binding(value) {
    		if ($$self.$$.not_equal(gallery.length, value)) {
    			gallery.length = value;
    			$$invalidate(0, gallery);
    		}
    	}

    	function footer_activeImage_binding(value) {
    		activeImage = value;
    		$$invalidate(1, activeImage);
    	}

    	const click_handler = () => dispatch("modalClick");
    	const click_handler_1 = () => dispatch("topModalClick");

    	$$self.$$set = $$props => {
    		if ("modalClasses" in $$props) $$invalidate(11, modalClasses = $$props.modalClasses);
    		if ("modalStyle" in $$props) $$invalidate(5, modalStyle = $$props.modalStyle);
    		if ("transitionDuration" in $$props) $$invalidate(6, transitionDuration = $$props.transitionDuration);
    		if ("image" in $$props) $$invalidate(2, image = $$props.image);
    		if ("protect" in $$props) $$invalidate(3, protect = $$props.protect);
    		if ("portrait" in $$props) $$invalidate(4, portrait = $$props.portrait);
    		if ("title" in $$props) $$invalidate(12, title = $$props.title);
    		if ("description" in $$props) $$invalidate(13, description = $$props.description);
    		if ("gallery" in $$props) $$invalidate(0, gallery = $$props.gallery);
    		if ("activeImage" in $$props) $$invalidate(1, activeImage = $$props.activeImage);
    		if ("$$scope" in $$props) $$invalidate(25, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		createEventDispatcher,
    		dispatch,
    		Header: LightboxHeader,
    		Body: LightboxBody,
    		Footer: LightboxFooter,
    		modalClasses,
    		modalStyle,
    		transitionDuration,
    		image,
    		protect,
    		portrait,
    		title,
    		description,
    		gallery,
    		activeImage,
    		actualTitle,
    		actualDescription,
    		allModalClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ("modalClasses" in $$props) $$invalidate(11, modalClasses = $$props.modalClasses);
    		if ("modalStyle" in $$props) $$invalidate(5, modalStyle = $$props.modalStyle);
    		if ("transitionDuration" in $$props) $$invalidate(6, transitionDuration = $$props.transitionDuration);
    		if ("image" in $$props) $$invalidate(2, image = $$props.image);
    		if ("protect" in $$props) $$invalidate(3, protect = $$props.protect);
    		if ("portrait" in $$props) $$invalidate(4, portrait = $$props.portrait);
    		if ("title" in $$props) $$invalidate(12, title = $$props.title);
    		if ("description" in $$props) $$invalidate(13, description = $$props.description);
    		if ("gallery" in $$props) $$invalidate(0, gallery = $$props.gallery);
    		if ("activeImage" in $$props) $$invalidate(1, activeImage = $$props.activeImage);
    		if ("actualTitle" in $$props) $$invalidate(7, actualTitle = $$props.actualTitle);
    		if ("actualDescription" in $$props) $$invalidate(8, actualDescription = $$props.actualDescription);
    		if ("allModalClasses" in $$props) $$invalidate(9, allModalClasses = $$props.allModalClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*modalClasses*/ 2048) {
    			//let allModalClasses = modalClasses;
    			$$invalidate(9, allModalClasses = `${modalClasses} svelte-lightbox-overlay clearfix`);
    		}

    		if ($$self.$$.dirty & /*title*/ 4096) {
    			$$invalidate(7, actualTitle = title);
    		}

    		if ($$self.$$.dirty & /*description*/ 8192) {
    			$$invalidate(8, actualDescription = description);
    		}

    		if ($$self.$$.dirty & /*gallery, title, description, activeImage*/ 12291) {
    			if (gallery && !title && !description) {
    				$$invalidate(7, actualTitle = gallery[activeImage].title);
    				$$invalidate(8, actualDescription = gallery[activeImage].description);
    			}
    		}
    	};

    	return [
    		gallery,
    		activeImage,
    		image,
    		protect,
    		portrait,
    		modalStyle,
    		transitionDuration,
    		actualTitle,
    		actualDescription,
    		allModalClasses,
    		dispatch,
    		modalClasses,
    		title,
    		description,
    		slots,
    		close_handler,
    		body_image_binding,
    		body_protect_binding,
    		body_portrait_binding,
    		footer_title_binding,
    		footer_description_binding,
    		footer_galleryLength_binding,
    		footer_activeImage_binding,
    		click_handler,
    		click_handler_1,
    		$$scope
    	];
    }

    class Index extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			modalClasses: 11,
    			modalStyle: 5,
    			transitionDuration: 6,
    			image: 2,
    			protect: 3,
    			portrait: 4,
    			title: 12,
    			description: 13,
    			gallery: 0,
    			activeImage: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*gallery*/ ctx[0] === undefined && !("gallery" in props)) {
    			console.warn("<Index> was created without expected prop 'gallery'");
    		}

    		if (/*activeImage*/ ctx[1] === undefined && !("activeImage" in props)) {
    			console.warn("<Index> was created without expected prop 'activeImage'");
    		}
    	}

    	get modalClasses() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalClasses(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalStyle() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalStyle(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionDuration() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionDuration(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get image() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set image(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get protect() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set protect(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get portrait() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set portrait(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gallery() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gallery(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeImage() {
    		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeImage(value) {
    		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-lightbox/src/Gallery/InternalGallery.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$5, console: console_1$6 } = globals;
    const file$u = "node_modules/svelte-lightbox/src/Gallery/InternalGallery.svelte";

    function create_fragment$z(ctx) {
    	let div1;
    	let button0;
    	let svg0;
    	let g0;
    	let path0;
    	let button0_disabled_value;
    	let t0;
    	let div0;
    	let t1;
    	let button1;
    	let svg1;
    	let g1;
    	let path1;
    	let button1_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			t0 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			g1 = svg_element("g");
    			path1 = svg_element("path");
    			attr_dev(path0, "class", "arrow svelte-wwe8hv");
    			attr_dev(path0, "d", "M8.7,7.22,4.59,11.33a1,1,0,0,0,0,1.41l4,4");
    			add_location(path0, file$u, 33, 16, 909);
    			add_location(g0, file$u, 32, 12, 889);
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "class", "svelte-wwe8hv");
    			add_location(svg0, file$u, 31, 8, 816);
    			button0.disabled = button0_disabled_value = /*activeImage*/ ctx[0] === 0;
    			attr_dev(button0, "class", "previous-button svelte-wwe8hv");
    			add_location(button0, file$u, 30, 4, 721);
    			attr_dev(div0, "class", "slot svelte-wwe8hv");
    			add_location(div0, file$u, 38, 4, 1028);
    			attr_dev(path1, "class", "arrow svelte-wwe8hv");
    			attr_dev(path1, "d", "M15.3,16.78l4.11-4.11a1,1,0,0,0,0-1.41l-4-4");
    			add_location(path1, file$u, 46, 16, 1313);
    			add_location(g1, file$u, 45, 12, 1293);
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "class", "svelte-wwe8hv");
    			add_location(svg1, file$u, 44, 8, 1220);
    			button1.disabled = button1_disabled_value = /*activeImage*/ ctx[0] === /*images*/ ctx[2]?.length - 1;
    			attr_dev(button1, "class", "next-button svelte-wwe8hv");
    			add_location(button1, file$u, 43, 4, 1118);
    			attr_dev(div1, "class", "wrapper svelte-wwe8hv");
    			add_location(div1, file$u, 29, 0, 695);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button0);
    			append_dev(button0, svg0);
    			append_dev(svg0, g0);
    			append_dev(g0, path0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[7](div0);
    			append_dev(div1, t1);
    			append_dev(div1, button1);
    			append_dev(button1, svg1);
    			append_dev(svg1, g1);
    			append_dev(g1, path1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*previousImage*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*nextImage*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*activeImage*/ 1 && button0_disabled_value !== (button0_disabled_value = /*activeImage*/ ctx[0] === 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*activeImage, images*/ 5 && button1_disabled_value !== (button1_disabled_value = /*activeImage*/ ctx[0] === /*images*/ ctx[2]?.length - 1)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			/*div0_binding*/ ctx[7](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InternalGallery", slots, ['default']);
    	let { activeImage = 0 } = $$props;
    	let slotContent;
    	let images;

    	const previousImage = () => {
    		$$invalidate(0, activeImage--, activeImage);
    	};

    	const nextImage = () => {
    		$$invalidate(0, activeImage++, activeImage);
    	};

    	const writable_props = ["activeImage"];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<InternalGallery> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			slotContent = $$value;
    			$$invalidate(1, slotContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("activeImage" in $$props) $$invalidate(0, activeImage = $$props.activeImage);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		activeImage,
    		slotContent,
    		images,
    		previousImage,
    		nextImage
    	});

    	$$self.$inject_state = $$props => {
    		if ("activeImage" in $$props) $$invalidate(0, activeImage = $$props.activeImage);
    		if ("slotContent" in $$props) $$invalidate(1, slotContent = $$props.slotContent);
    		if ("images" in $$props) $$invalidate(2, images = $$props.images);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*slotContent*/ 2) {
    			$$invalidate(2, images = slotContent?.children);
    		}

    		if ($$self.$$.dirty & /*images, activeImage*/ 5) {
    			{
    				console.log(typeof images);

    				if (images && activeImage < images.length) {
    					Object.values(images).forEach(img => {
    						img.hidden = true;
    						return img;
    					});

    					$$invalidate(2, images[activeImage].hidden = false, images);
    				} else if (images && activeImage >= images.length) {
    					console.error("LightboxGallery: Selected image doesn't exist, invalid activeImage");
    				}
    			}
    		}
    	};

    	return [
    		activeImage,
    		slotContent,
    		images,
    		previousImage,
    		nextImage,
    		$$scope,
    		slots,
    		div0_binding
    	];
    }

    class InternalGallery extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { activeImage: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InternalGallery",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get activeImage() {
    		throw new Error("<InternalGallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeImage(value) {
    		throw new Error("<InternalGallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    /* node_modules/svelte-lightbox/src/Gallery/ExternalGallery.svelte generated by Svelte v3.38.2 */

    function create_fragment$y(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ExternalGallery", slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExternalGallery> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class ExternalGallery extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExternalGallery",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* node_modules/svelte-lightbox/src/Lightbox.svelte generated by Svelte v3.38.2 */
    const get_thumbnail_slot_changes_1 = dirty => ({});
    const get_thumbnail_slot_context_1 = ctx => ({});
    const get_image_slot_changes = dirty => ({});
    const get_image_slot_context = ctx => ({});
    const get_thumbnail_slot_changes = dirty => ({});
    const get_thumbnail_slot_context = ctx => ({});

    // (65:4) {:else}
    function create_else_block_1$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[32], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(65:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:4) {#if thumbnail || gallery}
    function create_if_block_3$6(ctx) {
    	let current;
    	const thumbnail_slot_template = /*#slots*/ ctx[17].thumbnail;
    	const thumbnail_slot = create_slot(thumbnail_slot_template, ctx, /*$$scope*/ ctx[32], get_thumbnail_slot_context);

    	const block = {
    		c: function create() {
    			if (thumbnail_slot) thumbnail_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (thumbnail_slot) {
    				thumbnail_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (thumbnail_slot) {
    				if (thumbnail_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(thumbnail_slot, thumbnail_slot_template, ctx, /*$$scope*/ ctx[32], dirty, get_thumbnail_slot_changes, get_thumbnail_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(thumbnail_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(thumbnail_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (thumbnail_slot) thumbnail_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(63:4) {#if thumbnail || gallery}",
    		ctx
    	});

    	return block;
    }

    // (62:0) <Thumbnail bind:thumbnailClasses bind:thumbnailStyle bind:protect on:click={toggle}>
    function create_default_slot_2$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_3$6, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*thumbnail*/ ctx[12] || /*gallery*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(62:0) <Thumbnail bind:thumbnailClasses bind:thumbnailStyle bind:protect on:click={toggle}>",
    		ctx
    	});

    	return block;
    }

    // (70:0) {#if visible}
    function create_if_block$d(ctx) {
    	let modal;
    	let updating_modalClasses;
    	let updating_modalStyle;
    	let updating_transitionDuration;
    	let updating_image;
    	let updating_protect;
    	let updating_portrait;
    	let updating_title;
    	let updating_description;
    	let updating_gallery;
    	let updating_activeImage;
    	let current;

    	function modal_modalClasses_binding(value) {
    		/*modal_modalClasses_binding*/ ctx[22](value);
    	}

    	function modal_modalStyle_binding(value) {
    		/*modal_modalStyle_binding*/ ctx[23](value);
    	}

    	function modal_transitionDuration_binding(value) {
    		/*modal_transitionDuration_binding*/ ctx[24](value);
    	}

    	function modal_image_binding(value) {
    		/*modal_image_binding*/ ctx[25](value);
    	}

    	function modal_protect_binding(value) {
    		/*modal_protect_binding*/ ctx[26](value);
    	}

    	function modal_portrait_binding(value) {
    		/*modal_portrait_binding*/ ctx[27](value);
    	}

    	function modal_title_binding(value) {
    		/*modal_title_binding*/ ctx[28](value);
    	}

    	function modal_description_binding(value) {
    		/*modal_description_binding*/ ctx[29](value);
    	}

    	function modal_gallery_binding(value) {
    		/*modal_gallery_binding*/ ctx[30](value);
    	}

    	function modal_activeImage_binding(value) {
    		/*modal_activeImage_binding*/ ctx[31](value);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	if (/*modalClasses*/ ctx[2] !== void 0) {
    		modal_props.modalClasses = /*modalClasses*/ ctx[2];
    	}

    	if (/*modalStyle*/ ctx[3] !== void 0) {
    		modal_props.modalStyle = /*modalStyle*/ ctx[3];
    	}

    	if (/*transitionDuration*/ ctx[8] !== void 0) {
    		modal_props.transitionDuration = /*transitionDuration*/ ctx[8];
    	}

    	if (/*image*/ ctx[10] !== void 0) {
    		modal_props.image = /*image*/ ctx[10];
    	}

    	if (/*protect*/ ctx[9] !== void 0) {
    		modal_props.protect = /*protect*/ ctx[9];
    	}

    	if (/*portrait*/ ctx[11] !== void 0) {
    		modal_props.portrait = /*portrait*/ ctx[11];
    	}

    	if (/*title*/ ctx[6] !== void 0) {
    		modal_props.title = /*title*/ ctx[6];
    	}

    	if (/*description*/ ctx[7] !== void 0) {
    		modal_props.description = /*description*/ ctx[7];
    	}

    	if (/*gallery*/ ctx[5] !== void 0) {
    		modal_props.gallery = /*gallery*/ ctx[5];
    	}

    	if (/*activeImage*/ ctx[4] !== void 0) {
    		modal_props.activeImage = /*activeImage*/ ctx[4];
    	}

    	modal = new Index({ props: modal_props, $$inline: true });
    	binding_callbacks.push(() => bind(modal, "modalClasses", modal_modalClasses_binding));
    	binding_callbacks.push(() => bind(modal, "modalStyle", modal_modalStyle_binding));
    	binding_callbacks.push(() => bind(modal, "transitionDuration", modal_transitionDuration_binding));
    	binding_callbacks.push(() => bind(modal, "image", modal_image_binding));
    	binding_callbacks.push(() => bind(modal, "protect", modal_protect_binding));
    	binding_callbacks.push(() => bind(modal, "portrait", modal_portrait_binding));
    	binding_callbacks.push(() => bind(modal, "title", modal_title_binding));
    	binding_callbacks.push(() => bind(modal, "description", modal_description_binding));
    	binding_callbacks.push(() => bind(modal, "gallery", modal_gallery_binding));
    	binding_callbacks.push(() => bind(modal, "activeImage", modal_activeImage_binding));
    	modal.$on("close", /*toggle*/ ctx[14]);
    	modal.$on("topModalClick", /*toggle*/ ctx[14]);
    	modal.$on("modalClick", /*toggle*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};

    			if (dirty[0] & /*thumbnail, activeImage, gallery*/ 4144 | dirty[1] & /*$$scope*/ 2) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_modalClasses && dirty[0] & /*modalClasses*/ 4) {
    				updating_modalClasses = true;
    				modal_changes.modalClasses = /*modalClasses*/ ctx[2];
    				add_flush_callback(() => updating_modalClasses = false);
    			}

    			if (!updating_modalStyle && dirty[0] & /*modalStyle*/ 8) {
    				updating_modalStyle = true;
    				modal_changes.modalStyle = /*modalStyle*/ ctx[3];
    				add_flush_callback(() => updating_modalStyle = false);
    			}

    			if (!updating_transitionDuration && dirty[0] & /*transitionDuration*/ 256) {
    				updating_transitionDuration = true;
    				modal_changes.transitionDuration = /*transitionDuration*/ ctx[8];
    				add_flush_callback(() => updating_transitionDuration = false);
    			}

    			if (!updating_image && dirty[0] & /*image*/ 1024) {
    				updating_image = true;
    				modal_changes.image = /*image*/ ctx[10];
    				add_flush_callback(() => updating_image = false);
    			}

    			if (!updating_protect && dirty[0] & /*protect*/ 512) {
    				updating_protect = true;
    				modal_changes.protect = /*protect*/ ctx[9];
    				add_flush_callback(() => updating_protect = false);
    			}

    			if (!updating_portrait && dirty[0] & /*portrait*/ 2048) {
    				updating_portrait = true;
    				modal_changes.portrait = /*portrait*/ ctx[11];
    				add_flush_callback(() => updating_portrait = false);
    			}

    			if (!updating_title && dirty[0] & /*title*/ 64) {
    				updating_title = true;
    				modal_changes.title = /*title*/ ctx[6];
    				add_flush_callback(() => updating_title = false);
    			}

    			if (!updating_description && dirty[0] & /*description*/ 128) {
    				updating_description = true;
    				modal_changes.description = /*description*/ ctx[7];
    				add_flush_callback(() => updating_description = false);
    			}

    			if (!updating_gallery && dirty[0] & /*gallery*/ 32) {
    				updating_gallery = true;
    				modal_changes.gallery = /*gallery*/ ctx[5];
    				add_flush_callback(() => updating_gallery = false);
    			}

    			if (!updating_activeImage && dirty[0] & /*activeImage*/ 16) {
    				updating_activeImage = true;
    				modal_changes.activeImage = /*activeImage*/ ctx[4];
    				add_flush_callback(() => updating_activeImage = false);
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(70:0) {#if visible}",
    		ctx
    	});

    	return block;
    }

    // (82:8) {:else}
    function create_else_block$a(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[32], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(82:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:26) 
    function create_if_block_2$a(ctx) {
    	let internalgallery;
    	let updating_activeImage;
    	let current;

    	function internalgallery_activeImage_binding(value) {
    		/*internalgallery_activeImage_binding*/ ctx[21](value);
    	}

    	let internalgallery_props = {
    		$$slots: { default: [create_default_slot_1$3] },
    		$$scope: { ctx }
    	};

    	if (/*activeImage*/ ctx[4] !== void 0) {
    		internalgallery_props.activeImage = /*activeImage*/ ctx[4];
    	}

    	internalgallery = new InternalGallery({
    			props: internalgallery_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(internalgallery, "activeImage", internalgallery_activeImage_binding));

    	const block = {
    		c: function create() {
    			create_component(internalgallery.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(internalgallery, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const internalgallery_changes = {};

    			if (dirty[1] & /*$$scope*/ 2) {
    				internalgallery_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_activeImage && dirty[0] & /*activeImage*/ 16) {
    				updating_activeImage = true;
    				internalgallery_changes.activeImage = /*activeImage*/ ctx[4];
    				add_flush_callback(() => updating_activeImage = false);
    			}

    			internalgallery.$set(internalgallery_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(internalgallery.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(internalgallery.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(internalgallery, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(76:26) ",
    		ctx
    	});

    	return block;
    }

    // (74:8) {#if thumbnail}
    function create_if_block_1$b(ctx) {
    	let current;
    	const image_slot_template = /*#slots*/ ctx[17].image;
    	const image_slot = create_slot(image_slot_template, ctx, /*$$scope*/ ctx[32], get_image_slot_context);

    	const block = {
    		c: function create() {
    			if (image_slot) image_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (image_slot) {
    				image_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (image_slot) {
    				if (image_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(image_slot, image_slot_template, ctx, /*$$scope*/ ctx[32], dirty, get_image_slot_changes, get_image_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (image_slot) image_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(74:8) {#if thumbnail}",
    		ctx
    	});

    	return block;
    }

    // (77:12) <InternalGallery bind:activeImage>
    function create_default_slot_1$3(ctx) {
    	let t;
    	let current;
    	const thumbnail_slot_template = /*#slots*/ ctx[17].thumbnail;
    	const thumbnail_slot = create_slot(thumbnail_slot_template, ctx, /*$$scope*/ ctx[32], get_thumbnail_slot_context_1);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[32], null);

    	const block = {
    		c: function create() {
    			if (thumbnail_slot) thumbnail_slot.c();
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (thumbnail_slot) {
    				thumbnail_slot.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (thumbnail_slot) {
    				if (thumbnail_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(thumbnail_slot, thumbnail_slot_template, ctx, /*$$scope*/ ctx[32], dirty, get_thumbnail_slot_changes_1, get_thumbnail_slot_context_1);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 2)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[32], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(thumbnail_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(thumbnail_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (thumbnail_slot) thumbnail_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(77:12) <InternalGallery bind:activeImage>",
    		ctx
    	});

    	return block;
    }

    // (71:4) <Modal bind:modalClasses bind:modalStyle bind:transitionDuration bind:image bind:protect            bind:portrait bind:title bind:description bind:gallery bind:activeImage            on:close={toggle} on:topModalClick={toggle} on:modalClick={toggle}>
    function create_default_slot$5(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$b, create_if_block_2$a, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*thumbnail*/ ctx[12]) return 0;
    		if (/*gallery*/ ctx[5]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(71:4) <Modal bind:modalClasses bind:modalStyle bind:transitionDuration bind:image bind:protect            bind:portrait bind:title bind:description bind:gallery bind:activeImage            on:close={toggle} on:topModalClick={toggle} on:modalClick={toggle}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let thumbnail_1;
    	let updating_thumbnailClasses;
    	let updating_thumbnailStyle;
    	let updating_protect;
    	let t;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	function thumbnail_1_thumbnailClasses_binding(value) {
    		/*thumbnail_1_thumbnailClasses_binding*/ ctx[18](value);
    	}

    	function thumbnail_1_thumbnailStyle_binding(value) {
    		/*thumbnail_1_thumbnailStyle_binding*/ ctx[19](value);
    	}

    	function thumbnail_1_protect_binding(value) {
    		/*thumbnail_1_protect_binding*/ ctx[20](value);
    	}

    	let thumbnail_1_props = {
    		$$slots: { default: [create_default_slot_2$2] },
    		$$scope: { ctx }
    	};

    	if (/*thumbnailClasses*/ ctx[0] !== void 0) {
    		thumbnail_1_props.thumbnailClasses = /*thumbnailClasses*/ ctx[0];
    	}

    	if (/*thumbnailStyle*/ ctx[1] !== void 0) {
    		thumbnail_1_props.thumbnailStyle = /*thumbnailStyle*/ ctx[1];
    	}

    	if (/*protect*/ ctx[9] !== void 0) {
    		thumbnail_1_props.protect = /*protect*/ ctx[9];
    	}

    	thumbnail_1 = new LightboxThumbnail({ props: thumbnail_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(thumbnail_1, "thumbnailClasses", thumbnail_1_thumbnailClasses_binding));
    	binding_callbacks.push(() => bind(thumbnail_1, "thumbnailStyle", thumbnail_1_thumbnailStyle_binding));
    	binding_callbacks.push(() => bind(thumbnail_1, "protect", thumbnail_1_protect_binding));
    	thumbnail_1.$on("click", /*toggle*/ ctx[14]);
    	let if_block = /*visible*/ ctx[13] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			create_component(thumbnail_1.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(thumbnail_1, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*handleKeyDown*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const thumbnail_1_changes = {};

    			if (dirty[0] & /*thumbnail, gallery*/ 4128 | dirty[1] & /*$$scope*/ 2) {
    				thumbnail_1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_thumbnailClasses && dirty[0] & /*thumbnailClasses*/ 1) {
    				updating_thumbnailClasses = true;
    				thumbnail_1_changes.thumbnailClasses = /*thumbnailClasses*/ ctx[0];
    				add_flush_callback(() => updating_thumbnailClasses = false);
    			}

    			if (!updating_thumbnailStyle && dirty[0] & /*thumbnailStyle*/ 2) {
    				updating_thumbnailStyle = true;
    				thumbnail_1_changes.thumbnailStyle = /*thumbnailStyle*/ ctx[1];
    				add_flush_callback(() => updating_thumbnailStyle = false);
    			}

    			if (!updating_protect && dirty[0] & /*protect*/ 512) {
    				updating_protect = true;
    				thumbnail_1_changes.protect = /*protect*/ ctx[9];
    				add_flush_callback(() => updating_protect = false);
    			}

    			thumbnail_1.$set(thumbnail_1_changes);

    			if (/*visible*/ ctx[13]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*visible*/ 8192) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(thumbnail_1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(thumbnail_1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(thumbnail_1, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Lightbox", slots, ['thumbnail','default','image']);
    	let { thumbnailClasses = "" } = $$props;
    	let { thumbnailStyle = "" } = $$props;
    	let { modalClasses = "" } = $$props;
    	let { modalStyle = "" } = $$props;
    	let { activeImage = 0 } = $$props;
    	let { gallery = false } = $$props;
    	let { title = "" } = $$props;
    	let { description = "" } = $$props;
    	let { transitionDuration = 500 } = $$props;
    	let { protect = false } = $$props;
    	let { image = {} } = $$props;
    	let { portrait = false } = $$props;
    	let { noScroll = true } = $$props;
    	let { thumbnail = false } = $$props;
    	let visible = false;

    	const toggle = () => {
    		$$invalidate(13, visible = !visible);

    		if (noScroll) {
    			mountedT();
    		}
    	};

    	let mountedT = () => {
    		
    	};

    	onMount(() => {
    		let defaultOverflow = document.body.style.overflow;

    		mountedT = () => {
    			if (visible) {
    				document.body.style.overflow = "hidden";
    			} else {
    				document.body.style.overflow = defaultOverflow;
    			}
    		};
    	});

    	const handleKeyDown = e => {
    		if (e.code === "Escape") {
    			$$invalidate(13, visible = false);
    		}
    	};

    	const writable_props = [
    		"thumbnailClasses",
    		"thumbnailStyle",
    		"modalClasses",
    		"modalStyle",
    		"activeImage",
    		"gallery",
    		"title",
    		"description",
    		"transitionDuration",
    		"protect",
    		"image",
    		"portrait",
    		"noScroll",
    		"thumbnail"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Lightbox> was created with unknown prop '${key}'`);
    	});

    	function thumbnail_1_thumbnailClasses_binding(value) {
    		thumbnailClasses = value;
    		$$invalidate(0, thumbnailClasses);
    	}

    	function thumbnail_1_thumbnailStyle_binding(value) {
    		thumbnailStyle = value;
    		$$invalidate(1, thumbnailStyle);
    	}

    	function thumbnail_1_protect_binding(value) {
    		protect = value;
    		$$invalidate(9, protect);
    	}

    	function internalgallery_activeImage_binding(value) {
    		activeImage = value;
    		$$invalidate(4, activeImage);
    	}

    	function modal_modalClasses_binding(value) {
    		modalClasses = value;
    		$$invalidate(2, modalClasses);
    	}

    	function modal_modalStyle_binding(value) {
    		modalStyle = value;
    		$$invalidate(3, modalStyle);
    	}

    	function modal_transitionDuration_binding(value) {
    		transitionDuration = value;
    		$$invalidate(8, transitionDuration);
    	}

    	function modal_image_binding(value) {
    		image = value;
    		$$invalidate(10, image);
    	}

    	function modal_protect_binding(value) {
    		protect = value;
    		$$invalidate(9, protect);
    	}

    	function modal_portrait_binding(value) {
    		portrait = value;
    		$$invalidate(11, portrait);
    	}

    	function modal_title_binding(value) {
    		title = value;
    		$$invalidate(6, title);
    	}

    	function modal_description_binding(value) {
    		description = value;
    		$$invalidate(7, description);
    	}

    	function modal_gallery_binding(value) {
    		gallery = value;
    		$$invalidate(5, gallery);
    	}

    	function modal_activeImage_binding(value) {
    		activeImage = value;
    		$$invalidate(4, activeImage);
    	}

    	$$self.$$set = $$props => {
    		if ("thumbnailClasses" in $$props) $$invalidate(0, thumbnailClasses = $$props.thumbnailClasses);
    		if ("thumbnailStyle" in $$props) $$invalidate(1, thumbnailStyle = $$props.thumbnailStyle);
    		if ("modalClasses" in $$props) $$invalidate(2, modalClasses = $$props.modalClasses);
    		if ("modalStyle" in $$props) $$invalidate(3, modalStyle = $$props.modalStyle);
    		if ("activeImage" in $$props) $$invalidate(4, activeImage = $$props.activeImage);
    		if ("gallery" in $$props) $$invalidate(5, gallery = $$props.gallery);
    		if ("title" in $$props) $$invalidate(6, title = $$props.title);
    		if ("description" in $$props) $$invalidate(7, description = $$props.description);
    		if ("transitionDuration" in $$props) $$invalidate(8, transitionDuration = $$props.transitionDuration);
    		if ("protect" in $$props) $$invalidate(9, protect = $$props.protect);
    		if ("image" in $$props) $$invalidate(10, image = $$props.image);
    		if ("portrait" in $$props) $$invalidate(11, portrait = $$props.portrait);
    		if ("noScroll" in $$props) $$invalidate(16, noScroll = $$props.noScroll);
    		if ("thumbnail" in $$props) $$invalidate(12, thumbnail = $$props.thumbnail);
    		if ("$$scope" in $$props) $$invalidate(32, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Thumbnail: LightboxThumbnail,
    		Modal: Index,
    		InternalGallery,
    		onMount,
    		writable,
    		ExternalGallery,
    		thumbnailClasses,
    		thumbnailStyle,
    		modalClasses,
    		modalStyle,
    		activeImage,
    		gallery,
    		title,
    		description,
    		transitionDuration,
    		protect,
    		image,
    		portrait,
    		noScroll,
    		thumbnail,
    		visible,
    		toggle,
    		mountedT,
    		handleKeyDown
    	});

    	$$self.$inject_state = $$props => {
    		if ("thumbnailClasses" in $$props) $$invalidate(0, thumbnailClasses = $$props.thumbnailClasses);
    		if ("thumbnailStyle" in $$props) $$invalidate(1, thumbnailStyle = $$props.thumbnailStyle);
    		if ("modalClasses" in $$props) $$invalidate(2, modalClasses = $$props.modalClasses);
    		if ("modalStyle" in $$props) $$invalidate(3, modalStyle = $$props.modalStyle);
    		if ("activeImage" in $$props) $$invalidate(4, activeImage = $$props.activeImage);
    		if ("gallery" in $$props) $$invalidate(5, gallery = $$props.gallery);
    		if ("title" in $$props) $$invalidate(6, title = $$props.title);
    		if ("description" in $$props) $$invalidate(7, description = $$props.description);
    		if ("transitionDuration" in $$props) $$invalidate(8, transitionDuration = $$props.transitionDuration);
    		if ("protect" in $$props) $$invalidate(9, protect = $$props.protect);
    		if ("image" in $$props) $$invalidate(10, image = $$props.image);
    		if ("portrait" in $$props) $$invalidate(11, portrait = $$props.portrait);
    		if ("noScroll" in $$props) $$invalidate(16, noScroll = $$props.noScroll);
    		if ("thumbnail" in $$props) $$invalidate(12, thumbnail = $$props.thumbnail);
    		if ("visible" in $$props) $$invalidate(13, visible = $$props.visible);
    		if ("mountedT" in $$props) mountedT = $$props.mountedT;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		thumbnailClasses,
    		thumbnailStyle,
    		modalClasses,
    		modalStyle,
    		activeImage,
    		gallery,
    		title,
    		description,
    		transitionDuration,
    		protect,
    		image,
    		portrait,
    		thumbnail,
    		visible,
    		toggle,
    		handleKeyDown,
    		noScroll,
    		slots,
    		thumbnail_1_thumbnailClasses_binding,
    		thumbnail_1_thumbnailStyle_binding,
    		thumbnail_1_protect_binding,
    		internalgallery_activeImage_binding,
    		modal_modalClasses_binding,
    		modal_modalStyle_binding,
    		modal_transitionDuration_binding,
    		modal_image_binding,
    		modal_protect_binding,
    		modal_portrait_binding,
    		modal_title_binding,
    		modal_description_binding,
    		modal_gallery_binding,
    		modal_activeImage_binding,
    		$$scope
    	];
    }

    class Lightbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$x,
    			create_fragment$x,
    			safe_not_equal,
    			{
    				thumbnailClasses: 0,
    				thumbnailStyle: 1,
    				modalClasses: 2,
    				modalStyle: 3,
    				activeImage: 4,
    				gallery: 5,
    				title: 6,
    				description: 7,
    				transitionDuration: 8,
    				protect: 9,
    				image: 10,
    				portrait: 11,
    				noScroll: 16,
    				thumbnail: 12
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lightbox",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get thumbnailClasses() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnailClasses(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumbnailStyle() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnailStyle(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalClasses() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalClasses(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalStyle() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalStyle(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeImage() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeImage(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gallery() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gallery(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionDuration() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionDuration(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get protect() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set protect(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get image() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set image(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get portrait() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set portrait(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noScroll() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noScroll(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get thumbnail() {
    		throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set thumbnail(value) {
    		throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/Description.svelte generated by Svelte v3.38.2 */
    const file$t = "src/pages/Description.svelte";

    // (37:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot_5$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-scanning.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm scanning");
    			add_location(img, file$t, 37, 10, 1294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(37:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot_4$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-realtime-scan.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm realtime scan");
    			add_location(img, file$t, 63, 10, 2199);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(63:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot_3$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-img.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm scrennshot");
    			add_location(img, file$t, 95, 10, 3383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(95:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot_2$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-substitutes.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm substitutes");
    			add_location(img, file$t, 98, 10, 3567);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(98:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    // (114:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot_1$2(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-search.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm search");
    			add_location(img, file$t, 114, 10, 4018);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(114:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:8) <Lightbox thumbnailStyle="width: 24rem; max-width: 90%; border: solid 1px #eee">
    function create_default_slot$4(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "img/screenshots/charm-rinne-support.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "charm rinne support");
    			add_location(img, file$t, 135, 10, 4656);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(135:8) <Lightbox thumbnailStyle=\\\"width: 24rem; max-width: 90%; border: solid 1px #eee\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div25;
    	let div1;
    	let div0;
    	let h20;
    	let t1;
    	let p0;
    	let t2;
    	let br0;
    	let t3;
    	let br1;
    	let t4;
    	let br2;
    	let t5;
    	let br3;
    	let t6;
    	let br4;
    	let t7;
    	let div4;
    	let div3;
    	let h21;
    	let t9;
    	let p1;
    	let t10;
    	let br5;
    	let t11;
    	let a0;
    	let t13;
    	let br6;
    	let t14;
    	let br7;
    	let t15;
    	let br8;
    	let t16;
    	let a1;
    	let t18;
    	let br9;
    	let t19;
    	let br10;
    	let t20;
    	let a2;
    	let t22;
    	let br11;
    	let t23;
    	let br12;
    	let t24;
    	let br13;
    	let t25;
    	let span0;
    	let t27;
    	let br14;
    	let t28;
    	let br15;
    	let t29;
    	let div2;
    	let lightbox0;
    	let t30;
    	let div7;
    	let div6;
    	let h22;
    	let t32;
    	let p2;
    	let t33;
    	let br16;
    	let t34;
    	let br17;
    	let t35;
    	let br18;
    	let t36;
    	let br19;
    	let t37;
    	let br20;
    	let t38;
    	let br21;
    	let t39;
    	let br22;
    	let t40;
    	let br23;
    	let t41;
    	let br24;
    	let t42;
    	let br25;
    	let t43;
    	let br26;
    	let t44;
    	let span1;
    	let t46;
    	let br27;
    	let t47;
    	let div5;
    	let lightbox1;
    	let t48;
    	let div10;
    	let div9;
    	let h23;
    	let t50;
    	let p3;
    	let t51;
    	let br28;
    	let t52;
    	let br29;
    	let t53;
    	let br30;
    	let t54;
    	let br31;
    	let t55;
    	let br32;
    	let t56;
    	let br33;
    	let t57;
    	let br34;
    	let t58;
    	let span2;
    	let br35;
    	let t60;
    	let br36;
    	let t61;
    	let br37;
    	let t62;
    	let br38;
    	let t63;
    	let span3;
    	let br39;
    	let t65;
    	let br40;
    	let t66;
    	let br41;
    	let t67;
    	let br42;
    	let t68;
    	let br43;
    	let t69;
    	let div8;
    	let lightbox2;
    	let t70;
    	let lightbox3;
    	let t71;
    	let div13;
    	let div12;
    	let h24;
    	let t73;
    	let p4;
    	let t75;
    	let div11;
    	let lightbox4;
    	let t76;
    	let div16;
    	let div15;
    	let h25;
    	let t78;
    	let p5;
    	let t79;
    	let br44;
    	let t80;
    	let br45;
    	let t81;
    	let br46;
    	let t82;
    	let span4;
    	let t83;
    	let br47;
    	let t84;
    	let t85;
    	let div14;
    	let lightbox5;
    	let t86;
    	let div18;
    	let div17;
    	let h26;
    	let t88;
    	let p6;
    	let t89;
    	let br48;
    	let t90;
    	let br49;
    	let t91;
    	let br50;
    	let t92;
    	let span5;
    	let t93;
    	let br51;
    	let t94;
    	let t95;
    	let div20;
    	let div19;
    	let h27;
    	let t97;
    	let p7;
    	let t98;
    	let br52;
    	let t99;
    	let br53;
    	let t100;
    	let br54;
    	let t101;
    	let span6;
    	let t102;
    	let br55;
    	let t103;
    	let br56;
    	let t104;
    	let div22;
    	let div21;
    	let h28;
    	let t106;
    	let h3;
    	let t108;
    	let p8;
    	let t109;
    	let br57;
    	let t110;
    	let br58;
    	let t111;
    	let br59;
    	let t112;
    	let br60;
    	let t113;
    	let br61;
    	let t114;
    	let br62;
    	let t115;
    	let br63;
    	let t116;
    	let t117;
    	let div24;
    	let div23;
    	let h29;
    	let t119;
    	let p9;
    	let t120;
    	let a3;
    	let t122;
    	let current;

    	lightbox0 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox1 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox2 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox3 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox4 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	lightbox5 = new Lightbox({
    			props: {
    				thumbnailStyle: "width: 24rem; max-width: 90%; border: solid 1px #eee",
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div25 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "■ 概要";
    			t1 = space();
    			p0 = element("p");
    			t2 = text("モンスターハンターライズの護石用ツールです。");
    			br0 = element("br");
    			t3 = text("\n        手持ちの護石を自動読み取りすることができます。");
    			br1 = element("br");
    			t4 = space();
    			br2 = element("br");
    			t5 = text("\n        読み取った護石は、スキャン時の画像や上位互換の護石が確認できます。");
    			br3 = element("br");
    			t6 = text("\n        また、護石を性能検索することもできます。");
    			br4 = element("br");
    			t7 = space();
    			div4 = element("div");
    			div3 = element("div");
    			h21 = element("h2");
    			h21.textContent = "■ 護石スキャン";
    			t9 = space();
    			p1 = element("p");
    			t10 = text("護石のスキルやスロットを自動読み取りします。");
    			br5 = element("br");
    			t11 = text("\n        Nintendo Switch の 30 秒キャプチャ動画を用意するだけで、自動でデータ化できます。\n        (");
    			a0 = element("a");
    			a0.textContent = "動画例";
    			t13 = text(")");
    			br6 = element("br");
    			t14 = space();
    			br7 = element("br");
    			t15 = text("\n        出力形式は、<スキル1>,<スキル1Lv>,<スキル2>,<スキル2Lv>,<スロット1Lv>,<スロット2Lv>,<スロット3Lv> です。");
    			br8 = element("br");
    			t16 = space();
    			a1 = element("a");
    			a1.textContent = "泣きシミュ";
    			t18 = text(" さんでそのままインポートできます。");
    			br9 = element("br");
    			t19 = space();
    			br10 = element("br");
    			t20 = text("\n        キャプチャ動画の読み取りと、護石管理ページとの関係については、");
    			a2 = element("a");
    			a2.textContent = "護石管理";
    			t22 = text("を参照してください。");
    			br11 = element("br");
    			t23 = space();
    			br12 = element("br");
    			t24 = text("\n        (注意)");
    			br13 = element("br");
    			t25 = text("\n        - ");
    			span0 = element("span");
    			span0.textContent = "装飾品をつけたままだと、装飾品分のスキルも読み込まれてしまいます。";
    			t27 = text(" (一括解除が有用です)");
    			br14 = element("br");
    			t28 = text("\n        - キャプチャ動画のファイル名はデフォルトのまま使用することを推奨します。");
    			br15 = element("br");
    			t29 = space();
    			div2 = element("div");
    			create_component(lightbox0.$$.fragment);
    			t30 = space();
    			div7 = element("div");
    			div6 = element("div");
    			h22 = element("h2");
    			h22.textContent = "■ 護石リアルタイムスキャン(β)";
    			t32 = space();
    			p2 = element("p");
    			t33 = text("護石のスキルやスロットを自動読み取りします。");
    			br16 = element("br");
    			t34 = text("\n        Nintendo Switch の映像をキャプチャボードで取り込み、リアルタイムにスキャンを行うことができます。");
    			br17 = element("br");
    			t35 = text("\n        市販のキャプチャボードの購入が必要ですが、キャプチャ動画を用意する必要がなくなります。");
    			br18 = element("br");
    			t36 = space();
    			br19 = element("br");
    			t37 = text("\n        現時点では 720p での入力にのみ対応しています。");
    			br20 = element("br");
    			t38 = text("\n        キャプチャがより高解像度の場合は、Switch 側の設定で 720p にするか、");
    			br21 = element("br");
    			t39 = text("\n        OBS で 1280 x 720 に落として入力していただくことで使用できるかと思います。");
    			br22 = element("br");
    			t40 = space();
    			br23 = element("br");
    			t41 = text("\n        動画からのスキャン同様、読み込んだ護石は護石管理ページで確認したり、エクスポートすることができます。");
    			br24 = element("br");
    			t42 = space();
    			br25 = element("br");
    			t43 = text("\n        (注意)");
    			br26 = element("br");
    			t44 = space();
    			span1 = element("span");
    			span1.textContent = "装飾品をつけたままだと、装飾品分のスキルも読み込まれてしまいます。";
    			t46 = text(" (一括解除が有用です)");
    			br27 = element("br");
    			t47 = space();
    			div5 = element("div");
    			create_component(lightbox1.$$.fragment);
    			t48 = space();
    			div10 = element("div");
    			div9 = element("div");
    			h23 = element("h2");
    			h23.textContent = "■ 護石管理";
    			t50 = space();
    			p3 = element("p");
    			t51 = text("スキャンした護石の一覧を見ることができます。");
    			br28 = element("br");
    			t52 = text("\n        護石データは蓄積され、次回、同じブラウザで開いた時にも保持されます。");
    			br29 = element("br");
    			t53 = space();
    			br30 = element("br");
    			t54 = text("\n        護石一覧における表示順は、動画読み込み順 → ゲーム内での表示順です。");
    			br31 = element("br");
    			t55 = text("\n        動画を撮る際に、レア度ソートし、1 ページ目から順に撮ることで、輪廻錬金での表示順と同じになります。");
    			br32 = element("br");
    			t56 = space();
    			br33 = element("br");
    			t57 = text("\n        表中の \"合計スキルレベル\" は、");
    			br34 = element("br");
    			t58 = space();
    			span2 = element("span");
    			span2.textContent = "(スキルを装飾品換算した場合のスロットLv) × (スキルLv) + (スロットLv)";
    			br35 = element("br");
    			t60 = text("\n        として計算しています。");
    			br36 = element("br");
    			t61 = space();
    			br37 = element("br");
    			t62 = text("\n        例: 納刀術2, ひるみ軽減1, スロット 3-1-0 の場合");
    			br38 = element("br");
    			t63 = space();
    			span3 = element("span");
    			span3.textContent = "2 × 2 + 1 × 1 + 3 + 1 + 0 = 9";
    			br39 = element("br");
    			t65 = space();
    			br40 = element("br");
    			t66 = text("\n        右端の画像ボタンを押すことで、スキャン時のスクリーンショットを確認できます。");
    			br41 = element("br");
    			t67 = text("\n        右端に上向き矢印がある場合、上位互換の護石があります。クリックで該当の護石を確認することができます。");
    			br42 = element("br");
    			t68 = space();
    			br43 = element("br");
    			t69 = space();
    			div8 = element("div");
    			create_component(lightbox2.$$.fragment);
    			t70 = space();
    			create_component(lightbox3.$$.fragment);
    			t71 = space();
    			div13 = element("div");
    			div12 = element("div");
    			h24 = element("h2");
    			h24.textContent = "■ 護石スペック検索";
    			t73 = space();
    			p4 = element("p");
    			p4.textContent = "スキャンした護石を検索することができます。\n        装飾品でスキルが実現できる場合も検索対象に含まれます。";
    			t75 = space();
    			div11 = element("div");
    			create_component(lightbox4.$$.fragment);
    			t76 = space();
    			div16 = element("div");
    			div15 = element("div");
    			h25 = element("h2");
    			h25.textContent = "■ 輪廻サポート(β)";
    			t78 = space();
    			p5 = element("p");
    			t79 = text("輪廻錬金を行う際に、表示中の護石の上位互換護石をリアルタイム表示する機能です。");
    			br44 = element("br");
    			t80 = text("\n        カーソル位置のスキャンがうまくいかない場合、スライダーで感度を調整することができます。");
    			br45 = element("br");
    			t81 = space();
    			br46 = element("br");
    			t82 = space();
    			span4 = element("span");
    			t83 = text("必ずしもスキャンが正しいとは限りません。");
    			br47 = element("br");
    			t84 = text("\n          輪廻に使う時は記録されているスクリーンショットを確認するなど、十分な確認を行ってください。");
    			t85 = space();
    			div14 = element("div");
    			create_component(lightbox5.$$.fragment);
    			t86 = space();
    			div18 = element("div");
    			div17 = element("div");
    			h26 = element("h2");
    			h26.textContent = "■ 売却サポート(β)";
    			t88 = space();
    			p6 = element("p");
    			t89 = text("護石の売却を行う際に、表示中の護石の上位互換護石をリアルタイム表示する機能です。");
    			br48 = element("br");
    			t90 = text("\n        カーソル位置のスキャンがうまくいかない場合、スライダーで感度を調整することができます。");
    			br49 = element("br");
    			t91 = space();
    			br50 = element("br");
    			t92 = space();
    			span5 = element("span");
    			t93 = text("必ずしもスキャンが正しいとは限りません。");
    			br51 = element("br");
    			t94 = text("\n          売却時は記録されているスクリーンショットを確認するなど、十分な確認を行ってください。");
    			t95 = space();
    			div20 = element("div");
    			div19 = element("div");
    			h27 = element("h2");
    			h27.textContent = "■ 護石インポート・エクスポート";
    			t97 = space();
    			p7 = element("p");
    			t98 = text("スキャンした護石のエクスポート・インポートが行えます。");
    			br52 = element("br");
    			t99 = text("\n        入出力形式は、護石スキャン時と同様です。");
    			br53 = element("br");
    			t100 = space();
    			br54 = element("br");
    			t101 = space();
    			span6 = element("span");
    			t102 = text("上書きインポートを使用すると、保存している護石情報が全て失なわれます。");
    			br55 = element("br");
    			t103 = text("\n          また、インポート・エクスポートでは画像を扱っていないので、エクスポート → 上書きインポートすると護石画像が見れなくなります。");
    			br56 = element("br");
    			t104 = space();
    			div22 = element("div");
    			div21 = element("div");
    			h28 = element("h2");
    			h28.textContent = "■ FAQ";
    			t106 = space();
    			h3 = element("h3");
    			h3.textContent = "Q. 護石管理のページで表示される護石がスキャンした数より少ないです";
    			t108 = space();
    			p8 = element("p");
    			t109 = text("A.");
    			br57 = element("br");
    			t110 = text("\n        完全に同性能 (スキル、スキルレベル、スロット全て同じ) 護石は登録されない仕様になっています。");
    			br58 = element("br");
    			t111 = space();
    			br59 = element("br");
    			t112 = text("\n        これは、複数の動画を読み取った時に、同一の護石か別の同性能護石か判別する術がないためです。");
    			br60 = element("br");
    			t113 = text("\n        「重複していると思って輪廻に使ったら、同じ護石が登録されているだけだった」");
    			br61 = element("br");
    			t114 = text("\n        という事態を考慮し、安全重視の仕様にしています。");
    			br62 = element("br");
    			t115 = space();
    			br63 = element("br");
    			t116 = text("\n        スキャン時の出力は重複も含めて表示されるので、必要があればそちらをご利用下さい。");
    			t117 = space();
    			div24 = element("div");
    			div23 = element("div");
    			h29 = element("h2");
    			h29.textContent = "■ お問い合わせ";
    			t119 = space();
    			p9 = element("p");
    			t120 = text("不具合報告や要望は ");
    			a3 = element("a");
    			a3.textContent = "GitHub issue";
    			t122 = text(" にてお願いします。");
    			attr_dev(h20, "class", "svelte-1b50fsn");
    			add_location(h20, file$t, 6, 6, 181);
    			add_location(br0, file$t, 8, 30, 235);
    			add_location(br1, file$t, 9, 31, 271);
    			add_location(br2, file$t, 10, 8, 284);
    			add_location(br3, file$t, 11, 41, 330);
    			add_location(br4, file$t, 12, 28, 363);
    			attr_dev(p0, "class", "svelte-1b50fsn");
    			add_location(p0, file$t, 7, 6, 201);
    			attr_dev(div0, "class", "card-body");
    			add_location(div0, file$t, 5, 4, 151);
    			attr_dev(div1, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div1, file$t, 4, 2, 98);
    			attr_dev(h21, "class", "svelte-1b50fsn");
    			add_location(h21, file$t, 19, 6, 485);
    			add_location(br5, file$t, 21, 30, 543);
    			attr_dev(a0, "href", "sample/input.mp4");
    			add_location(a0, file$t, 23, 9, 616);
    			add_location(br6, file$t, 23, 44, 651);
    			add_location(br7, file$t, 24, 8, 664);
    			add_location(br8, file$t, 25, 121, 790);
    			attr_dev(a1, "href", "https://mhrise.wiki-db.com/sim/");
    			add_location(a1, file$t, 26, 8, 803);
    			add_location(br9, file$t, 26, 77, 872);
    			add_location(br10, file$t, 27, 8, 885);
    			attr_dev(a2, "href", "#h2-charm-manager");
    			add_location(a2, file$t, 28, 39, 929);
    			add_location(br11, file$t, 28, 85, 975);
    			add_location(br12, file$t, 29, 8, 988);
    			add_location(br13, file$t, 30, 12, 1005);
    			set_style(span0, "color", "red");
    			add_location(span0, file$t, 31, 10, 1020);
    			add_location(br14, file$t, 31, 87, 1097);
    			add_location(br15, file$t, 32, 45, 1147);
    			attr_dev(p1, "class", "svelte-1b50fsn");
    			add_location(p1, file$t, 20, 6, 509);
    			attr_dev(div2, "class", "lightboxes svelte-1b50fsn");
    			add_location(div2, file$t, 35, 6, 1170);
    			attr_dev(div3, "class", "card-body");
    			add_location(div3, file$t, 18, 4, 455);
    			attr_dev(div4, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div4, file$t, 17, 2, 402);
    			attr_dev(h22, "class", "svelte-1b50fsn");
    			add_location(h22, file$t, 45, 6, 1501);
    			add_location(br16, file$t, 47, 30, 1568);
    			add_location(br17, file$t, 48, 64, 1637);
    			add_location(br18, file$t, 49, 51, 1693);
    			add_location(br19, file$t, 50, 8, 1706);
    			add_location(br20, file$t, 51, 34, 1745);
    			add_location(br21, file$t, 52, 48, 1798);
    			add_location(br22, file$t, 53, 53, 1856);
    			add_location(br23, file$t, 54, 8, 1869);
    			add_location(br24, file$t, 55, 58, 1932);
    			add_location(br25, file$t, 56, 8, 1945);
    			add_location(br26, file$t, 57, 12, 1962);
    			set_style(span1, "color", "red");
    			add_location(span1, file$t, 58, 8, 1975);
    			add_location(br27, file$t, 58, 85, 2052);
    			attr_dev(p2, "class", "svelte-1b50fsn");
    			add_location(p2, file$t, 46, 6, 1534);
    			attr_dev(div5, "class", "lightboxes svelte-1b50fsn");
    			add_location(div5, file$t, 61, 6, 2075);
    			attr_dev(div6, "class", "card-body");
    			add_location(div6, file$t, 44, 4, 1471);
    			attr_dev(div7, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div7, file$t, 43, 2, 1418);
    			attr_dev(h23, "id", "h2-charm-manager");
    			attr_dev(h23, "class", "svelte-1b50fsn");
    			add_location(h23, file$t, 71, 6, 2416);
    			add_location(br28, file$t, 73, 30, 2494);
    			add_location(br29, file$t, 74, 42, 2541);
    			add_location(br30, file$t, 75, 8, 2554);
    			add_location(br31, file$t, 76, 43, 2602);
    			add_location(br32, file$t, 77, 58, 2665);
    			add_location(br33, file$t, 78, 8, 2678);
    			add_location(br34, file$t, 79, 25, 2708);
    			attr_dev(span2, "class", "px-3 font-weight-bold");
    			add_location(span2, file$t, 80, 8, 2721);
    			add_location(br35, file$t, 80, 94, 2807);
    			add_location(br36, file$t, 81, 19, 2831);
    			add_location(br37, file$t, 82, 8, 2844);
    			add_location(br38, file$t, 83, 39, 2888);
    			attr_dev(span3, "class", "px-3");
    			add_location(span3, file$t, 84, 8, 2901);
    			add_location(br39, file$t, 84, 63, 2956);
    			add_location(br40, file$t, 85, 8, 2969);
    			add_location(br41, file$t, 86, 46, 3020);
    			add_location(br42, file$t, 87, 58, 3083);
    			add_location(br43, file$t, 88, 8, 3096);
    			attr_dev(p3, "class", "svelte-1b50fsn");
    			add_location(p3, file$t, 72, 6, 2460);
    			attr_dev(div8, "class", "lightboxes svelte-1b50fsn");
    			add_location(div8, file$t, 93, 6, 3259);
    			attr_dev(div9, "class", "card-body");
    			add_location(div9, file$t, 70, 4, 2386);
    			attr_dev(div10, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div10, file$t, 69, 2, 2333);
    			attr_dev(h24, "class", "svelte-1b50fsn");
    			add_location(h24, file$t, 106, 6, 3780);
    			attr_dev(p4, "class", "svelte-1b50fsn");
    			add_location(p4, file$t, 107, 6, 3806);
    			attr_dev(div11, "class", "lightboxes svelte-1b50fsn");
    			add_location(div11, file$t, 112, 6, 3894);
    			attr_dev(div12, "class", "card-body");
    			add_location(div12, file$t, 105, 4, 3750);
    			attr_dev(div13, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div13, file$t, 104, 2, 3697);
    			attr_dev(h25, "class", "svelte-1b50fsn");
    			add_location(h25, file$t, 122, 6, 4221);
    			add_location(br44, file$t, 124, 47, 4299);
    			add_location(br45, file$t, 125, 51, 4355);
    			add_location(br46, file$t, 126, 8, 4368);
    			add_location(br47, file$t, 128, 30, 4437);
    			set_style(span4, "color", "red");
    			add_location(span4, file$t, 127, 8, 4381);
    			attr_dev(p5, "class", "svelte-1b50fsn");
    			add_location(p5, file$t, 123, 6, 4248);
    			attr_dev(div14, "class", "lightboxes svelte-1b50fsn");
    			add_location(div14, file$t, 133, 6, 4532);
    			attr_dev(div15, "class", "card-body");
    			add_location(div15, file$t, 121, 4, 4191);
    			attr_dev(div16, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div16, file$t, 120, 2, 4138);
    			attr_dev(h26, "class", "svelte-1b50fsn");
    			add_location(h26, file$t, 143, 6, 4873);
    			add_location(br48, file$t, 145, 48, 4952);
    			add_location(br49, file$t, 146, 51, 5008);
    			add_location(br50, file$t, 147, 8, 5021);
    			add_location(br51, file$t, 149, 30, 5090);
    			set_style(span5, "color", "red");
    			add_location(span5, file$t, 148, 8, 5034);
    			attr_dev(p6, "class", "svelte-1b50fsn");
    			add_location(p6, file$t, 144, 6, 4900);
    			attr_dev(div17, "class", "card-body");
    			add_location(div17, file$t, 142, 4, 4843);
    			attr_dev(div18, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div18, file$t, 141, 2, 4790);
    			attr_dev(h27, "class", "svelte-1b50fsn");
    			add_location(h27, file$t, 158, 6, 5281);
    			add_location(br52, file$t, 160, 35, 5352);
    			add_location(br53, file$t, 161, 28, 5385);
    			add_location(br54, file$t, 162, 8, 5398);
    			add_location(br55, file$t, 164, 45, 5482);
    			add_location(br56, file$t, 165, 73, 5560);
    			set_style(span6, "color", "red");
    			add_location(span6, file$t, 163, 8, 5411);
    			attr_dev(p7, "class", "svelte-1b50fsn");
    			add_location(p7, file$t, 159, 6, 5313);
    			attr_dev(div19, "class", "card-body");
    			add_location(div19, file$t, 157, 4, 5251);
    			attr_dev(div20, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div20, file$t, 156, 2, 5198);
    			attr_dev(h28, "class", "svelte-1b50fsn");
    			add_location(h28, file$t, 173, 6, 5698);
    			attr_dev(h3, "class", "svelte-1b50fsn");
    			add_location(h3, file$t, 174, 6, 5719);
    			add_location(br57, file$t, 178, 10, 5799);
    			add_location(br58, file$t, 179, 56, 5860);
    			add_location(br59, file$t, 180, 8, 5873);
    			add_location(br60, file$t, 181, 53, 5931);
    			add_location(br61, file$t, 182, 45, 5981);
    			add_location(br62, file$t, 183, 32, 6018);
    			add_location(br63, file$t, 184, 8, 6031);
    			attr_dev(p8, "class", "svelte-1b50fsn");
    			add_location(p8, file$t, 177, 6, 5785);
    			attr_dev(div21, "class", "card-body");
    			add_location(div21, file$t, 172, 4, 5668);
    			attr_dev(div22, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div22, file$t, 171, 2, 5615);
    			attr_dev(h29, "class", "svelte-1b50fsn");
    			add_location(h29, file$t, 197, 6, 6410);
    			attr_dev(a3, "href", "https://github.com/ks-yuzu/mhrise-charm-scanner-web/issues");
    			add_location(a3, file$t, 199, 18, 6456);
    			attr_dev(p9, "class", "svelte-1b50fsn");
    			add_location(p9, file$t, 198, 6, 6434);
    			attr_dev(div23, "class", "card-body");
    			add_location(div23, file$t, 196, 4, 6380);
    			attr_dev(div24, "class", "card border border-light shadow-sm svelte-1b50fsn");
    			add_location(div24, file$t, 195, 2, 6327);
    			attr_dev(div25, "id", "description");
    			attr_dev(div25, "class", "svelte-1b50fsn");
    			add_location(div25, file$t, 3, 0, 73);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div25, anchor);
    			append_dev(div25, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h20);
    			append_dev(div0, t1);
    			append_dev(div0, p0);
    			append_dev(p0, t2);
    			append_dev(p0, br0);
    			append_dev(p0, t3);
    			append_dev(p0, br1);
    			append_dev(p0, t4);
    			append_dev(p0, br2);
    			append_dev(p0, t5);
    			append_dev(p0, br3);
    			append_dev(p0, t6);
    			append_dev(p0, br4);
    			append_dev(div25, t7);
    			append_dev(div25, div4);
    			append_dev(div4, div3);
    			append_dev(div3, h21);
    			append_dev(div3, t9);
    			append_dev(div3, p1);
    			append_dev(p1, t10);
    			append_dev(p1, br5);
    			append_dev(p1, t11);
    			append_dev(p1, a0);
    			append_dev(p1, t13);
    			append_dev(p1, br6);
    			append_dev(p1, t14);
    			append_dev(p1, br7);
    			append_dev(p1, t15);
    			append_dev(p1, br8);
    			append_dev(p1, t16);
    			append_dev(p1, a1);
    			append_dev(p1, t18);
    			append_dev(p1, br9);
    			append_dev(p1, t19);
    			append_dev(p1, br10);
    			append_dev(p1, t20);
    			append_dev(p1, a2);
    			append_dev(p1, t22);
    			append_dev(p1, br11);
    			append_dev(p1, t23);
    			append_dev(p1, br12);
    			append_dev(p1, t24);
    			append_dev(p1, br13);
    			append_dev(p1, t25);
    			append_dev(p1, span0);
    			append_dev(p1, t27);
    			append_dev(p1, br14);
    			append_dev(p1, t28);
    			append_dev(p1, br15);
    			append_dev(div3, t29);
    			append_dev(div3, div2);
    			mount_component(lightbox0, div2, null);
    			append_dev(div25, t30);
    			append_dev(div25, div7);
    			append_dev(div7, div6);
    			append_dev(div6, h22);
    			append_dev(div6, t32);
    			append_dev(div6, p2);
    			append_dev(p2, t33);
    			append_dev(p2, br16);
    			append_dev(p2, t34);
    			append_dev(p2, br17);
    			append_dev(p2, t35);
    			append_dev(p2, br18);
    			append_dev(p2, t36);
    			append_dev(p2, br19);
    			append_dev(p2, t37);
    			append_dev(p2, br20);
    			append_dev(p2, t38);
    			append_dev(p2, br21);
    			append_dev(p2, t39);
    			append_dev(p2, br22);
    			append_dev(p2, t40);
    			append_dev(p2, br23);
    			append_dev(p2, t41);
    			append_dev(p2, br24);
    			append_dev(p2, t42);
    			append_dev(p2, br25);
    			append_dev(p2, t43);
    			append_dev(p2, br26);
    			append_dev(p2, t44);
    			append_dev(p2, span1);
    			append_dev(p2, t46);
    			append_dev(p2, br27);
    			append_dev(div6, t47);
    			append_dev(div6, div5);
    			mount_component(lightbox1, div5, null);
    			append_dev(div25, t48);
    			append_dev(div25, div10);
    			append_dev(div10, div9);
    			append_dev(div9, h23);
    			append_dev(div9, t50);
    			append_dev(div9, p3);
    			append_dev(p3, t51);
    			append_dev(p3, br28);
    			append_dev(p3, t52);
    			append_dev(p3, br29);
    			append_dev(p3, t53);
    			append_dev(p3, br30);
    			append_dev(p3, t54);
    			append_dev(p3, br31);
    			append_dev(p3, t55);
    			append_dev(p3, br32);
    			append_dev(p3, t56);
    			append_dev(p3, br33);
    			append_dev(p3, t57);
    			append_dev(p3, br34);
    			append_dev(p3, t58);
    			append_dev(p3, span2);
    			append_dev(p3, br35);
    			append_dev(p3, t60);
    			append_dev(p3, br36);
    			append_dev(p3, t61);
    			append_dev(p3, br37);
    			append_dev(p3, t62);
    			append_dev(p3, br38);
    			append_dev(p3, t63);
    			append_dev(p3, span3);
    			append_dev(p3, br39);
    			append_dev(p3, t65);
    			append_dev(p3, br40);
    			append_dev(p3, t66);
    			append_dev(p3, br41);
    			append_dev(p3, t67);
    			append_dev(p3, br42);
    			append_dev(p3, t68);
    			append_dev(p3, br43);
    			append_dev(div9, t69);
    			append_dev(div9, div8);
    			mount_component(lightbox2, div8, null);
    			append_dev(div8, t70);
    			mount_component(lightbox3, div8, null);
    			append_dev(div25, t71);
    			append_dev(div25, div13);
    			append_dev(div13, div12);
    			append_dev(div12, h24);
    			append_dev(div12, t73);
    			append_dev(div12, p4);
    			append_dev(div12, t75);
    			append_dev(div12, div11);
    			mount_component(lightbox4, div11, null);
    			append_dev(div25, t76);
    			append_dev(div25, div16);
    			append_dev(div16, div15);
    			append_dev(div15, h25);
    			append_dev(div15, t78);
    			append_dev(div15, p5);
    			append_dev(p5, t79);
    			append_dev(p5, br44);
    			append_dev(p5, t80);
    			append_dev(p5, br45);
    			append_dev(p5, t81);
    			append_dev(p5, br46);
    			append_dev(p5, t82);
    			append_dev(p5, span4);
    			append_dev(span4, t83);
    			append_dev(span4, br47);
    			append_dev(span4, t84);
    			append_dev(div15, t85);
    			append_dev(div15, div14);
    			mount_component(lightbox5, div14, null);
    			append_dev(div25, t86);
    			append_dev(div25, div18);
    			append_dev(div18, div17);
    			append_dev(div17, h26);
    			append_dev(div17, t88);
    			append_dev(div17, p6);
    			append_dev(p6, t89);
    			append_dev(p6, br48);
    			append_dev(p6, t90);
    			append_dev(p6, br49);
    			append_dev(p6, t91);
    			append_dev(p6, br50);
    			append_dev(p6, t92);
    			append_dev(p6, span5);
    			append_dev(span5, t93);
    			append_dev(span5, br51);
    			append_dev(span5, t94);
    			append_dev(div25, t95);
    			append_dev(div25, div20);
    			append_dev(div20, div19);
    			append_dev(div19, h27);
    			append_dev(div19, t97);
    			append_dev(div19, p7);
    			append_dev(p7, t98);
    			append_dev(p7, br52);
    			append_dev(p7, t99);
    			append_dev(p7, br53);
    			append_dev(p7, t100);
    			append_dev(p7, br54);
    			append_dev(p7, t101);
    			append_dev(p7, span6);
    			append_dev(span6, t102);
    			append_dev(span6, br55);
    			append_dev(span6, t103);
    			append_dev(span6, br56);
    			append_dev(div25, t104);
    			append_dev(div25, div22);
    			append_dev(div22, div21);
    			append_dev(div21, h28);
    			append_dev(div21, t106);
    			append_dev(div21, h3);
    			append_dev(div21, t108);
    			append_dev(div21, p8);
    			append_dev(p8, t109);
    			append_dev(p8, br57);
    			append_dev(p8, t110);
    			append_dev(p8, br58);
    			append_dev(p8, t111);
    			append_dev(p8, br59);
    			append_dev(p8, t112);
    			append_dev(p8, br60);
    			append_dev(p8, t113);
    			append_dev(p8, br61);
    			append_dev(p8, t114);
    			append_dev(p8, br62);
    			append_dev(p8, t115);
    			append_dev(p8, br63);
    			append_dev(p8, t116);
    			append_dev(div25, t117);
    			append_dev(div25, div24);
    			append_dev(div24, div23);
    			append_dev(div23, h29);
    			append_dev(div23, t119);
    			append_dev(div23, p9);
    			append_dev(p9, t120);
    			append_dev(p9, a3);
    			append_dev(p9, t122);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const lightbox0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox0_changes.$$scope = { dirty, ctx };
    			}

    			lightbox0.$set(lightbox0_changes);
    			const lightbox1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox1_changes.$$scope = { dirty, ctx };
    			}

    			lightbox1.$set(lightbox1_changes);
    			const lightbox2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox2_changes.$$scope = { dirty, ctx };
    			}

    			lightbox2.$set(lightbox2_changes);
    			const lightbox3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox3_changes.$$scope = { dirty, ctx };
    			}

    			lightbox3.$set(lightbox3_changes);
    			const lightbox4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox4_changes.$$scope = { dirty, ctx };
    			}

    			lightbox4.$set(lightbox4_changes);
    			const lightbox5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				lightbox5_changes.$$scope = { dirty, ctx };
    			}

    			lightbox5.$set(lightbox5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lightbox0.$$.fragment, local);
    			transition_in(lightbox1.$$.fragment, local);
    			transition_in(lightbox2.$$.fragment, local);
    			transition_in(lightbox3.$$.fragment, local);
    			transition_in(lightbox4.$$.fragment, local);
    			transition_in(lightbox5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lightbox0.$$.fragment, local);
    			transition_out(lightbox1.$$.fragment, local);
    			transition_out(lightbox2.$$.fragment, local);
    			transition_out(lightbox3.$$.fragment, local);
    			transition_out(lightbox4.$$.fragment, local);
    			transition_out(lightbox5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div25);
    			destroy_component(lightbox0);
    			destroy_component(lightbox1);
    			destroy_component(lightbox2);
    			destroy_component(lightbox3);
    			destroy_component(lightbox4);
    			destroy_component(lightbox5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Description", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Lightbox });
    	return [];
    }

    class Description extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Description",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    function clean($$props, extra_keys) {
      let keys = ["children", "$$scope", "$$slots"].concat(extra_keys);
      const rest = {};
      for (const key of Object.keys($$props)) {
        if (!(keys.includes(key))) {
          rest[key] = $$props[key];
        }
      }
      return rest;
    }

    function getOriginalBodyPadding() {
      const style = window ? window.getComputedStyle(document.body, null) : {};

      return parseInt((style && style.getPropertyValue('padding-right')) || 0, 10);
    }

    function getScrollbarWidth() {
      let scrollDiv = document.createElement('div');
      // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113
      scrollDiv.style.position = 'absolute';
      scrollDiv.style.top = '-9999px';
      scrollDiv.style.width = '50px';
      scrollDiv.style.height = '50px';
      scrollDiv.style.overflow = 'scroll';
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    }

    function setScrollbarWidth(padding) {
      document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
    }

    function isBodyOverflowing() {
      return window ? document.body.clientWidth < window.innerWidth : false;
    }

    function conditionallyUpdateScrollbar() {
      const scrollbarWidth = getScrollbarWidth();
      // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433
      const fixedContent = document.querySelectorAll(
        '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'
      )[0];
      const bodyPadding = fixedContent
        ? parseInt(fixedContent.style.paddingRight || 0, 10)
        : 0;

      if (isBodyOverflowing()) {
        setScrollbarWidth(bodyPadding + scrollbarWidth);
      }
    }

    function browserEvent(target, ...args) {
      target.addEventListener(...args);

      return () => target.removeEventListener(...args);
    }

    function toVal(mix) {
      var k, y, str = '';
      if (mix) {
        if (typeof mix === 'object') {
          if (Array.isArray(mix)) {
            for (k = 0; k < mix.length; k++) {
              if (mix[k] && (y = toVal(mix[k]))) {
                str && (str += ' ');
                str += y;
              }
            }
          } else {
            for (k in mix) {
              if (mix[k] && (y = toVal(k))) {
                str && (str += ' ');
                str += y;
              }
            }
          }
        } else if (typeof mix !== 'boolean' && !mix.call) {
          str && (str += ' ');
          str += mix;
        }
      }
      return str;
    }

    function clsx() {
      let i = 0, x, str = '';
      while (i < arguments.length) {
        if (x = toVal(arguments[i++])) {
          str && (str += ' ');
          str += x;
        }
      }
      return str;
    }

    function forwardEventsBuilder(component, additionalEvents = []) {
      const events = [
        'focus', 'blur', 'change', 'input', 'update','submit',
        'fullscreenchange', 'fullscreenerror', 'scroll',
        'cut', 'copy', 'paste',
        'keydown', 'keypress', 'keyup',
        'auxclick', 'click', 'contextmenu', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'pointerlockchange', 'pointerlockerror', 'select', 'wheel',
        'drag', 'dragend', 'dragenter', 'dragstart', 'dragleave', 'dragover', 'drop',
        'touchcancel', 'touchend', 'touchmove', 'touchstart',
        'pointerover', 'pointerenter', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerout', 'pointerleave', 'gotpointercapture', 'lostpointercapture',
        ...additionalEvents
      ];

      function forward(e) {
        bubble(component, e);
      }

      return node => {
        const destructors = [];

        for (let i = 0; i < events.length; i++) {
          destructors.push(listen(node, events[i], forward));
        }

        return {
          destroy: () => {
            for (let i = 0; i < destructors.length; i++) {
              destructors[i]();
            }
          }
        }
      };
    }

    /* node_modules/mdbsvelte/src/MDBBtn.svelte generated by Svelte v3.38.2 */
    const file$s = "node_modules/mdbsvelte/src/MDBBtn.svelte";

    // (64:0) {:else}
    function create_else_block_1$2(ctx) {
    	let button;
    	let button_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	let button_levels = [
    		/*props*/ ctx[12],
    		{ type: /*type*/ ctx[4] },
    		{ class: /*classes*/ ctx[9] },
    		{ disabled: /*disabled*/ ctx[3] },
    		{ value: /*value*/ ctx[6] },
    		{
    			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[10]
    		},
    		{ style: /*style*/ ctx[0] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$s, 64, 2, 1463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			/*button_binding*/ ctx[23](button);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[11].call(null, button));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*close, children, $$scope*/ 2097158) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				/*props*/ ctx[12],
    				(!current || dirty & /*type*/ 16) && { type: /*type*/ ctx[4] },
    				(!current || dirty & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				(!current || dirty & /*disabled*/ 8) && { disabled: /*disabled*/ ctx[3] },
    				(!current || dirty & /*value*/ 64) && { value: /*value*/ ctx[6] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 1280 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[10])) && { "aria-label": button_aria_label_value },
    				(!current || dirty & /*style*/ 1) && { style: /*style*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*button_binding*/ ctx[23](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(64:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (50:0) {#if href}
    function create_if_block$c(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let a_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$a, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*props*/ ctx[12],
    		{ class: /*classes*/ ctx[9] },
    		{ disabled: /*disabled*/ ctx[3] },
    		{ href: /*href*/ ctx[5] },
    		{
    			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[10]
    		},
    		{ style: /*style*/ ctx[0] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$s, 50, 2, 1232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[11].call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				/*props*/ ctx[12],
    				(!current || dirty & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
    				(!current || dirty & /*disabled*/ 8) && { disabled: /*disabled*/ ctx[3] },
    				(!current || dirty & /*href*/ 32) && { href: /*href*/ ctx[5] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 1280 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[10])) && { "aria-label": a_aria_label_value },
    				(!current || dirty & /*style*/ 1) && { style: /*style*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(50:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (80:6) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(80:6) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (78:25) 
    function create_if_block_3$5(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(78:25) ",
    		ctx
    	});

    	return block_1;
    }

    // (76:6) {#if close}
    function create_if_block_2$9(ctx) {
    	let span;

    	const block_1 = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "×";
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$s, 76, 8, 1694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(76:6) {#if close}",
    		ctx
    	});

    	return block_1;
    }

    // (75:10)        
    function fallback_block$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$9, create_if_block_3$5, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*close*/ ctx[2]) return 0;
    		if (/*children*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(75:10)        ",
    		ctx
    	});

    	return block_1;
    }

    // (60:4) {:else}
    function create_else_block$9(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(60:4) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (58:4) {#if children}
    function create_if_block_1$a(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(58:4) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$v(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$c, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let ariaLabel;
    	let classes;
    	let defaultAriaLabel;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBBtn", slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { class: className = "" } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { children = undefined } = $$props;
    	let { close = false } = $$props;
    	let { color } = $$props;
    	let { disabled = false } = $$props;
    	let { type = "button" } = $$props;
    	let { href = "" } = $$props;
    	let { outline = false } = $$props;
    	let { size = "" } = $$props;
    	let { style = "" } = $$props;
    	let { value = "" } = $$props;
    	let { gradient } = $$props;
    	let domElement;
    	let { rounded } = $$props;

    	if (rounded) {
    		style = "border-radius: 10em" + style;
    	}

    	if (!color) {
    		href ? color = "primary" : color = "default";
    	}

    	const props = clean($$props, ["color", "gradient", "value", "style", "size"]);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domElement = $$value;
    			$$invalidate(7, domElement);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(14, className = $$new_props.class);
    		if ("active" in $$new_props) $$invalidate(15, active = $$new_props.active);
    		if ("block" in $$new_props) $$invalidate(16, block = $$new_props.block);
    		if ("children" in $$new_props) $$invalidate(1, children = $$new_props.children);
    		if ("close" in $$new_props) $$invalidate(2, close = $$new_props.close);
    		if ("color" in $$new_props) $$invalidate(13, color = $$new_props.color);
    		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ("type" in $$new_props) $$invalidate(4, type = $$new_props.type);
    		if ("href" in $$new_props) $$invalidate(5, href = $$new_props.href);
    		if ("outline" in $$new_props) $$invalidate(17, outline = $$new_props.outline);
    		if ("size" in $$new_props) $$invalidate(18, size = $$new_props.size);
    		if ("style" in $$new_props) $$invalidate(0, style = $$new_props.style);
    		if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
    		if ("gradient" in $$new_props) $$invalidate(19, gradient = $$new_props.gradient);
    		if ("rounded" in $$new_props) $$invalidate(20, rounded = $$new_props.rounded);
    		if ("$$scope" in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		clean,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		active,
    		block,
    		children,
    		close,
    		color,
    		disabled,
    		type,
    		href,
    		outline,
    		size,
    		style,
    		value,
    		gradient,
    		domElement,
    		rounded,
    		props,
    		ariaLabel,
    		classes,
    		defaultAriaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(14, className = $$new_props.className);
    		if ("active" in $$props) $$invalidate(15, active = $$new_props.active);
    		if ("block" in $$props) $$invalidate(16, block = $$new_props.block);
    		if ("children" in $$props) $$invalidate(1, children = $$new_props.children);
    		if ("close" in $$props) $$invalidate(2, close = $$new_props.close);
    		if ("color" in $$props) $$invalidate(13, color = $$new_props.color);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ("type" in $$props) $$invalidate(4, type = $$new_props.type);
    		if ("href" in $$props) $$invalidate(5, href = $$new_props.href);
    		if ("outline" in $$props) $$invalidate(17, outline = $$new_props.outline);
    		if ("size" in $$props) $$invalidate(18, size = $$new_props.size);
    		if ("style" in $$props) $$invalidate(0, style = $$new_props.style);
    		if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
    		if ("gradient" in $$props) $$invalidate(19, gradient = $$new_props.gradient);
    		if ("domElement" in $$props) $$invalidate(7, domElement = $$new_props.domElement);
    		if ("rounded" in $$props) $$invalidate(20, rounded = $$new_props.rounded);
    		if ("ariaLabel" in $$props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
    		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
    		if ("defaultAriaLabel" in $$props) $$invalidate(10, defaultAriaLabel = $$new_props.defaultAriaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(8, ariaLabel = $$props["aria-label"]);

    		if ($$self.$$.dirty & /*className, close, gradient, outline, color, size, block, active*/ 1040388) {
    			$$invalidate(9, classes = clsx(
    				className,
    				{ close },
    				close || "btn waves-effect waves-light",
    				gradient
    				? `${gradient}-gradient`
    				: close || `btn${outline ? "-outline" : ""}-${color}`,
    				size ? `btn-${size}` : false,
    				block ? "btn-block" : false,
    				{ active }
    			));
    		}

    		if ($$self.$$.dirty & /*close*/ 4) {
    			$$invalidate(10, defaultAriaLabel = close ? "Close" : null);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		style,
    		children,
    		close,
    		disabled,
    		type,
    		href,
    		value,
    		domElement,
    		ariaLabel,
    		classes,
    		defaultAriaLabel,
    		forwardEvents,
    		props,
    		color,
    		className,
    		active,
    		block,
    		outline,
    		size,
    		gradient,
    		rounded,
    		$$scope,
    		slots,
    		button_binding
    	];
    }

    class MDBBtn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			class: 14,
    			active: 15,
    			block: 16,
    			children: 1,
    			close: 2,
    			color: 13,
    			disabled: 3,
    			type: 4,
    			href: 5,
    			outline: 17,
    			size: 18,
    			style: 0,
    			value: 6,
    			gradient: 19,
    			rounded: 20
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBBtn",
    			options,
    			id: create_fragment$v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*color*/ ctx[13] === undefined && !("color" in props)) {
    			console.warn("<MDBBtn> was created without expected prop 'color'");
    		}

    		if (/*gradient*/ ctx[19] === undefined && !("gradient" in props)) {
    			console.warn("<MDBBtn> was created without expected prop 'gradient'");
    		}

    		if (/*rounded*/ ctx[20] === undefined && !("rounded" in props)) {
    			console.warn("<MDBBtn> was created without expected prop 'rounded'");
    		}
    	}

    	get class() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gradient() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gradient(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rounded() {
    		throw new Error("<MDBBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rounded(value) {
    		throw new Error("<MDBBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/mdbsvelte/src/MDBBtnGroup.svelte generated by Svelte v3.38.2 */
    const file$r = "node_modules/mdbsvelte/src/MDBBtnGroup.svelte";

    function create_fragment$u(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	let div_levels = [
    		/*props*/ ctx[1],
    		{ role: "group" },
    		{
    			class: div_class_value = /*elementClasses*/ ctx[2].join(" ")
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$r, 21, 0, 494);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[0].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [/*props*/ ctx[1], { role: "group" }, { class: div_class_value }]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBBtnGroup", slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let className = "";
    	const props = clean($$props, []);
    	let { size } = $$props;
    	let { vertical } = $$props;
    	let elementClasses = [vertical ? "btn-group-vertical" : "btn-group"];

    	if (className) {
    		elementClasses.push(className);
    	}

    	if (size) {
    		elementClasses.push(`btn-group-${size}`);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("size" in $$new_props) $$invalidate(3, size = $$new_props.size);
    		if ("vertical" in $$new_props) $$invalidate(4, vertical = $$new_props.vertical);
    		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		clean,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		props,
    		size,
    		vertical,
    		elementClasses
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) className = $$new_props.className;
    		if ("size" in $$props) $$invalidate(3, size = $$new_props.size);
    		if ("vertical" in $$props) $$invalidate(4, vertical = $$new_props.vertical);
    		if ("elementClasses" in $$props) $$invalidate(2, elementClasses = $$new_props.elementClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [forwardEvents, props, elementClasses, size, vertical, $$scope, slots];
    }

    class MDBBtnGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { size: 3, vertical: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBBtnGroup",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*size*/ ctx[3] === undefined && !("size" in props)) {
    			console.warn("<MDBBtnGroup> was created without expected prop 'size'");
    		}

    		if (/*vertical*/ ctx[4] === undefined && !("vertical" in props)) {
    			console.warn("<MDBBtnGroup> was created without expected prop 'vertical'");
    		}
    	}

    	get size() {
    		throw new Error("<MDBBtnGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<MDBBtnGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<MDBBtnGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<MDBBtnGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/mdbsvelte/src/MDBModal.svelte generated by Svelte v3.38.2 */
    const file$q = "node_modules/mdbsvelte/src/MDBModal.svelte";
    const get_external_slot_changes = dirty => ({});
    const get_external_slot_context = ctx => ({});

    // (251:0) {#if _isMounted && isOpen}
    function create_if_block$b(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let div0_class_value;
    	let div2_transition;
    	let t1;
    	let div3;
    	let div3_class_value;
    	let div3_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const external_slot_template = /*#slots*/ ctx[38].external;
    	const external_slot = create_slot(external_slot_template, ctx, /*$$scope*/ ctx[37], get_external_slot_context);
    	const default_slot_template = /*#slots*/ ctx[38].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[37], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (external_slot) external_slot.c();
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", div0_class_value = clsx("modal-content", /*contentClassName*/ ctx[8]));
    			add_location(div0, file$q, 262, 6, 6210);
    			attr_dev(div1, "class", /*classes*/ ctx[13]);
    			attr_dev(div1, "role", "document");
    			add_location(div1, file$q, 261, 4, 6146);
    			attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[5]);
    			attr_dev(div2, "class", /*modalClasses*/ ctx[12]);
    			attr_dev(div2, "role", "dialog");
    			set_style(div2, "display", "block");
    			add_location(div2, file$q, 251, 2, 5795);
    			attr_dev(div3, "class", div3_class_value = clsx({ "modal-backdrop": /*backdrop*/ ctx[6] }, "show", /*backdropClassName*/ ctx[7]));
    			add_location(div3, file$q, 268, 2, 6347);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (external_slot) {
    				external_slot.m(div0, null);
    			}

    			append_dev(div0, t0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			/*div1_binding*/ ctx[39](div1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "introend", /*onModalOpened*/ ctx[15], false, false, false),
    					listen_dev(div2, "outroend", /*onModalClosed*/ ctx[16], false, false, false),
    					listen_dev(div2, "click", /*handleBackdropClick*/ ctx[14], false, false, false),
    					listen_dev(div2, "mousedown", /*handleBackdropMouseDown*/ ctx[17], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (external_slot) {
    				if (external_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
    					update_slot(external_slot, external_slot_template, ctx, /*$$scope*/ ctx[37], dirty, get_external_slot_changes, get_external_slot_context);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 64)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[37], dirty, null, null);
    				}
    			}

    			if (!current || dirty[0] & /*contentClassName*/ 256 && div0_class_value !== (div0_class_value = clsx("modal-content", /*contentClassName*/ ctx[8]))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty[0] & /*classes*/ 8192) {
    				attr_dev(div1, "class", /*classes*/ ctx[13]);
    			}

    			if (!current || dirty[0] & /*labelledBy*/ 32) {
    				attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*modalClasses*/ 4096) {
    				attr_dev(div2, "class", /*modalClasses*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*backdrop, backdropClassName*/ 192 && div3_class_value !== (div3_class_value = clsx({ "modal-backdrop": /*backdrop*/ ctx[6] }, "show", /*backdropClassName*/ ctx[7]))) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(external_slot, local);
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(
    					div2,
    					fly,
    					{
    						x: /*displacementX*/ ctx[0],
    						y: /*displacementY*/ ctx[1],
    						duration: /*fade*/ ctx[9] && /*duration*/ ctx[3]
    					},
    					true
    				);

    				div2_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!div3_transition) div3_transition = create_bidirectional_transition(
    					div3,
    					fade,
    					{
    						duration: /*fade*/ ctx[9] && /*backdropDuration*/ ctx[4]
    					},
    					true
    				);

    				div3_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(external_slot, local);
    			transition_out(default_slot, local);

    			if (!div2_transition) div2_transition = create_bidirectional_transition(
    				div2,
    				fly,
    				{
    					x: /*displacementX*/ ctx[0],
    					y: /*displacementY*/ ctx[1],
    					duration: /*fade*/ ctx[9] && /*duration*/ ctx[3]
    				},
    				false
    			);

    			div2_transition.run(0);

    			if (!div3_transition) div3_transition = create_bidirectional_transition(
    				div3,
    				fade,
    				{
    					duration: /*fade*/ ctx[9] && /*backdropDuration*/ ctx[4]
    				},
    				false
    			);

    			div3_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (external_slot) external_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			/*div1_binding*/ ctx[39](null);
    			if (detaching && div2_transition) div2_transition.end();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    			if (detaching && div3_transition) div3_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(251:0) {#if _isMounted && isOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*_isMounted*/ ctx[10] && /*isOpen*/ ctx[2] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*_isMounted*/ ctx[10] && /*isOpen*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*_isMounted, isOpen*/ 1028) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let openCount = 0;
    const dialogBaseClass = "modal-dialog";

    function instance$t($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBModal", slots, ['external','default']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { class: className = "" } = $$props;
    	let { isOpen } = $$props;
    	let { autoFocus = true } = $$props;
    	let { centered = false } = $$props;
    	let { duration = 500 } = $$props;
    	let { backdropDuration = duration } = $$props;
    	let { scrollable = false } = $$props;
    	let { size = "" } = $$props;
    	let { toggle = undefined } = $$props;
    	let { labelledBy = "" } = $$props;
    	let { backdrop = true } = $$props;
    	let { onEnter = undefined } = $$props;
    	let { onExit = undefined } = $$props;

    	let { onOpened = () => {
    		
    	} } = $$props;

    	let { onClosed = () => {
    		
    	} } = $$props;

    	let { wrapClassName = "" } = $$props;
    	let { modalClassName = "" } = $$props;
    	let { backdropClassName = "" } = $$props;
    	let { contentClassName = "" } = $$props;
    	let { fade: fade$1 = true } = $$props;
    	let { zIndex = 1050 } = $$props;
    	let { unmountOnClose = true } = $$props;
    	let { returnFocusAfterClose = true } = $$props;
    	let { displacementX = 0 } = $$props;
    	let { displacementY = -300 } = $$props;
    	let { side } = $$props;
    	let { position = "" } = $$props;
    	let { fullHeight } = $$props;
    	let { frame } = $$props;

    	const props = clean($$props, [
    		"isOpen",
    		"autoFocus",
    		"centered",
    		"duration",
    		"backdropDuration",
    		"scrollable",
    		"size",
    		"toggle",
    		"labelledBy",
    		"toggle",
    		"onEnter",
    		"onExit",
    		"onOpened",
    		"onClosed",
    		"wrapClassName",
    		"modalClassName",
    		"backdropClassName",
    		"contentClassName",
    		"fade",
    		"zIndex",
    		"unmountOnClose",
    		"returnFocusAfterClose",
    		"side",
    		"position",
    		"frame",
    		"backdrop"
    	]);

    	let hasOpened = false;
    	let _isMounted = false;
    	let _triggeringElement;
    	let _originalBodyPadding;
    	let _lastIsOpen = isOpen;
    	let _lastHasOpened = hasOpened;
    	let _dialog;
    	let _mouseDownElement;
    	let _removeEscListener;
    	let modalClasses;

    	onMount(() => {
    		if (isOpen) {
    			init();
    			hasOpened = true;
    		}

    		if (typeof onEnter === "function") {
    			onEnter();
    		}

    		if (hasOpened && autoFocus) {
    			setFocus();
    		}
    	});

    	onDestroy(() => {
    		if (typeof onExit === "function") {
    			onExit();
    		}

    		destroy();

    		if (hasOpened) {
    			close();
    		}
    	});

    	afterUpdate(() => {
    		if (isOpen && !_lastIsOpen) {
    			init();
    			hasOpened = true;
    		}

    		if (autoFocus && hasOpened && !_lastHasOpened) {
    			setFocus();
    		}

    		_lastIsOpen = isOpen;
    		_lastHasOpened = hasOpened;
    	});

    	function setFocus() {
    		if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === "function") {
    			_dialog.parentNode.focus();
    		}
    	}

    	function init() {
    		try {
    			_triggeringElement = document.activeElement;
    		} catch(err) {
    			_triggeringElement = null;
    		}

    		_originalBodyPadding = getOriginalBodyPadding();
    		conditionallyUpdateScrollbar();

    		if (openCount === 0) {
    			document.body.className = clsx(document.body.className, "modal-open");
    		}

    		++openCount;
    		$$invalidate(10, _isMounted = true);
    	}

    	function manageFocusAfterClose() {
    		if (_triggeringElement) {
    			if (typeof _triggeringElement.focus === "function" && returnFocusAfterClose) {
    				_triggeringElement.focus();
    			}

    			_triggeringElement = null;
    		}
    	}

    	function destroy() {
    		manageFocusAfterClose();
    	}

    	function close() {
    		if (openCount <= 1) {
    			const modalOpenClassName = "modal-open";
    			const modalOpenClassNameRegex = new RegExp(`(^| )${modalOpenClassName}( |$)`);
    			document.body.className = document.body.className.replace(modalOpenClassNameRegex, " ").trim();
    		}

    		manageFocusAfterClose();
    		openCount = Math.max(0, openCount - 1);
    		setScrollbarWidth(_originalBodyPadding);
    	}

    	function handleBackdropClick(e) {
    		if (e.target === _mouseDownElement) {
    			e.stopPropagation();

    			if (!isOpen || !backdrop) {
    				return;
    			}

    			const backdropElem = _dialog ? _dialog.parentNode : null;

    			if (backdropElem && e.target === backdropElem && toggle) {
    				toggle(e);
    			}
    		}
    	}

    	function onModalOpened() {
    		_removeEscListener = browserEvent(document, "keydown", event => {
    			if (event.key && event.key === "Escape") {
    				toggle(event);
    			}
    		});

    		onOpened();
    	}

    	function onModalClosed() {
    		onClosed();

    		if (_removeEscListener) {
    			_removeEscListener();
    		}

    		if (unmountOnClose) {
    			destroy();
    		}

    		close();

    		if (_isMounted) {
    			hasOpened = false;
    		}

    		$$invalidate(10, _isMounted = false);
    	}

    	function handleBackdropMouseDown(e) {
    		_mouseDownElement = e.target;
    	}

    	if (position.indexOf("right") !== -1) {
    		displacementX = 300;
    		if (fullHeight) displacementY = 0;
    	}

    	if (position.indexOf("left") !== -1) {
    		displacementX = -300;
    		if (fullHeight) displacementY = 0;
    	}

    	if (position.indexOf("top") !== -1) {
    		displacementY = -300;
    		if (fullHeight) displacementX = 0;
    	}

    	if (position.indexOf("bottom") !== -1) {
    		displacementY = 300;
    		if (fullHeight) displacementX = 0;
    	}

    	modalClasses = clsx("modal", "show", modalClassName);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			_dialog = $$value;
    			$$invalidate(11, _dialog);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(18, className = $$new_props.class);
    		if ("isOpen" in $$new_props) $$invalidate(2, isOpen = $$new_props.isOpen);
    		if ("autoFocus" in $$new_props) $$invalidate(19, autoFocus = $$new_props.autoFocus);
    		if ("centered" in $$new_props) $$invalidate(20, centered = $$new_props.centered);
    		if ("duration" in $$new_props) $$invalidate(3, duration = $$new_props.duration);
    		if ("backdropDuration" in $$new_props) $$invalidate(4, backdropDuration = $$new_props.backdropDuration);
    		if ("scrollable" in $$new_props) $$invalidate(21, scrollable = $$new_props.scrollable);
    		if ("size" in $$new_props) $$invalidate(22, size = $$new_props.size);
    		if ("toggle" in $$new_props) $$invalidate(23, toggle = $$new_props.toggle);
    		if ("labelledBy" in $$new_props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
    		if ("backdrop" in $$new_props) $$invalidate(6, backdrop = $$new_props.backdrop);
    		if ("onEnter" in $$new_props) $$invalidate(24, onEnter = $$new_props.onEnter);
    		if ("onExit" in $$new_props) $$invalidate(25, onExit = $$new_props.onExit);
    		if ("onOpened" in $$new_props) $$invalidate(26, onOpened = $$new_props.onOpened);
    		if ("onClosed" in $$new_props) $$invalidate(27, onClosed = $$new_props.onClosed);
    		if ("wrapClassName" in $$new_props) $$invalidate(28, wrapClassName = $$new_props.wrapClassName);
    		if ("modalClassName" in $$new_props) $$invalidate(29, modalClassName = $$new_props.modalClassName);
    		if ("backdropClassName" in $$new_props) $$invalidate(7, backdropClassName = $$new_props.backdropClassName);
    		if ("contentClassName" in $$new_props) $$invalidate(8, contentClassName = $$new_props.contentClassName);
    		if ("fade" in $$new_props) $$invalidate(9, fade$1 = $$new_props.fade);
    		if ("zIndex" in $$new_props) $$invalidate(30, zIndex = $$new_props.zIndex);
    		if ("unmountOnClose" in $$new_props) $$invalidate(31, unmountOnClose = $$new_props.unmountOnClose);
    		if ("returnFocusAfterClose" in $$new_props) $$invalidate(32, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    		if ("displacementX" in $$new_props) $$invalidate(0, displacementX = $$new_props.displacementX);
    		if ("displacementY" in $$new_props) $$invalidate(1, displacementY = $$new_props.displacementY);
    		if ("side" in $$new_props) $$invalidate(33, side = $$new_props.side);
    		if ("position" in $$new_props) $$invalidate(34, position = $$new_props.position);
    		if ("fullHeight" in $$new_props) $$invalidate(35, fullHeight = $$new_props.fullHeight);
    		if ("frame" in $$new_props) $$invalidate(36, frame = $$new_props.frame);
    		if ("$$scope" in $$new_props) $$invalidate(37, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		openCount,
    		onDestroy,
    		onMount,
    		afterUpdate,
    		fadeTransition: fade,
    		flyTransition: fly,
    		conditionallyUpdateScrollbar,
    		getOriginalBodyPadding,
    		setScrollbarWidth,
    		clean,
    		browserEvent,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		isOpen,
    		autoFocus,
    		centered,
    		duration,
    		backdropDuration,
    		scrollable,
    		size,
    		toggle,
    		labelledBy,
    		backdrop,
    		onEnter,
    		onExit,
    		onOpened,
    		onClosed,
    		wrapClassName,
    		modalClassName,
    		backdropClassName,
    		contentClassName,
    		fade: fade$1,
    		zIndex,
    		unmountOnClose,
    		returnFocusAfterClose,
    		displacementX,
    		displacementY,
    		side,
    		position,
    		fullHeight,
    		frame,
    		props,
    		hasOpened,
    		_isMounted,
    		_triggeringElement,
    		_originalBodyPadding,
    		_lastIsOpen,
    		_lastHasOpened,
    		_dialog,
    		_mouseDownElement,
    		_removeEscListener,
    		modalClasses,
    		setFocus,
    		init,
    		manageFocusAfterClose,
    		destroy,
    		close,
    		handleBackdropClick,
    		onModalOpened,
    		onModalClosed,
    		handleBackdropMouseDown,
    		dialogBaseClass,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(54, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(18, className = $$new_props.className);
    		if ("isOpen" in $$props) $$invalidate(2, isOpen = $$new_props.isOpen);
    		if ("autoFocus" in $$props) $$invalidate(19, autoFocus = $$new_props.autoFocus);
    		if ("centered" in $$props) $$invalidate(20, centered = $$new_props.centered);
    		if ("duration" in $$props) $$invalidate(3, duration = $$new_props.duration);
    		if ("backdropDuration" in $$props) $$invalidate(4, backdropDuration = $$new_props.backdropDuration);
    		if ("scrollable" in $$props) $$invalidate(21, scrollable = $$new_props.scrollable);
    		if ("size" in $$props) $$invalidate(22, size = $$new_props.size);
    		if ("toggle" in $$props) $$invalidate(23, toggle = $$new_props.toggle);
    		if ("labelledBy" in $$props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
    		if ("backdrop" in $$props) $$invalidate(6, backdrop = $$new_props.backdrop);
    		if ("onEnter" in $$props) $$invalidate(24, onEnter = $$new_props.onEnter);
    		if ("onExit" in $$props) $$invalidate(25, onExit = $$new_props.onExit);
    		if ("onOpened" in $$props) $$invalidate(26, onOpened = $$new_props.onOpened);
    		if ("onClosed" in $$props) $$invalidate(27, onClosed = $$new_props.onClosed);
    		if ("wrapClassName" in $$props) $$invalidate(28, wrapClassName = $$new_props.wrapClassName);
    		if ("modalClassName" in $$props) $$invalidate(29, modalClassName = $$new_props.modalClassName);
    		if ("backdropClassName" in $$props) $$invalidate(7, backdropClassName = $$new_props.backdropClassName);
    		if ("contentClassName" in $$props) $$invalidate(8, contentClassName = $$new_props.contentClassName);
    		if ("fade" in $$props) $$invalidate(9, fade$1 = $$new_props.fade);
    		if ("zIndex" in $$props) $$invalidate(30, zIndex = $$new_props.zIndex);
    		if ("unmountOnClose" in $$props) $$invalidate(31, unmountOnClose = $$new_props.unmountOnClose);
    		if ("returnFocusAfterClose" in $$props) $$invalidate(32, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    		if ("displacementX" in $$props) $$invalidate(0, displacementX = $$new_props.displacementX);
    		if ("displacementY" in $$props) $$invalidate(1, displacementY = $$new_props.displacementY);
    		if ("side" in $$props) $$invalidate(33, side = $$new_props.side);
    		if ("position" in $$props) $$invalidate(34, position = $$new_props.position);
    		if ("fullHeight" in $$props) $$invalidate(35, fullHeight = $$new_props.fullHeight);
    		if ("frame" in $$props) $$invalidate(36, frame = $$new_props.frame);
    		if ("hasOpened" in $$props) hasOpened = $$new_props.hasOpened;
    		if ("_isMounted" in $$props) $$invalidate(10, _isMounted = $$new_props._isMounted);
    		if ("_triggeringElement" in $$props) _triggeringElement = $$new_props._triggeringElement;
    		if ("_originalBodyPadding" in $$props) _originalBodyPadding = $$new_props._originalBodyPadding;
    		if ("_lastIsOpen" in $$props) _lastIsOpen = $$new_props._lastIsOpen;
    		if ("_lastHasOpened" in $$props) _lastHasOpened = $$new_props._lastHasOpened;
    		if ("_dialog" in $$props) $$invalidate(11, _dialog = $$new_props._dialog);
    		if ("_mouseDownElement" in $$props) _mouseDownElement = $$new_props._mouseDownElement;
    		if ("_removeEscListener" in $$props) _removeEscListener = $$new_props._removeEscListener;
    		if ("modalClasses" in $$props) $$invalidate(12, modalClasses = $$new_props.modalClasses);
    		if ("classes" in $$props) $$invalidate(13, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*className, size, centered, scrollable*/ 7602176 | $$self.$$.dirty[1] & /*side, fullHeight, frame, position*/ 60) {
    			$$invalidate(13, classes = clsx(dialogBaseClass, className, {
    				[`modal-${size}`]: size,
    				[`${dialogBaseClass}-centered`]: centered,
    				[`${dialogBaseClass}-scrollable`]: scrollable,
    				"modal-side": side,
    				"modal-full-height": fullHeight,
    				"modal-frame": frame,
    				[`modal-${position}`]: position
    			}));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		displacementX,
    		displacementY,
    		isOpen,
    		duration,
    		backdropDuration,
    		labelledBy,
    		backdrop,
    		backdropClassName,
    		contentClassName,
    		fade$1,
    		_isMounted,
    		_dialog,
    		modalClasses,
    		classes,
    		handleBackdropClick,
    		onModalOpened,
    		onModalClosed,
    		handleBackdropMouseDown,
    		className,
    		autoFocus,
    		centered,
    		scrollable,
    		size,
    		toggle,
    		onEnter,
    		onExit,
    		onOpened,
    		onClosed,
    		wrapClassName,
    		modalClassName,
    		zIndex,
    		unmountOnClose,
    		returnFocusAfterClose,
    		side,
    		position,
    		fullHeight,
    		frame,
    		$$scope,
    		slots,
    		div1_binding
    	];
    }

    class MDBModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$t,
    			create_fragment$t,
    			safe_not_equal,
    			{
    				class: 18,
    				isOpen: 2,
    				autoFocus: 19,
    				centered: 20,
    				duration: 3,
    				backdropDuration: 4,
    				scrollable: 21,
    				size: 22,
    				toggle: 23,
    				labelledBy: 5,
    				backdrop: 6,
    				onEnter: 24,
    				onExit: 25,
    				onOpened: 26,
    				onClosed: 27,
    				wrapClassName: 28,
    				modalClassName: 29,
    				backdropClassName: 7,
    				contentClassName: 8,
    				fade: 9,
    				zIndex: 30,
    				unmountOnClose: 31,
    				returnFocusAfterClose: 32,
    				displacementX: 0,
    				displacementY: 1,
    				side: 33,
    				position: 34,
    				fullHeight: 35,
    				frame: 36
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBModal",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isOpen*/ ctx[2] === undefined && !("isOpen" in props)) {
    			console.warn("<MDBModal> was created without expected prop 'isOpen'");
    		}

    		if (/*side*/ ctx[33] === undefined && !("side" in props)) {
    			console.warn("<MDBModal> was created without expected prop 'side'");
    		}

    		if (/*fullHeight*/ ctx[35] === undefined && !("fullHeight" in props)) {
    			console.warn("<MDBModal> was created without expected prop 'fullHeight'");
    		}

    		if (/*frame*/ ctx[36] === undefined && !("frame" in props)) {
    			console.warn("<MDBModal> was created without expected prop 'frame'");
    		}
    	}

    	get class() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoFocus() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoFocus(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get centered() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set centered(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdropDuration() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdropDuration(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollable() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollable(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelledBy() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelledBy(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdrop() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdrop(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onEnter() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEnter(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onExit() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onExit(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onOpened() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onOpened(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClosed() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClosed(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapClassName() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapClassName(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalClassName() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalClassName(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdropClassName() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdropClassName(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentClassName() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentClassName(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fade() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fade(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get zIndex() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set zIndex(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get unmountOnClose() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set unmountOnClose(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get returnFocusAfterClose() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set returnFocusAfterClose(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displacementX() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displacementX(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get displacementY() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set displacementY(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get side() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set side(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get position() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set position(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullHeight() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullHeight(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get frame() {
    		throw new Error("<MDBModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set frame(value) {
    		throw new Error("<MDBModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/mdbsvelte/src/MDBModalBody.svelte generated by Svelte v3.38.2 */
    const file$p = "node_modules/mdbsvelte/src/MDBModalBody.svelte";

    function create_fragment$s(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [/*props*/ ctx[2], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$p, 13, 0, 335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[1].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				/*props*/ ctx[2],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBModalBody", slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { class: className = "" } = $$props;
    	const props = clean($$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		clean,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		props,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			$$invalidate(0, classes = clsx(className, "modal-body"));
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, forwardEvents, props, className, $$scope, slots];
    }

    class MDBModalBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { class: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBModalBody",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get class() {
    		throw new Error("<MDBModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MDBModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/mdbsvelte/src/MDBModalHeader.svelte generated by Svelte v3.38.2 */
    const file$o = "node_modules/mdbsvelte/src/MDBModalHeader.svelte";
    const get_close_slot_changes = dirty => ({});
    const get_close_slot_context = ctx => ({});

    // (26:4) {:else}
    function create_else_block$8(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(26:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:4) {#if children}
    function create_if_block_1$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*children*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 4) set_data_dev(t, /*children*/ ctx[2]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(24:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    // (31:4) {#if typeof toggle === 'function'}
    function create_if_block$a(ctx) {
    	let button;
    	let span;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			span = element("span");
    			t = text(/*closeIcon*/ ctx[3]);
    			attr_dev(span, "aria-hidden", "true");
    			add_location(span, file$o, 36, 8, 915);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "close");
    			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			add_location(button, file$o, 31, 6, 792);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*toggle*/ ctx[0])) /*toggle*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*closeIcon*/ 8) set_data_dev(t, /*closeIcon*/ ctx[3]);

    			if (dirty & /*closeAriaLabel*/ 2) {
    				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(31:4) {#if typeof toggle === 'function'}",
    		ctx
    	});

    	return block;
    }

    // (30:21)      
    function fallback_block$1(ctx) {
    	let if_block_anchor;
    	let if_block = typeof /*toggle*/ ctx[0] === "function" && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*toggle*/ ctx[0] === "function") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(30:21)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let div;
    	let h5;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$9, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*children*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const close_slot_template = /*#slots*/ ctx[10].close;
    	const close_slot = create_slot(close_slot_template, ctx, /*$$scope*/ ctx[9], get_close_slot_context);
    	const close_slot_or_fallback = close_slot || fallback_block$1(ctx);
    	let div_levels = [/*props*/ ctx[6], { class: /*classes*/ ctx[4] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			if_block.c();
    			t = space();
    			if (close_slot_or_fallback) close_slot_or_fallback.c();
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$o, 22, 2, 620);
    			set_attributes(div, div_data);
    			add_location(div, file$o, 21, 0, 567);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			if_blocks[current_block_type_index].m(h5, null);
    			append_dev(div, t);

    			if (close_slot_or_fallback) {
    				close_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[5].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(h5, null);
    			}

    			if (close_slot) {
    				if (close_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot(close_slot, close_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_close_slot_changes, get_close_slot_context);
    				}
    			} else {
    				if (close_slot_or_fallback && close_slot_or_fallback.p && dirty & /*closeAriaLabel, toggle, closeIcon*/ 11) {
    					close_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				/*props*/ ctx[6],
    				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(close_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(close_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let closeIcon;
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBModalHeader", slots, ['default','close']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { class: className = "" } = $$props;
    	let { toggle = undefined } = $$props;
    	let { closeAriaLabel = "Close" } = $$props;
    	let { charCode = 215 } = $$props;
    	let { children = undefined } = $$props;
    	const props = clean($$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ("toggle" in $$new_props) $$invalidate(0, toggle = $$new_props.toggle);
    		if ("closeAriaLabel" in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ("charCode" in $$new_props) $$invalidate(8, charCode = $$new_props.charCode);
    		if ("children" in $$new_props) $$invalidate(2, children = $$new_props.children);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		clean,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		toggle,
    		closeAriaLabel,
    		charCode,
    		children,
    		props,
    		closeIcon,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
    		if ("toggle" in $$props) $$invalidate(0, toggle = $$new_props.toggle);
    		if ("closeAriaLabel" in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ("charCode" in $$props) $$invalidate(8, charCode = $$new_props.charCode);
    		if ("children" in $$props) $$invalidate(2, children = $$new_props.children);
    		if ("closeIcon" in $$props) $$invalidate(3, closeIcon = $$new_props.closeIcon);
    		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*charCode*/ 256) {
    			$$invalidate(3, closeIcon = typeof charCode === "number"
    			? String.fromCharCode(charCode)
    			: charCode);
    		}

    		if ($$self.$$.dirty & /*className*/ 128) {
    			$$invalidate(4, classes = clsx(className, "modal-header"));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		toggle,
    		closeAriaLabel,
    		children,
    		closeIcon,
    		classes,
    		forwardEvents,
    		props,
    		className,
    		charCode,
    		$$scope,
    		slots
    	];
    }

    class MDBModalHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {
    			class: 7,
    			toggle: 0,
    			closeAriaLabel: 1,
    			charCode: 8,
    			children: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBModalHeader",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get class() {
    		throw new Error("<MDBModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MDBModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<MDBModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<MDBModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeAriaLabel() {
    		throw new Error("<MDBModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeAriaLabel(value) {
    		throw new Error("<MDBModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get charCode() {
    		throw new Error("<MDBModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set charCode(value) {
    		throw new Error("<MDBModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<MDBModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<MDBModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/mdbsvelte/src/MDBModalFooter.svelte generated by Svelte v3.38.2 */
    const file$n = "node_modules/mdbsvelte/src/MDBModalFooter.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
    	let div_levels = [/*props*/ ctx[2], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$n, 13, 0, 335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(/*forwardEvents*/ ctx[1].call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				/*props*/ ctx[2],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let classes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MDBModalFooter", slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(current_component);
    	let { class: className = "" } = $$props;
    	const props = clean($$props);

    	$$self.$$set = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		clean,
    		clsx,
    		forwardEventsBuilder,
    		current_component,
    		forwardEvents,
    		className,
    		props,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
    		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 8) {
    			$$invalidate(0, classes = clsx(className, "modal-footer"));
    		}
    	};

    	$$props = exclude_internal_props($$props);
    	return [classes, forwardEvents, props, className, $$scope, slots];
    }

    class MDBModalFooter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { class: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MDBModalFooter",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get class() {
    		throw new Error("<MDBModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<MDBModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/ConfirmModal.svelte generated by Svelte v3.38.2 */

    // (42:2) <MDBModalHeader toggle={toggle}>
    function create_default_slot_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("確認");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(42:2) <MDBModalHeader toggle={toggle}>",
    		ctx
    	});

    	return block;
    }

    // (43:2) <MDBModalBody>
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*message*/ ctx[0]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 1) set_data_dev(t, /*message*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(43:2) <MDBModalBody>",
    		ctx
    	});

    	return block;
    }

    // (47:4) <MDBBtn color={colorOkayButton} on:click={_onOkay}>
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*labelOkayButton*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labelOkayButton*/ 4) set_data_dev(t, /*labelOkayButton*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(47:4) <MDBBtn color={colorOkayButton} on:click={_onOkay}>",
    		ctx
    	});

    	return block;
    }

    // (48:4) <MDBBtn color="primary" outline on:click={_onCancel}>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancel");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(48:4) <MDBBtn color=\\\"primary\\\" outline on:click={_onCancel}>",
    		ctx
    	});

    	return block;
    }

    // (46:2) <MDBModalFooter>
    function create_default_slot_1$1(ctx) {
    	let mdbbtn0;
    	let t;
    	let mdbbtn1;
    	let current;

    	mdbbtn0 = new MDBBtn({
    			props: {
    				color: /*colorOkayButton*/ ctx[1],
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbbtn0.$on("click", /*_onOkay*/ ctx[6]);

    	mdbbtn1 = new MDBBtn({
    			props: {
    				color: "primary",
    				outline: true,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbbtn1.$on("click", /*_onCancel*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(mdbbtn0.$$.fragment);
    			t = space();
    			create_component(mdbbtn1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdbbtn0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mdbbtn1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdbbtn0_changes = {};
    			if (dirty & /*colorOkayButton*/ 2) mdbbtn0_changes.color = /*colorOkayButton*/ ctx[1];

    			if (dirty & /*$$scope, labelOkayButton*/ 1028) {
    				mdbbtn0_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtn0.$set(mdbbtn0_changes);
    			const mdbbtn1_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				mdbbtn1_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtn1.$set(mdbbtn1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdbbtn0.$$.fragment, local);
    			transition_in(mdbbtn1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdbbtn0.$$.fragment, local);
    			transition_out(mdbbtn1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdbbtn0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mdbbtn1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(46:2) <MDBModalFooter>",
    		ctx
    	});

    	return block;
    }

    // (41:0) <MDBModal isOpen={isOpen} toggle={toggle}>
    function create_default_slot$3(ctx) {
    	let mdbmodalheader;
    	let t0;
    	let mdbmodalbody;
    	let t1;
    	let mdbmodalfooter;
    	let current;

    	mdbmodalheader = new MDBModalHeader({
    			props: {
    				toggle: /*toggle*/ ctx[4],
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbmodalbody = new MDBModalBody({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbmodalfooter = new MDBModalFooter({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdbmodalheader.$$.fragment);
    			t0 = space();
    			create_component(mdbmodalbody.$$.fragment);
    			t1 = space();
    			create_component(mdbmodalfooter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdbmodalheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(mdbmodalbody, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(mdbmodalfooter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mdbmodalheader_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				mdbmodalheader_changes.$$scope = { dirty, ctx };
    			}

    			mdbmodalheader.$set(mdbmodalheader_changes);
    			const mdbmodalbody_changes = {};

    			if (dirty & /*$$scope, message*/ 1025) {
    				mdbmodalbody_changes.$$scope = { dirty, ctx };
    			}

    			mdbmodalbody.$set(mdbmodalbody_changes);
    			const mdbmodalfooter_changes = {};

    			if (dirty & /*$$scope, colorOkayButton, labelOkayButton*/ 1030) {
    				mdbmodalfooter_changes.$$scope = { dirty, ctx };
    			}

    			mdbmodalfooter.$set(mdbmodalfooter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdbmodalheader.$$.fragment, local);
    			transition_in(mdbmodalbody.$$.fragment, local);
    			transition_in(mdbmodalfooter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdbmodalheader.$$.fragment, local);
    			transition_out(mdbmodalbody.$$.fragment, local);
    			transition_out(mdbmodalfooter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdbmodalheader, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(mdbmodalbody, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(mdbmodalfooter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(41:0) <MDBModal isOpen={isOpen} toggle={toggle}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let mdbmodal;
    	let current;

    	mdbmodal = new MDBModal({
    			props: {
    				isOpen: /*isOpen*/ ctx[3],
    				toggle: /*toggle*/ ctx[4],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mdbmodal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdbmodal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mdbmodal_changes = {};
    			if (dirty & /*isOpen*/ 8) mdbmodal_changes.isOpen = /*isOpen*/ ctx[3];

    			if (dirty & /*$$scope, colorOkayButton, labelOkayButton, message*/ 1031) {
    				mdbmodal_changes.$$scope = { dirty, ctx };
    			}

    			mdbmodal.$set(mdbmodal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdbmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdbmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdbmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ConfirmModal", slots, []);
    	let message;
    	let onOkay;
    	let onCancel;
    	let colorOkayButton;
    	let labelOkayButton;
    	let isOpen = false;

    	const confirm = params => {
    		return new Promise((resolve, reject) => {
    				$$invalidate(0, message = params.message || "");
    				$$invalidate(1, colorOkayButton = params.colorOkayButton || "primary");
    				$$invalidate(2, labelOkayButton = params.labelOkayButton || "OK");

    				onOkay = event => {
    					(params.onOkay || (() => {
    						
    					}))(event);

    					resolve(true);
    				};

    				onCancel = event => {
    					(params.onCancel || (() => {
    						
    					}))(event);

    					reject("cancel");
    				};

    				$$invalidate(3, isOpen = true);
    			});
    	};

    	function toggle() {
    		$$invalidate(3, isOpen = !isOpen);
    	}

    	function _onCancel(event) {
    		$$invalidate(3, isOpen = false);
    		onCancel(event);
    	}

    	function _onOkay(event) {
    		$$invalidate(3, isOpen = false);
    		onOkay(event);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ConfirmModal> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		MDBBtn,
    		MDBModal,
    		MDBModalBody,
    		MDBModalHeader,
    		MDBModalFooter,
    		message,
    		onOkay,
    		onCancel,
    		colorOkayButton,
    		labelOkayButton,
    		isOpen,
    		confirm,
    		toggle,
    		_onCancel,
    		_onOkay
    	});

    	$$self.$inject_state = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("onOkay" in $$props) onOkay = $$props.onOkay;
    		if ("onCancel" in $$props) onCancel = $$props.onCancel;
    		if ("colorOkayButton" in $$props) $$invalidate(1, colorOkayButton = $$props.colorOkayButton);
    		if ("labelOkayButton" in $$props) $$invalidate(2, labelOkayButton = $$props.labelOkayButton);
    		if ("isOpen" in $$props) $$invalidate(3, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		message,
    		colorOkayButton,
    		labelOkayButton,
    		isOpen,
    		toggle,
    		_onCancel,
    		_onOkay,
    		confirm
    	];
    }

    class ConfirmModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { confirm: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConfirmModal",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get confirm() {
    		return this.$$.ctx[7];
    	}

    	set confirm(value) {
    		throw new Error("<ConfirmModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const charmManager = writable(null);

    const zenkaku2hankaku = (str) => str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
    const hankaku2zenkaku = (str) => str.replace(/[A-Za-z0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0));

    /* src/pages/CharmIxporter.svelte generated by Svelte v3.38.2 */

    const { console: console_1$5 } = globals;
    const file$m = "src/pages/CharmIxporter.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (84:6) <MDBBtn color="primary"               class="shadow-0 mx-1 px-0"               style="width: 8rem;"               disabled={p.isDisabled()}               on:click={p.onClick}>
    function create_default_slot_1(ctx) {
    	let t0_value = /*p*/ ctx[14].label + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$charmManager, textareaValue*/ 5 && t0_value !== (t0_value = /*p*/ ctx[14].label + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(84:6) <MDBBtn color=\\\"primary\\\"               class=\\\"shadow-0 mx-1 px-0\\\"               style=\\\"width: 8rem;\\\"               disabled={p.isDisabled()}               on:click={p.onClick}>",
    		ctx
    	});

    	return block;
    }

    // (80:6) {#each [         {label: 'エクスポート',     isDisabled: () => $charmManager == null, onClick: exportCharms},         {label: '追加インポート',   isDisabled: () => $charmManager == null || textareaValue.trim().length === 0, onClick: () => importCharms({mode: IMPORT_MODE.APPEND})},         {label: '上書きインポート', isDisabled: () => $charmManager == null || textareaValue.trim().length === 0, onClick: () => importCharms({mode: IMPORT_MODE.OVERWRITE})} ] as p}
    function create_each_block$f(ctx) {
    	let mdbbtn;
    	let current;

    	mdbbtn = new MDBBtn({
    			props: {
    				color: "primary",
    				class: "shadow-0 mx-1 px-0",
    				style: "width: 8rem;",
    				disabled: /*p*/ ctx[14].isDisabled(),
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbbtn.$on("click", function () {
    		if (is_function(/*p*/ ctx[14].onClick)) /*p*/ ctx[14].onClick.apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(mdbbtn.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mdbbtn, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const mdbbtn_changes = {};
    			if (dirty & /*$charmManager, textareaValue*/ 5) mdbbtn_changes.disabled = /*p*/ ctx[14].isDisabled();

    			if (dirty & /*$$scope, $charmManager, textareaValue*/ 131077) {
    				mdbbtn_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtn.$set(mdbbtn_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdbbtn.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdbbtn.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mdbbtn, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(80:6) {#each [         {label: 'エクスポート',     isDisabled: () => $charmManager == null, onClick: exportCharms},         {label: '追加インポート',   isDisabled: () => $charmManager == null || textareaValue.trim().length === 0, onClick: () => importCharms({mode: IMPORT_MODE.APPEND})},         {label: '上書きインポート', isDisabled: () => $charmManager == null || textareaValue.trim().length === 0, onClick: () => importCharms({mode: IMPORT_MODE.OVERWRITE})} ] as p}",
    		ctx
    	});

    	return block;
    }

    // (79:4) <MDBBtnGroup class="shadow-0">
    function create_default_slot$2(ctx) {
    	let each_1_anchor;
    	let current;

    	let each_value = [
    		{
    			label: "エクスポート",
    			isDisabled: /*func*/ ctx[7],
    			onClick: /*exportCharms*/ ctx[5]
    		},
    		{
    			label: "追加インポート",
    			isDisabled: /*func_1*/ ctx[8],
    			onClick: /*func_2*/ ctx[9]
    		},
    		{
    			label: "上書きインポート",
    			isDisabled: /*func_3*/ ctx[10],
    			onClick: /*func_4*/ ctx[11]
    		}
    	];

    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 3; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 3; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 3; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$charmManager, exportCharms, textareaValue, importCharms, IMPORT_MODE*/ 61) {
    				each_value = [
    					{
    						label: "エクスポート",
    						isDisabled: /*func*/ ctx[7],
    						onClick: /*exportCharms*/ ctx[5]
    					},
    					{
    						label: "追加インポート",
    						isDisabled: /*func_1*/ ctx[8],
    						onClick: /*func_2*/ ctx[9]
    					},
    					{
    						label: "上書きインポート",
    						isDisabled: /*func_3*/ ctx[10],
    						onClick: /*func_4*/ ctx[11]
    					}
    				];

    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 3; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = 3; i < 3; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < 3; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < 3; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(79:4) <MDBBtnGroup class=\\\"shadow-0\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div1;
    	let div0;
    	let textarea;
    	let t0;
    	let mdbbtngroup;
    	let t1;
    	let confirmmodal;
    	let updating_confirm;
    	let current;
    	let mounted;
    	let dispose;

    	mdbbtngroup = new MDBBtnGroup({
    			props: {
    				class: "shadow-0",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function confirmmodal_confirm_binding(value) {
    		/*confirmmodal_confirm_binding*/ ctx[12](value);
    	}

    	let confirmmodal_props = {};

    	if (/*confirm*/ ctx[1] !== void 0) {
    		confirmmodal_props.confirm = /*confirm*/ ctx[1];
    	}

    	confirmmodal = new ConfirmModal({
    			props: confirmmodal_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(confirmmodal, "confirm", confirmmodal_confirm_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			textarea = element("textarea");
    			t0 = space();
    			create_component(mdbbtngroup.$$.fragment);
    			t1 = space();
    			create_component(confirmmodal.$$.fragment);
    			attr_dev(textarea, "id", "input");
    			attr_dev(textarea, "class", "svelte-1m5otor");
    			add_location(textarea, file$m, 76, 4, 3119);
    			attr_dev(div0, "id", "charm-ixporter");
    			attr_dev(div0, "class", "svelte-1m5otor");
    			add_location(div0, file$m, 75, 2, 3089);
    			attr_dev(div1, "class", "tab-content svelte-1m5otor");
    			add_location(div1, file$m, 74, 0, 3061);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, textarea);
    			set_input_value(textarea, /*textareaValue*/ ctx[0]);
    			append_dev(div0, t0);
    			mount_component(mdbbtngroup, div0, null);
    			append_dev(div0, t1);
    			mount_component(confirmmodal, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*textareaValue*/ 1) {
    				set_input_value(textarea, /*textareaValue*/ ctx[0]);
    			}

    			const mdbbtngroup_changes = {};

    			if (dirty & /*$$scope, $charmManager, textareaValue*/ 131077) {
    				mdbbtngroup_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtngroup.$set(mdbbtngroup_changes);
    			const confirmmodal_changes = {};

    			if (!updating_confirm && dirty & /*confirm*/ 2) {
    				updating_confirm = true;
    				confirmmodal_changes.confirm = /*confirm*/ ctx[1];
    				add_flush_callback(() => updating_confirm = false);
    			}

    			confirmmodal.$set(confirmmodal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mdbbtngroup.$$.fragment, local);
    			transition_in(confirmmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mdbbtngroup.$$.fragment, local);
    			transition_out(confirmmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(mdbbtngroup);
    			destroy_component(confirmmodal);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $charmManager;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(2, $charmManager = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmIxporter", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	

    	// TYPES
    	const IMPORT_MODE = { APPEND: "append", OVERWRITE: "overwrite" };

    	// VARIABLES
    	let textareaValue = "";

    	let confirm;

    	// FUNCTIONS
    	function importCharms({ mode }) {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (textareaValue.trim().length <= 0) {
    				console.log("blank!!");
    				return;
    			}

    			if (mode !== IMPORT_MODE.APPEND && mode !== IMPORT_MODE.OVERWRITE) {
    				console.log("internal error");
    				return;
    			}

    			const result = yield confirm({
    				message: mode === IMPORT_MODE.OVERWRITE
    				? "護石を上書きインポートします。\n既存の護石は削除され、元に戻すことはできません。よろしいですか？"
    				: "護石を追加インポートします。",
    				colorOkayButton: mode === IMPORT_MODE.OVERWRITE ? "danger" : "primary"
    			});

    			console.log(result);

    			if (mode === IMPORT_MODE.OVERWRITE) {
    				yield $charmManager.reset();
    			}

    			// console.log($charmManager.charms)
    			const charms = textareaValue.trim().split("\n").map(line => {
    				const [s1, sl1, s2, sl2, slot1, slot2, slot3] = line.split(/,\s*/);

    				return {
    					skills: [s1, s2].map(i => i === "" ? "無し" : zenkaku2hankaku(i)),
    					skillLevels: [sl1, sl2].map(i => parseInt(i)),
    					slots: [slot1, slot2, slot3].map(i => parseInt(i))
    				};
    			});

    			console.log(charms);
    			$charmManager.registerCharms(charms);
    		});
    	}

    	function exportCharms() {
    		return __awaiter(this, void 0, void 0, function* () {
    			// console.log($charmManager.charmTableName)
    			$$invalidate(0, textareaValue = $charmManager.charms.map(row => {
    				const { skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3 } = row;

    				return [
    					hankaku2zenkaku(skill1 === "無し" ? "" : skill1),
    					skill1Level,
    					hankaku2zenkaku(skill2 === "無し" ? "" : skill2),
    					skill2Level,
    					slot1,
    					slot2,
    					slot3
    				].join(",");
    			}).join("\n"));
    		}); // $charmManager.exportIdx()
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<CharmIxporter> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		textareaValue = this.value;
    		$$invalidate(0, textareaValue);
    	}

    	const func = () => $charmManager == null;
    	const func_1 = () => $charmManager == null || textareaValue.trim().length === 0;
    	const func_2 = () => importCharms({ mode: IMPORT_MODE.APPEND });
    	const func_3 = () => $charmManager == null || textareaValue.trim().length === 0;
    	const func_4 = () => importCharms({ mode: IMPORT_MODE.OVERWRITE });

    	function confirmmodal_confirm_binding(value) {
    		confirm = value;
    		$$invalidate(1, confirm);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		MDBBtn,
    		MDBBtnGroup,
    		ConfirmModal,
    		charmManager,
    		zenkaku2hankaku,
    		hankaku2zenkaku,
    		IMPORT_MODE,
    		textareaValue,
    		confirm,
    		importCharms,
    		exportCharms,
    		$charmManager
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("textareaValue" in $$props) $$invalidate(0, textareaValue = $$props.textareaValue);
    		if ("confirm" in $$props) $$invalidate(1, confirm = $$props.confirm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		textareaValue,
    		confirm,
    		$charmManager,
    		IMPORT_MODE,
    		importCharms,
    		exportCharms,
    		textarea_input_handler,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		confirmmodal_confirm_binding
    	];
    }

    class CharmIxporter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmIxporter",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var dayjs_min = createCommonjsModule(function (module, exports) {
    !function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},v="en",D={};D[v]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return v;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(v=i),i||!r&&v},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var v=this.$locale().weekStart||0,D=(y<v?y+7:y)-v;return $(r?m-D:m+(6-D),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,v=O.m(this,M);return v=(l={},l[c]=v/12,l[f]=v,l[h]=v/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?v:O.a(v)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[v],w.Ls=D,w.p={},w}));
    });

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function tick_spring(ctx, last_value, current_value, target_value) {
        if (typeof current_value === 'number' || is_date(current_value)) {
            // @ts-ignore
            const delta = target_value - current_value;
            // @ts-ignore
            const velocity = (current_value - last_value) / (ctx.dt || 1 / 60); // guard div by 0
            const spring = ctx.opts.stiffness * delta;
            const damper = ctx.opts.damping * velocity;
            const acceleration = (spring - damper) * ctx.inv_mass;
            const d = (velocity + acceleration) * ctx.dt;
            if (Math.abs(d) < ctx.opts.precision && Math.abs(delta) < ctx.opts.precision) {
                return target_value; // settled
            }
            else {
                ctx.settled = false; // signal loop to keep ticking
                // @ts-ignore
                return is_date(current_value) ?
                    new Date(current_value.getTime() + d) : current_value + d;
            }
        }
        else if (Array.isArray(current_value)) {
            // @ts-ignore
            return current_value.map((_, i) => tick_spring(ctx, last_value[i], current_value[i], target_value[i]));
        }
        else if (typeof current_value === 'object') {
            const next_value = {};
            for (const k in current_value) {
                // @ts-ignore
                next_value[k] = tick_spring(ctx, last_value[k], current_value[k], target_value[k]);
            }
            // @ts-ignore
            return next_value;
        }
        else {
            throw new Error(`Cannot spring ${typeof current_value} values`);
        }
    }
    function spring(value, opts = {}) {
        const store = writable(value);
        const { stiffness = 0.15, damping = 0.8, precision = 0.01 } = opts;
        let last_time;
        let task;
        let current_token;
        let last_value = value;
        let target_value = value;
        let inv_mass = 1;
        let inv_mass_recovery_rate = 0;
        let cancel_task = false;
        function set(new_value, opts = {}) {
            target_value = new_value;
            const token = current_token = {};
            if (value == null || opts.hard || (spring.stiffness >= 1 && spring.damping >= 1)) {
                cancel_task = true; // cancel any running animation
                last_time = now();
                last_value = new_value;
                store.set(value = target_value);
                return Promise.resolve();
            }
            else if (opts.soft) {
                const rate = opts.soft === true ? .5 : +opts.soft;
                inv_mass_recovery_rate = 1 / (rate * 60);
                inv_mass = 0; // infinite mass, unaffected by spring forces
            }
            if (!task) {
                last_time = now();
                cancel_task = false;
                task = loop(now => {
                    if (cancel_task) {
                        cancel_task = false;
                        task = null;
                        return false;
                    }
                    inv_mass = Math.min(inv_mass + inv_mass_recovery_rate, 1);
                    const ctx = {
                        inv_mass,
                        opts: spring,
                        settled: true,
                        dt: (now - last_time) * 60 / 1000
                    };
                    const next_value = tick_spring(ctx, last_value, value, target_value);
                    last_time = now;
                    last_value = value;
                    store.set(value = next_value);
                    if (ctx.settled) {
                        task = null;
                    }
                    return !ctx.settled;
                });
            }
            return new Promise(fulfil => {
                task.promise.then(() => {
                    if (token === current_token)
                        fulfil();
                });
            });
        }
        const spring = {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe,
            stiffness,
            damping,
            precision
        };
        return spring;
    }

    /* node_modules/svelte-range-slider-pips/src/RangePips.svelte generated by Svelte v3.38.2 */

    const file$l = "node_modules/svelte-range-slider-pips/src/RangePips.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	child_ctx[30] = i;
    	return child_ctx;
    }

    // (177:2) {#if ( all && first !== false ) || first }
    function create_if_block_9(ctx) {
    	let span;
    	let span_style_value;
    	let mounted;
    	let dispose;
    	let if_block = (/*all*/ ctx[6] === "label" || /*first*/ ctx[7] === "label") && create_if_block_10(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "pip first");
    			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"));
    			toggle_class(span, "selected", /*isSelected*/ ctx[19](/*min*/ ctx[0]));
    			toggle_class(span, "in-range", /*inRange*/ ctx[20](/*min*/ ctx[0]));
    			add_location(span, file$l, 177, 4, 4438);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block) if_block.m(span, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						span,
    						"click",
    						function () {
    							if (is_function(/*labelClick*/ ctx[21](/*min*/ ctx[0]))) /*labelClick*/ ctx[21](/*min*/ ctx[0]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						span,
    						"touchend",
    						prevent_default(function () {
    							if (is_function(/*labelClick*/ ctx[21](/*min*/ ctx[0]))) /*labelClick*/ ctx[21](/*min*/ ctx[0]).apply(this, arguments);
    						}),
    						false,
    						true,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*all*/ ctx[6] === "label" || /*first*/ ctx[7] === "label") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_10(ctx);
    					if_block.c();
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 0%;"))) {
    				attr_dev(span, "style", span_style_value);
    			}

    			if (dirty & /*isSelected, min*/ 524289) {
    				toggle_class(span, "selected", /*isSelected*/ ctx[19](/*min*/ ctx[0]));
    			}

    			if (dirty & /*inRange, min*/ 1048577) {
    				toggle_class(span, "in-range", /*inRange*/ ctx[20](/*min*/ ctx[0]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(177:2) {#if ( all && first !== false ) || first }",
    		ctx
    	});

    	return block;
    }

    // (186:6) {#if all === 'label' || first === 'label'}
    function create_if_block_10(ctx) {
    	let span;
    	let t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*min*/ ctx[0]), 0, 0) + "";
    	let t;
    	let if_block0 = /*prefix*/ ctx[10] && create_if_block_12(ctx);
    	let if_block1 = /*suffix*/ ctx[11] && create_if_block_11(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = text(t_value);
    			if (if_block1) if_block1.c();
    			attr_dev(span, "class", "pipVal");
    			add_location(span, file$l, 186, 8, 4728);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*prefix*/ ctx[10]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_12(ctx);
    					if_block0.c();
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*formatter, fixFloat, min*/ 69633 && t_value !== (t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*min*/ ctx[0]), 0, 0) + "")) set_data_dev(t, t_value);

    			if (/*suffix*/ ctx[11]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_11(ctx);
    					if_block1.c();
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(186:6) {#if all === 'label' || first === 'label'}",
    		ctx
    	});

    	return block;
    }

    // (188:10) {#if prefix}
    function create_if_block_12(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*prefix*/ ctx[10]);
    			attr_dev(span, "class", "pipVal-prefix");
    			add_location(span, file$l, 187, 22, 4772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(188:10) {#if prefix}",
    		ctx
    	});

    	return block;
    }

    // (188:100) {#if suffix}
    function create_if_block_11(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*suffix*/ ctx[11]);
    			attr_dev(span, "class", "pipVal-suffix");
    			add_location(span, file$l, 187, 112, 4862);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(188:100) {#if suffix}",
    		ctx
    	});

    	return block;
    }

    // (194:2) {#if ( all && rest !== false ) || rest}
    function create_if_block_4$4(ctx) {
    	let each_1_anchor;
    	let each_value = Array(/*pipCount*/ ctx[17] + 1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelClick, suffix, formatter, prefix, all, rest, min, max, pipCount*/ 4120131) {
    				each_value = Array(/*pipCount*/ ctx[17] + 1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(194:2) {#if ( all && rest !== false ) || rest}",
    		ctx
    	});

    	return block;
    }

    // (196:6) {#if pipVal(i) !== min && pipVal(i) !== max}
    function create_if_block_5$2(ctx) {
    	let span;
    	let t;
    	let span_style_value;
    	let mounted;
    	let dispose;
    	let if_block = (/*all*/ ctx[6] === "label" || /*rest*/ ctx[9] === "label") && create_if_block_6$2(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block) if_block.c();
    			t = space();
    			attr_dev(span, "class", "pip");
    			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[30])) + "%;"));
    			toggle_class(span, "selected", /*isSelected*/ ctx[19](/*pipVal*/ ctx[18](/*i*/ ctx[30])));
    			toggle_class(span, "in-range", /*inRange*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[30])));
    			add_location(span, file$l, 196, 8, 5101);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block) if_block.m(span, null);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						span,
    						"click",
    						function () {
    							if (is_function(/*labelClick*/ ctx[21](/*pipVal*/ ctx[18](/*i*/ ctx[30])))) /*labelClick*/ ctx[21](/*pipVal*/ ctx[18](/*i*/ ctx[30])).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						span,
    						"touchend",
    						prevent_default(function () {
    							if (is_function(/*labelClick*/ ctx[21](/*pipVal*/ ctx[18](/*i*/ ctx[30])))) /*labelClick*/ ctx[21](/*pipVal*/ ctx[18](/*i*/ ctx[30])).apply(this, arguments);
    						}),
    						false,
    						true,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*all*/ ctx[6] === "label" || /*rest*/ ctx[9] === "label") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_6$2(ctx);
    					if_block.c();
    					if_block.m(span, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*orientationStart, percentOf, pipVal*/ 311296 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": " + /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[30])) + "%;"))) {
    				attr_dev(span, "style", span_style_value);
    			}

    			if (dirty & /*isSelected, pipVal*/ 786432) {
    				toggle_class(span, "selected", /*isSelected*/ ctx[19](/*pipVal*/ ctx[18](/*i*/ ctx[30])));
    			}

    			if (dirty & /*inRange, pipVal*/ 1310720) {
    				toggle_class(span, "in-range", /*inRange*/ ctx[20](/*pipVal*/ ctx[18](/*i*/ ctx[30])));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(196:6) {#if pipVal(i) !== min && pipVal(i) !== max}",
    		ctx
    	});

    	return block;
    }

    // (205:10) {#if all === 'label' || rest === 'label'}
    function create_if_block_6$2(ctx) {
    	let span;
    	let t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[30]), /*i*/ ctx[30], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[30]))) + "";
    	let t;
    	let if_block0 = /*prefix*/ ctx[10] && create_if_block_8(ctx);
    	let if_block1 = /*suffix*/ ctx[11] && create_if_block_7(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = text(t_value);
    			if (if_block1) if_block1.c();
    			attr_dev(span, "class", "pipVal");
    			add_location(span, file$l, 205, 12, 5465);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*prefix*/ ctx[10]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*formatter, pipVal, percentOf*/ 299008 && t_value !== (t_value = /*formatter*/ ctx[12](/*pipVal*/ ctx[18](/*i*/ ctx[30]), /*i*/ ctx[30], /*percentOf*/ ctx[15](/*pipVal*/ ctx[18](/*i*/ ctx[30]))) + "")) set_data_dev(t, t_value);

    			if (/*suffix*/ ctx[11]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_7(ctx);
    					if_block1.c();
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(205:10) {#if all === 'label' || rest === 'label'}",
    		ctx
    	});

    	return block;
    }

    // (207:14) {#if prefix}
    function create_if_block_8(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*prefix*/ ctx[10]);
    			attr_dev(span, "class", "pipVal-prefix");
    			add_location(span, file$l, 206, 26, 5513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(207:14) {#if prefix}",
    		ctx
    	});

    	return block;
    }

    // (207:119) {#if suffix}
    function create_if_block_7(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*suffix*/ ctx[11]);
    			attr_dev(span, "class", "pipVal-suffix");
    			add_location(span, file$l, 206, 131, 5618);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(207:119) {#if suffix}",
    		ctx
    	});

    	return block;
    }

    // (195:4) {#each Array(pipCount + 1) as _, i}
    function create_each_block$e(ctx) {
    	let show_if = /*pipVal*/ ctx[18](/*i*/ ctx[30]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[30]) !== /*max*/ ctx[1];
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_5$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*pipVal, min, max*/ 262147) show_if = /*pipVal*/ ctx[18](/*i*/ ctx[30]) !== /*min*/ ctx[0] && /*pipVal*/ ctx[18](/*i*/ ctx[30]) !== /*max*/ ctx[1];

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(195:4) {#each Array(pipCount + 1) as _, i}",
    		ctx
    	});

    	return block;
    }

    // (215:2) {#if ( all && last !== false ) || last}
    function create_if_block$9(ctx) {
    	let span;
    	let span_style_value;
    	let mounted;
    	let dispose;
    	let if_block = (/*all*/ ctx[6] === "label" || /*last*/ ctx[8] === "label") && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block) if_block.c();
    			attr_dev(span, "class", "pip last");
    			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"));
    			toggle_class(span, "selected", /*isSelected*/ ctx[19](/*max*/ ctx[1]));
    			toggle_class(span, "in-range", /*inRange*/ ctx[20](/*max*/ ctx[1]));
    			add_location(span, file$l, 215, 4, 5798);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block) if_block.m(span, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						span,
    						"click",
    						function () {
    							if (is_function(/*labelClick*/ ctx[21](/*max*/ ctx[1]))) /*labelClick*/ ctx[21](/*max*/ ctx[1]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						span,
    						"touchend",
    						prevent_default(function () {
    							if (is_function(/*labelClick*/ ctx[21](/*max*/ ctx[1]))) /*labelClick*/ ctx[21](/*max*/ ctx[1]).apply(this, arguments);
    						}),
    						false,
    						true,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*all*/ ctx[6] === "label" || /*last*/ ctx[8] === "label") {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*orientationStart*/ 16384 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[14] + ": 100%;"))) {
    				attr_dev(span, "style", span_style_value);
    			}

    			if (dirty & /*isSelected, max*/ 524290) {
    				toggle_class(span, "selected", /*isSelected*/ ctx[19](/*max*/ ctx[1]));
    			}

    			if (dirty & /*inRange, max*/ 1048578) {
    				toggle_class(span, "in-range", /*inRange*/ ctx[20](/*max*/ ctx[1]));
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(215:2) {#if ( all && last !== false ) || last}",
    		ctx
    	});

    	return block;
    }

    // (224:6) {#if all === 'label' || last === 'label'}
    function create_if_block_1$8(ctx) {
    	let span;
    	let t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*max*/ ctx[1]), /*pipCount*/ ctx[17], 100) + "";
    	let t;
    	let if_block0 = /*prefix*/ ctx[10] && create_if_block_3$4(ctx);
    	let if_block1 = /*suffix*/ ctx[11] && create_if_block_2$8(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = text(t_value);
    			if (if_block1) if_block1.c();
    			attr_dev(span, "class", "pipVal");
    			add_location(span, file$l, 224, 8, 6088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*prefix*/ ctx[10]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*formatter, fixFloat, max, pipCount*/ 200706 && t_value !== (t_value = /*formatter*/ ctx[12](/*fixFloat*/ ctx[16](/*max*/ ctx[1]), /*pipCount*/ ctx[17], 100) + "")) set_data_dev(t, t_value);

    			if (/*suffix*/ ctx[11]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$8(ctx);
    					if_block1.c();
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(224:6) {#if all === 'label' || last === 'label'}",
    		ctx
    	});

    	return block;
    }

    // (226:10) {#if prefix}
    function create_if_block_3$4(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*prefix*/ ctx[10]);
    			attr_dev(span, "class", "pipVal-prefix");
    			add_location(span, file$l, 225, 22, 6132);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*prefix*/ 1024) set_data_dev(t, /*prefix*/ ctx[10]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(226:10) {#if prefix}",
    		ctx
    	});

    	return block;
    }

    // (226:109) {#if suffix}
    function create_if_block_2$8(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*suffix*/ ctx[11]);
    			attr_dev(span, "class", "pipVal-suffix");
    			add_location(span, file$l, 225, 121, 6231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*suffix*/ 2048) set_data_dev(t, /*suffix*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(226:109) {#if suffix}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let if_block0 = (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) && create_if_block_9(ctx);
    	let if_block1 = (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) && create_if_block_4$4(ctx);
    	let if_block2 = (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div, "class", "rangePips");
    			toggle_class(div, "disabled", /*disabled*/ ctx[5]);
    			toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
    			toggle_class(div, "vertical", /*vertical*/ ctx[2]);
    			toggle_class(div, "reversed", /*reversed*/ ctx[3]);
    			toggle_class(div, "focus", /*focus*/ ctx[13]);
    			add_location(div, file$l, 168, 0, 4273);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*all*/ ctx[6] && /*first*/ ctx[7] !== false || /*first*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_9(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*all*/ ctx[6] && /*rest*/ ctx[9] !== false || /*rest*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$4(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*all*/ ctx[6] && /*last*/ ctx[8] !== false || /*last*/ ctx[8]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$9(ctx);
    					if_block2.c();
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*disabled*/ 32) {
    				toggle_class(div, "disabled", /*disabled*/ ctx[5]);
    			}

    			if (dirty & /*hoverable*/ 16) {
    				toggle_class(div, "hoverable", /*hoverable*/ ctx[4]);
    			}

    			if (dirty & /*vertical*/ 4) {
    				toggle_class(div, "vertical", /*vertical*/ ctx[2]);
    			}

    			if (dirty & /*reversed*/ 8) {
    				toggle_class(div, "reversed", /*reversed*/ ctx[3]);
    			}

    			if (dirty & /*focus*/ 8192) {
    				toggle_class(div, "focus", /*focus*/ ctx[13]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let pipStep;
    	let pipCount;
    	let pipVal;
    	let isSelected;
    	let inRange;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RangePips", slots, []);
    	let { range = false } = $$props;
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { step = 1 } = $$props;
    	let { values = [(max + min) / 2] } = $$props;
    	let { vertical = false } = $$props;
    	let { reversed = false } = $$props;
    	let { hoverable = true } = $$props;
    	let { disabled = false } = $$props;
    	let { pipstep = undefined } = $$props;
    	let { all = true } = $$props;
    	let { first = undefined } = $$props;
    	let { last = undefined } = $$props;
    	let { rest = undefined } = $$props;
    	let { prefix = "" } = $$props;
    	let { suffix = "" } = $$props;
    	let { formatter = (v, i) => v } = $$props;
    	let { focus = undefined } = $$props;
    	let { orientationStart = undefined } = $$props;
    	let { percentOf = undefined } = $$props;
    	let { moveHandle = undefined } = $$props;
    	let { fixFloat = undefined } = $$props;

    	function labelClick(val) {
    		if (!disabled) {
    			moveHandle(undefined, val);
    		}
    	}

    	const writable_props = [
    		"range",
    		"min",
    		"max",
    		"step",
    		"values",
    		"vertical",
    		"reversed",
    		"hoverable",
    		"disabled",
    		"pipstep",
    		"all",
    		"first",
    		"last",
    		"rest",
    		"prefix",
    		"suffix",
    		"formatter",
    		"focus",
    		"orientationStart",
    		"percentOf",
    		"moveHandle",
    		"fixFloat"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RangePips> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("range" in $$props) $$invalidate(22, range = $$props.range);
    		if ("min" in $$props) $$invalidate(0, min = $$props.min);
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("step" in $$props) $$invalidate(23, step = $$props.step);
    		if ("values" in $$props) $$invalidate(24, values = $$props.values);
    		if ("vertical" in $$props) $$invalidate(2, vertical = $$props.vertical);
    		if ("reversed" in $$props) $$invalidate(3, reversed = $$props.reversed);
    		if ("hoverable" in $$props) $$invalidate(4, hoverable = $$props.hoverable);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("pipstep" in $$props) $$invalidate(25, pipstep = $$props.pipstep);
    		if ("all" in $$props) $$invalidate(6, all = $$props.all);
    		if ("first" in $$props) $$invalidate(7, first = $$props.first);
    		if ("last" in $$props) $$invalidate(8, last = $$props.last);
    		if ("rest" in $$props) $$invalidate(9, rest = $$props.rest);
    		if ("prefix" in $$props) $$invalidate(10, prefix = $$props.prefix);
    		if ("suffix" in $$props) $$invalidate(11, suffix = $$props.suffix);
    		if ("formatter" in $$props) $$invalidate(12, formatter = $$props.formatter);
    		if ("focus" in $$props) $$invalidate(13, focus = $$props.focus);
    		if ("orientationStart" in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
    		if ("percentOf" in $$props) $$invalidate(15, percentOf = $$props.percentOf);
    		if ("moveHandle" in $$props) $$invalidate(26, moveHandle = $$props.moveHandle);
    		if ("fixFloat" in $$props) $$invalidate(16, fixFloat = $$props.fixFloat);
    	};

    	$$self.$capture_state = () => ({
    		range,
    		min,
    		max,
    		step,
    		values,
    		vertical,
    		reversed,
    		hoverable,
    		disabled,
    		pipstep,
    		all,
    		first,
    		last,
    		rest,
    		prefix,
    		suffix,
    		formatter,
    		focus,
    		orientationStart,
    		percentOf,
    		moveHandle,
    		fixFloat,
    		labelClick,
    		pipStep,
    		pipCount,
    		pipVal,
    		isSelected,
    		inRange
    	});

    	$$self.$inject_state = $$props => {
    		if ("range" in $$props) $$invalidate(22, range = $$props.range);
    		if ("min" in $$props) $$invalidate(0, min = $$props.min);
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("step" in $$props) $$invalidate(23, step = $$props.step);
    		if ("values" in $$props) $$invalidate(24, values = $$props.values);
    		if ("vertical" in $$props) $$invalidate(2, vertical = $$props.vertical);
    		if ("reversed" in $$props) $$invalidate(3, reversed = $$props.reversed);
    		if ("hoverable" in $$props) $$invalidate(4, hoverable = $$props.hoverable);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("pipstep" in $$props) $$invalidate(25, pipstep = $$props.pipstep);
    		if ("all" in $$props) $$invalidate(6, all = $$props.all);
    		if ("first" in $$props) $$invalidate(7, first = $$props.first);
    		if ("last" in $$props) $$invalidate(8, last = $$props.last);
    		if ("rest" in $$props) $$invalidate(9, rest = $$props.rest);
    		if ("prefix" in $$props) $$invalidate(10, prefix = $$props.prefix);
    		if ("suffix" in $$props) $$invalidate(11, suffix = $$props.suffix);
    		if ("formatter" in $$props) $$invalidate(12, formatter = $$props.formatter);
    		if ("focus" in $$props) $$invalidate(13, focus = $$props.focus);
    		if ("orientationStart" in $$props) $$invalidate(14, orientationStart = $$props.orientationStart);
    		if ("percentOf" in $$props) $$invalidate(15, percentOf = $$props.percentOf);
    		if ("moveHandle" in $$props) $$invalidate(26, moveHandle = $$props.moveHandle);
    		if ("fixFloat" in $$props) $$invalidate(16, fixFloat = $$props.fixFloat);
    		if ("pipStep" in $$props) $$invalidate(27, pipStep = $$props.pipStep);
    		if ("pipCount" in $$props) $$invalidate(17, pipCount = $$props.pipCount);
    		if ("pipVal" in $$props) $$invalidate(18, pipVal = $$props.pipVal);
    		if ("isSelected" in $$props) $$invalidate(19, isSelected = $$props.isSelected);
    		if ("inRange" in $$props) $$invalidate(20, inRange = $$props.inRange);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pipstep, max, min, step, vertical*/ 41943047) {
    			$$invalidate(27, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100)
    			? (max - min) / (vertical ? 10 : 20)
    			: 1));
    		}

    		if ($$self.$$.dirty & /*max, min, step, pipStep*/ 142606339) {
    			$$invalidate(17, pipCount = parseInt((max - min) / (step * pipStep), 10));
    		}

    		if ($$self.$$.dirty & /*fixFloat, min, step, pipStep*/ 142671873) {
    			$$invalidate(18, pipVal = function (val) {
    				return fixFloat(min + val * step * pipStep);
    			});
    		}

    		if ($$self.$$.dirty & /*values, fixFloat*/ 16842752) {
    			$$invalidate(19, isSelected = function (val) {
    				return values.some(v => fixFloat(v) === fixFloat(val));
    			});
    		}

    		if ($$self.$$.dirty & /*range, values*/ 20971520) {
    			$$invalidate(20, inRange = function (val) {
    				if (range === "min") {
    					return values[0] > val;
    				} else if (range === "max") {
    					return values[0] < val;
    				} else if (range) {
    					return values[0] < val && values[1] > val;
    				}
    			});
    		}
    	};

    	return [
    		min,
    		max,
    		vertical,
    		reversed,
    		hoverable,
    		disabled,
    		all,
    		first,
    		last,
    		rest,
    		prefix,
    		suffix,
    		formatter,
    		focus,
    		orientationStart,
    		percentOf,
    		fixFloat,
    		pipCount,
    		pipVal,
    		isSelected,
    		inRange,
    		labelClick,
    		range,
    		step,
    		values,
    		pipstep,
    		moveHandle,
    		pipStep
    	];
    }

    class RangePips extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			range: 22,
    			min: 0,
    			max: 1,
    			step: 23,
    			values: 24,
    			vertical: 2,
    			reversed: 3,
    			hoverable: 4,
    			disabled: 5,
    			pipstep: 25,
    			all: 6,
    			first: 7,
    			last: 8,
    			rest: 9,
    			prefix: 10,
    			suffix: 11,
    			formatter: 12,
    			focus: 13,
    			orientationStart: 14,
    			percentOf: 15,
    			moveHandle: 26,
    			fixFloat: 16
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RangePips",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get range() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set range(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get values() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reversed() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reversed(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverable() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverable(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pipstep() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pipstep(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get all() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set all(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get first() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set first(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get last() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set last(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rest() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rest(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get suffix() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set suffix(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formatter() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formatter(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focus(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get orientationStart() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set orientationStart(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get percentOf() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set percentOf(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get moveHandle() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set moveHandle(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixFloat() {
    		throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixFloat(value) {
    		throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-range-slider-pips/src/RangeSlider.svelte generated by Svelte v3.38.2 */

    const { console: console_1$4 } = globals;
    const file$k = "node_modules/svelte-range-slider-pips/src/RangeSlider.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[64] = list[i];
    	child_ctx[66] = i;
    	return child_ctx;
    }

    // (821:6) {#if float}
    function create_if_block_2$7(ctx) {
    	let span;
    	let t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + "";
    	let t;
    	let if_block0 = /*prefix*/ ctx[18] && create_if_block_4$3(ctx);
    	let if_block1 = /*suffix*/ ctx[19] && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = text(t_value);
    			if (if_block1) if_block1.c();
    			attr_dev(span, "class", "rangeFloat");
    			add_location(span, file$k, 821, 8, 24447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*prefix*/ ctx[18]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*handleFormatter, values, percentOf*/ 10485761 && t_value !== (t_value = /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + "")) set_data_dev(t, t_value);

    			if (/*suffix*/ ctx[19]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$3(ctx);
    					if_block1.c();
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(821:6) {#if float}",
    		ctx
    	});

    	return block;
    }

    // (823:10) {#if prefix}
    function create_if_block_4$3(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*prefix*/ ctx[18]);
    			attr_dev(span, "class", "rangeFloat-prefix");
    			add_location(span, file$k, 822, 22, 24495);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*prefix*/ 262144) set_data_dev(t, /*prefix*/ ctx[18]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(823:10) {#if prefix}",
    		ctx
    	});

    	return block;
    }

    // (823:121) {#if suffix}
    function create_if_block_3$3(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*suffix*/ ctx[19]);
    			attr_dev(span, "class", "rangeFloat-suffix");
    			add_location(span, file$k, 822, 133, 24606);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*suffix*/ 524288) set_data_dev(t, /*suffix*/ ctx[19]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(823:121) {#if suffix}",
    		ctx
    	});

    	return block;
    }

    // (800:2) {#each values as value, index}
    function create_each_block$d(ctx) {
    	let span1;
    	let span0;
    	let t;
    	let span1_style_value;
    	let span1_aria_valuemin_value;
    	let span1_aria_valuemax_value;
    	let span1_aria_valuenow_value;
    	let span1_aria_valuetext_value;
    	let span1_aria_orientation_value;
    	let span1_tabindex_value;
    	let mounted;
    	let dispose;
    	let if_block = /*float*/ ctx[7] && create_if_block_2$7(ctx);

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			span0 = element("span");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(span0, "class", "rangeNub");
    			add_location(span0, file$k, 819, 6, 24395);
    			attr_dev(span1, "role", "slider");
    			attr_dev(span1, "class", "rangeHandle");
    			attr_dev(span1, "data-handle", /*index*/ ctx[66]);
    			attr_dev(span1, "style", span1_style_value = "" + (/*orientationStart*/ ctx[27] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[66]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[66] ? 3 : 2) + ";"));

    			attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 1
    			? /*values*/ ctx[0][0]
    			: /*min*/ ctx[3]);

    			attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 0
    			? /*values*/ ctx[0][1]
    			: /*max*/ ctx[4]);

    			attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/ ctx[64]);
    			attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + /*suffix*/ ctx[19]));
    			attr_dev(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/ ctx[6] ? "vertical" : "horizontal");
    			attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
    			attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
    			attr_dev(span1, "tabindex", span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0);
    			toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
    			toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
    			add_location(span1, file$k, 800, 4, 23582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, span0);
    			append_dev(span1, t);
    			if (if_block) if_block.m(span1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span1, "blur", /*sliderBlurHandle*/ ctx[34], false, false, false),
    					listen_dev(span1, "focus", /*sliderFocusHandle*/ ctx[35], false, false, false),
    					listen_dev(span1, "keydown", /*sliderKeydown*/ ctx[36], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*float*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$7(ctx);
    					if_block.c();
    					if_block.m(span1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/ 738197504 && span1_style_value !== (span1_style_value = "" + (/*orientationStart*/ ctx[27] + ": " + /*$springPositions*/ ctx[29][/*index*/ ctx[66]] + "%; z-index: " + (/*activeHandle*/ ctx[26] === /*index*/ ctx[66] ? 3 : 2) + ";"))) {
    				attr_dev(span1, "style", span1_style_value);
    			}

    			if (dirty[0] & /*range, values, min*/ 13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 1
    			? /*values*/ ctx[0][0]
    			: /*min*/ ctx[3])) {
    				attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value);
    			}

    			if (dirty[0] & /*range, values, max*/ 21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/ ctx[2] === true && /*index*/ ctx[66] === 0
    			? /*values*/ ctx[0][1]
    			: /*max*/ ctx[4])) {
    				attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value);
    			}

    			if (dirty[0] & /*values*/ 1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/ ctx[64])) {
    				attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value);
    			}

    			if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/ 11272193 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + (/*prefix*/ ctx[18] + /*handleFormatter*/ ctx[21](/*value*/ ctx[64], /*index*/ ctx[66], /*percentOf*/ ctx[23](/*value*/ ctx[64])) + /*suffix*/ ctx[19]))) {
    				attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value);
    			}

    			if (dirty[0] & /*vertical*/ 64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/ ctx[6] ? "vertical" : "horizontal")) {
    				attr_dev(span1, "aria-orientation", span1_aria_orientation_value);
    			}

    			if (dirty[0] & /*disabled*/ 1024) {
    				attr_dev(span1, "aria-disabled", /*disabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*disabled*/ 1024) {
    				attr_dev(span1, "disabled", /*disabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*disabled*/ 1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/ ctx[10] ? -1 : 0)) {
    				attr_dev(span1, "tabindex", span1_tabindex_value);
    			}

    			if (dirty[0] & /*focus, activeHandle*/ 83886080) {
    				toggle_class(span1, "active", /*focus*/ ctx[24] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
    			}

    			if (dirty[0] & /*handlePressed, activeHandle*/ 100663296) {
    				toggle_class(span1, "press", /*handlePressed*/ ctx[25] && /*activeHandle*/ ctx[26] === /*index*/ ctx[66]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(800:2) {#each values as value, index}",
    		ctx
    	});

    	return block;
    }

    // (828:2) {#if range}
    function create_if_block_1$7(ctx) {
    	let span;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "rangeBar");
    			attr_dev(span, "style", span_style_value = "" + (/*orientationStart*/ ctx[27] + ": " + /*rangeStart*/ ctx[32](/*$springPositions*/ ctx[29]) + "%; \n             " + /*orientationEnd*/ ctx[28] + ": " + /*rangeEnd*/ ctx[33](/*$springPositions*/ ctx[29]) + "%;"));
    			add_location(span, file$k, 828, 4, 24727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/ 939524096 && span_style_value !== (span_style_value = "" + (/*orientationStart*/ ctx[27] + ": " + /*rangeStart*/ ctx[32](/*$springPositions*/ ctx[29]) + "%; \n             " + /*orientationEnd*/ ctx[28] + ": " + /*rangeEnd*/ ctx[33](/*$springPositions*/ ctx[29]) + "%;"))) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(828:2) {#if range}",
    		ctx
    	});

    	return block;
    }

    // (834:2) {#if pips}
    function create_if_block$8(ctx) {
    	let rangepips;
    	let current;

    	rangepips = new RangePips({
    			props: {
    				values: /*values*/ ctx[0],
    				min: /*min*/ ctx[3],
    				max: /*max*/ ctx[4],
    				step: /*step*/ ctx[5],
    				range: /*range*/ ctx[2],
    				vertical: /*vertical*/ ctx[6],
    				reversed: /*reversed*/ ctx[8],
    				orientationStart: /*orientationStart*/ ctx[27],
    				hoverable: /*hoverable*/ ctx[9],
    				disabled: /*disabled*/ ctx[10],
    				all: /*all*/ ctx[13],
    				first: /*first*/ ctx[14],
    				last: /*last*/ ctx[15],
    				rest: /*rest*/ ctx[16],
    				pipstep: /*pipstep*/ ctx[12],
    				prefix: /*prefix*/ ctx[18],
    				suffix: /*suffix*/ ctx[19],
    				formatter: /*formatter*/ ctx[20],
    				focus: /*focus*/ ctx[24],
    				percentOf: /*percentOf*/ ctx[23],
    				moveHandle: /*moveHandle*/ ctx[31],
    				fixFloat: /*fixFloat*/ ctx[30]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rangepips.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rangepips, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rangepips_changes = {};
    			if (dirty[0] & /*values*/ 1) rangepips_changes.values = /*values*/ ctx[0];
    			if (dirty[0] & /*min*/ 8) rangepips_changes.min = /*min*/ ctx[3];
    			if (dirty[0] & /*max*/ 16) rangepips_changes.max = /*max*/ ctx[4];
    			if (dirty[0] & /*step*/ 32) rangepips_changes.step = /*step*/ ctx[5];
    			if (dirty[0] & /*range*/ 4) rangepips_changes.range = /*range*/ ctx[2];
    			if (dirty[0] & /*vertical*/ 64) rangepips_changes.vertical = /*vertical*/ ctx[6];
    			if (dirty[0] & /*reversed*/ 256) rangepips_changes.reversed = /*reversed*/ ctx[8];
    			if (dirty[0] & /*orientationStart*/ 134217728) rangepips_changes.orientationStart = /*orientationStart*/ ctx[27];
    			if (dirty[0] & /*hoverable*/ 512) rangepips_changes.hoverable = /*hoverable*/ ctx[9];
    			if (dirty[0] & /*disabled*/ 1024) rangepips_changes.disabled = /*disabled*/ ctx[10];
    			if (dirty[0] & /*all*/ 8192) rangepips_changes.all = /*all*/ ctx[13];
    			if (dirty[0] & /*first*/ 16384) rangepips_changes.first = /*first*/ ctx[14];
    			if (dirty[0] & /*last*/ 32768) rangepips_changes.last = /*last*/ ctx[15];
    			if (dirty[0] & /*rest*/ 65536) rangepips_changes.rest = /*rest*/ ctx[16];
    			if (dirty[0] & /*pipstep*/ 4096) rangepips_changes.pipstep = /*pipstep*/ ctx[12];
    			if (dirty[0] & /*prefix*/ 262144) rangepips_changes.prefix = /*prefix*/ ctx[18];
    			if (dirty[0] & /*suffix*/ 524288) rangepips_changes.suffix = /*suffix*/ ctx[19];
    			if (dirty[0] & /*formatter*/ 1048576) rangepips_changes.formatter = /*formatter*/ ctx[20];
    			if (dirty[0] & /*focus*/ 16777216) rangepips_changes.focus = /*focus*/ ctx[24];
    			if (dirty[0] & /*percentOf*/ 8388608) rangepips_changes.percentOf = /*percentOf*/ ctx[23];
    			rangepips.$set(rangepips_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rangepips.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rangepips.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rangepips, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(834:2) {#if pips}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*values*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	let if_block0 = /*range*/ ctx[2] && create_if_block_1$7(ctx);
    	let if_block1 = /*pips*/ ctx[11] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "id", /*id*/ ctx[17]);
    			attr_dev(div, "class", "rangeSlider");
    			toggle_class(div, "range", /*range*/ ctx[2]);
    			toggle_class(div, "disabled", /*disabled*/ ctx[10]);
    			toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
    			toggle_class(div, "vertical", /*vertical*/ ctx[6]);
    			toggle_class(div, "reversed", /*reversed*/ ctx[8]);
    			toggle_class(div, "focus", /*focus*/ ctx[24]);
    			toggle_class(div, "min", /*range*/ ctx[2] === "min");
    			toggle_class(div, "max", /*range*/ ctx[2] === "max");
    			toggle_class(div, "pips", /*pips*/ ctx[11]);
    			toggle_class(div, "pip-labels", /*all*/ ctx[13] === "label" || /*first*/ ctx[14] === "label" || /*last*/ ctx[15] === "label" || /*rest*/ ctx[16] === "label");
    			add_location(div, file$k, 780, 0, 23048);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t0);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			/*div_binding*/ ctx[50](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "mousedown", /*bodyInteractStart*/ ctx[39], false, false, false),
    					listen_dev(window, "touchstart", /*bodyInteractStart*/ ctx[39], false, false, false),
    					listen_dev(window, "mousemove", /*bodyInteract*/ ctx[40], false, false, false),
    					listen_dev(window, "touchmove", /*bodyInteract*/ ctx[40], false, false, false),
    					listen_dev(window, "mouseup", /*bodyMouseUp*/ ctx[41], false, false, false),
    					listen_dev(window, "touchend", /*bodyTouchEnd*/ ctx[42], false, false, false),
    					listen_dev(window, "keydown", /*bodyKeyDown*/ ctx[43], false, false, false),
    					listen_dev(div, "mousedown", /*sliderInteractStart*/ ctx[37], false, false, false),
    					listen_dev(div, "mouseup", /*sliderInteractEnd*/ ctx[38], false, false, false),
    					listen_dev(div, "touchstart", prevent_default(/*sliderInteractStart*/ ctx[37]), false, true, false),
    					listen_dev(div, "touchend", prevent_default(/*sliderInteractEnd*/ ctx[38]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*orientationStart, $springPositions, activeHandle, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/ 799802589 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/ 56) {
    				each_value = /*values*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (/*range*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*pips*/ ctx[11]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*pips*/ 2048) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*id*/ 131072) {
    				attr_dev(div, "id", /*id*/ ctx[17]);
    			}

    			if (dirty[0] & /*range*/ 4) {
    				toggle_class(div, "range", /*range*/ ctx[2]);
    			}

    			if (dirty[0] & /*disabled*/ 1024) {
    				toggle_class(div, "disabled", /*disabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*hoverable*/ 512) {
    				toggle_class(div, "hoverable", /*hoverable*/ ctx[9]);
    			}

    			if (dirty[0] & /*vertical*/ 64) {
    				toggle_class(div, "vertical", /*vertical*/ ctx[6]);
    			}

    			if (dirty[0] & /*reversed*/ 256) {
    				toggle_class(div, "reversed", /*reversed*/ ctx[8]);
    			}

    			if (dirty[0] & /*focus*/ 16777216) {
    				toggle_class(div, "focus", /*focus*/ ctx[24]);
    			}

    			if (dirty[0] & /*range*/ 4) {
    				toggle_class(div, "min", /*range*/ ctx[2] === "min");
    			}

    			if (dirty[0] & /*range*/ 4) {
    				toggle_class(div, "max", /*range*/ ctx[2] === "max");
    			}

    			if (dirty[0] & /*pips*/ 2048) {
    				toggle_class(div, "pips", /*pips*/ ctx[11]);
    			}

    			if (dirty[0] & /*all, first, last, rest*/ 122880) {
    				toggle_class(div, "pip-labels", /*all*/ ctx[13] === "label" || /*first*/ ctx[14] === "label" || /*last*/ ctx[15] === "label" || /*rest*/ ctx[16] === "label");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*div_binding*/ ctx[50](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function index(el) {
    	if (!el) return -1;
    	var i = 0;

    	while (el = el.previousElementSibling) {
    		i++;
    	}

    	return i;
    }

    /**
     * normalise a mouse or touch event to return the
     * client (x/y) object for that event
     * @param {event} e a mouse/touch event to normalise
     * @returns {object} normalised event client object (x,y)
     **/
    function normalisedClient(e) {
    	if (e.type.includes("touch")) {
    		return e.touches[0];
    	} else {
    		return e;
    	}
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let percentOf;
    	let clampValue;
    	let alignValueToStep;
    	let orientationStart;
    	let orientationEnd;

    	let $springPositions,
    		$$unsubscribe_springPositions = noop,
    		$$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, $$value => $$invalidate(29, $springPositions = $$value)), springPositions);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RangeSlider", slots, []);
    	let { slider = undefined } = $$props;
    	let { range = false } = $$props;
    	let { pushy = false } = $$props;
    	let { min = 0 } = $$props;
    	let { max = 100 } = $$props;
    	let { step = 1 } = $$props;
    	let { values = [(max + min) / 2] } = $$props;
    	let { vertical = false } = $$props;
    	let { float = false } = $$props;
    	let { reversed = false } = $$props;
    	let { hoverable = true } = $$props;
    	let { disabled = false } = $$props;
    	let { pips = false } = $$props;
    	let { pipstep = undefined } = $$props;
    	let { all = undefined } = $$props;
    	let { first = undefined } = $$props;
    	let { last = undefined } = $$props;
    	let { rest = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { prefix = "" } = $$props;
    	let { suffix = "" } = $$props;
    	let { formatter = (v, i, p) => v } = $$props;
    	let { handleFormatter = formatter } = $$props;
    	let { precision = 2 } = $$props;
    	let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;

    	// prepare dispatched events
    	const dispatch = createEventDispatcher();

    	// state management
    	let valueLength = 0;

    	let focus = false;
    	let handleActivated = false;
    	let handlePressed = false;
    	let keyboardActive = false;
    	let activeHandle = values.length - 1;
    	let startValue;
    	let previousValue;

    	// copy the initial values in to a spring function which
    	// will update every time the values array is modified
    	let springPositions;

    	const fixFloat = v => parseFloat(v.toFixed(precision));
    	

    	/**
     * check if an element is a handle on the slider
     * @param {object} el dom object reference we want to check
     * @returns {boolean}
     **/
    	function targetIsHandle(el) {
    		const handles = slider.querySelectorAll(".handle");
    		const isHandle = Array.prototype.includes.call(handles, el);
    		const isChild = Array.prototype.some.call(handles, e => e.contains(el));
    		return isHandle || isChild;
    	}

    	/**
     * trim the values array based on whether the property
     * for 'range' is 'min', 'max', or truthy. This is because we
     * do not want more than one handle for a min/max range, and we do
     * not want more than two handles for a true range.
     * @param {array} values the input values for the rangeSlider
     * @return {array} the range array for creating a rangeSlider
     **/
    	function trimRange(values) {
    		if (range === "min" || range === "max") {
    			return values.slice(0, 1);
    		} else if (range) {
    			return values.slice(0, 2);
    		} else {
    			return values;
    		}
    	}

    	/**
     * helper to return the slider dimensions for finding
     * the closest handle to user interaction
     * @return {object} the range slider DOM client rect
     **/
    	function getSliderDimensions() {
    		return slider.getBoundingClientRect();
    	}

    	/**
     * helper to return closest handle to user interaction
     * @param {object} clientPos the client{x,y} positions to check against
     * @return {number} the index of the closest handle to clientPos
     **/
    	function getClosestHandle(clientPos) {
    		// first make sure we have the latest dimensions
    		// of the slider, as it may have changed size
    		const dims = getSliderDimensions();

    		// calculate the interaction position, percent and value
    		let handlePos = 0;

    		let handlePercent = 0;
    		let handleVal = 0;

    		if (vertical) {
    			handlePos = clientPos.clientY - dims.top;
    			handlePercent = handlePos / dims.height * 100;
    			handlePercent = reversed ? handlePercent : 100 - handlePercent;
    		} else {
    			handlePos = clientPos.clientX - dims.left;
    			handlePercent = handlePos / dims.width * 100;
    			handlePercent = reversed ? 100 - handlePercent : handlePercent;
    		}

    		handleVal = (max - min) / 100 * handlePercent + min;
    		let closest;

    		// if we have a range, and the handles are at the same
    		// position, we want a simple check if the interaction
    		// value is greater than return the second handle
    		if (range === true && values[0] === values[1]) {
    			if (handleVal > values[1]) {
    				return 1;
    			} else {
    				return 0;
    			}
    		} else // we sort the handles values, and return the first one closest
    		// to the interaction value
    		{
    			closest = values.indexOf([...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]); // if there are multiple handles, and not a range, then
    		}

    		return closest;
    	}

    	/**
     * take the interaction position on the slider, convert
     * it to a value on the range, and then send that value
     * through to the moveHandle() method to set the active
     * handle's position
     * @param {object} clientPos the client{x,y} of the interaction
     **/
    	function handleInteract(clientPos) {
    		// first make sure we have the latest dimensions
    		// of the slider, as it may have changed size
    		const dims = getSliderDimensions();

    		// calculate the interaction position, percent and value
    		let handlePos = 0;

    		let handlePercent = 0;
    		let handleVal = 0;

    		if (vertical) {
    			handlePos = clientPos.clientY - dims.top;
    			handlePercent = handlePos / dims.height * 100;
    			handlePercent = reversed ? handlePercent : 100 - handlePercent;
    		} else {
    			handlePos = clientPos.clientX - dims.left;
    			handlePercent = handlePos / dims.width * 100;
    			handlePercent = reversed ? 100 - handlePercent : handlePercent;
    		}

    		handleVal = (max - min) / 100 * handlePercent + min;

    		// move handle to the value
    		moveHandle(activeHandle, handleVal);
    	}

    	/**
     * move a handle to a specific value, respecting the clamp/align rules
     * @param {number} index the index of the handle we want to move
     * @param {number} value the value to move the handle to
     * @return {number} the value that was moved to (after alignment/clamping)
     **/
    	function moveHandle(index, value) {
    		// align & clamp the value so we're not doing extra
    		// calculation on an out-of-range value down below
    		value = alignValueToStep(value);

    		// use the active handle if handle index is not provided
    		if (typeof index === "undefined") {
    			index = activeHandle;
    		}

    		// if this is a range slider perform special checks
    		if (range) {
    			// restrict the handles of a range-slider from
    			// going past one-another unless "pushy" is true
    			if (index === 0 && value > values[1]) {
    				if (pushy) {
    					$$invalidate(0, values[1] = value, values);
    				} else {
    					value = values[1];
    				}
    			} else if (index === 1 && value < values[0]) {
    				if (pushy) {
    					$$invalidate(0, values[0] = value, values);
    				} else {
    					value = values[0];
    				}
    			}
    		}

    		// if the value has changed, update it
    		if (values[index] !== value) {
    			$$invalidate(0, values[index] = value, values);
    		}

    		// fire the change event when the handle moves,
    		// and store the previous value for the next time
    		if (previousValue !== value) {
    			eChange();
    			previousValue = value;
    		}

    		return value;
    	}

    	/**
     * helper to find the beginning range value for use with css style
     * @param {array} values the input values for the rangeSlider
     * @return {number} the beginning of the range
     **/
    	function rangeStart(values) {
    		if (range === "min") {
    			return 0;
    		} else {
    			return values[0];
    		}
    	}

    	/**
     * helper to find the ending range value for use with css style
     * @param {array} values the input values for the rangeSlider
     * @return {number} the end of the range
     **/
    	function rangeEnd(values) {
    		if (range === "max") {
    			return 0;
    		} else if (range === "min") {
    			return 100 - values[0];
    		} else {
    			return 100 - values[1];
    		}
    	}

    	/**
     * when the user has unfocussed (blurred) from the
     * slider, deactivate all handles
     * @param {event} e the event from browser
     **/
    	function sliderBlurHandle(e) {
    		if (keyboardActive) {
    			$$invalidate(24, focus = false);
    			handleActivated = false;
    			$$invalidate(25, handlePressed = false);
    		}
    	}

    	/**
     * when the user focusses the handle of a slider
     * set it to be active
     * @param {event} e the event from browser
     **/
    	function sliderFocusHandle(e) {
    		if (!disabled) {
    			$$invalidate(26, activeHandle = index(e.target));
    			$$invalidate(24, focus = true);
    		}
    	}

    	/**
     * handle the keyboard accessible features by checking the
     * input type, and modfier key then moving handle by appropriate amount
     * @param {event} e the event from browser
     **/
    	function sliderKeydown(e) {
    		if (!disabled) {
    			const handle = index(e.target);
    			let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
    			let prevent = false;

    			switch (e.key) {
    				case "PageDown":
    					jump *= 10;
    				case "ArrowRight":
    				case "ArrowUp":
    					moveHandle(handle, values[handle] + jump);
    					prevent = true;
    					break;
    				case "PageUp":
    					jump *= 10;
    				case "ArrowLeft":
    				case "ArrowDown":
    					moveHandle(handle, values[handle] - jump);
    					prevent = true;
    					break;
    				case "Home":
    					moveHandle(handle, min);
    					prevent = true;
    					break;
    				case "End":
    					moveHandle(handle, max);
    					prevent = true;
    					break;
    			}

    			if (prevent) {
    				e.preventDefault();
    				e.stopPropagation();
    			}
    		}
    	}

    	/**
     * function to run when the user touches
     * down on the slider element anywhere
     * @param {event} e the event from browser
     **/
    	function sliderInteractStart(e) {
    		if (!disabled) {
    			const el = e.target;
    			const clientPos = normalisedClient(e);

    			// set the closest handle as active
    			$$invalidate(24, focus = true);

    			handleActivated = true;
    			$$invalidate(25, handlePressed = true);
    			$$invalidate(26, activeHandle = getClosestHandle(clientPos));

    			// fire the start event
    			startValue = previousValue = alignValueToStep(values[activeHandle]);

    			eStart();

    			// for touch devices we want the handle to instantly
    			// move to the position touched for more responsive feeling
    			if (e.type === "touchstart" && !el.matches(".pipVal")) {
    				handleInteract(clientPos);
    			}
    		}
    	}

    	/**
     * function to run when the user stops touching
     * down on the slider element anywhere
     * @param {event} e the event from browser
     **/
    	function sliderInteractEnd(e) {
    		// fire the stop event for touch devices
    		if (e.type === "touchend") {
    			eStop();
    		}

    		$$invalidate(25, handlePressed = false);
    	}

    	/**
     * unfocus the slider if the user clicked off of
     * it, somewhere else on the screen
     * @param {event} e the event from browser
     **/
    	function bodyInteractStart(e) {
    		keyboardActive = false;

    		if (focus && e.target !== slider && !slider.contains(e.target)) {
    			$$invalidate(24, focus = false);
    		}
    	}

    	/**
     * send the clientX through to handle the interaction
     * whenever the user moves acros screen while active
     * @param {event} e the event from browser
     **/
    	function bodyInteract(e) {
    		if (!disabled) {
    			if (handleActivated) {
    				handleInteract(normalisedClient(e));
    			}
    		}
    	}

    	/**
     * if user triggers mouseup on the body while
     * a handle is active (without moving) then we
     * trigger an interact event there
     * @param {event} e the event from browser
     **/
    	function bodyMouseUp(e) {
    		if (!disabled) {
    			const el = e.target;

    			// this only works if a handle is active, which can
    			// only happen if there was sliderInteractStart triggered
    			// on the slider, already
    			if (handleActivated) {
    				if (el === slider || slider.contains(el)) {
    					$$invalidate(24, focus = true);

    					// don't trigger interact if the target is a handle (no need) or
    					// if the target is a label (we want to move to that value from rangePips)
    					if (!targetIsHandle(el) && !el.matches(".pipVal")) {
    						handleInteract(normalisedClient(e));
    					}
    				}

    				// fire the stop event for mouse device
    				// when the body is triggered with an active handle
    				eStop();
    			}
    		}

    		handleActivated = false;
    		$$invalidate(25, handlePressed = false);
    	}

    	/**
     * if user triggers touchend on the body then we
     * defocus the slider completely
     * @param {event} e the event from browser
     **/
    	function bodyTouchEnd(e) {
    		handleActivated = false;
    		$$invalidate(25, handlePressed = false);
    	}

    	function bodyKeyDown(e) {
    		if (!disabled) {
    			if (e.target === slider || slider.contains(e.target)) {
    				keyboardActive = true;
    			}
    		}
    	}

    	function eStart() {
    		!disabled && dispatch("start", {
    			activeHandle,
    			value: startValue,
    			values: values.map(v => alignValueToStep(v))
    		});
    	}

    	function eStop() {
    		!disabled && dispatch("stop", {
    			activeHandle,
    			startValue,
    			value: values[activeHandle],
    			values: values.map(v => alignValueToStep(v))
    		});
    	}

    	function eChange() {
    		!disabled && dispatch("change", {
    			activeHandle,
    			startValue,
    			previousValue: typeof previousValue === "undefined"
    			? startValue
    			: previousValue,
    			value: values[activeHandle],
    			values: values.map(v => alignValueToStep(v))
    		});
    	}

    	const writable_props = [
    		"slider",
    		"range",
    		"pushy",
    		"min",
    		"max",
    		"step",
    		"values",
    		"vertical",
    		"float",
    		"reversed",
    		"hoverable",
    		"disabled",
    		"pips",
    		"pipstep",
    		"all",
    		"first",
    		"last",
    		"rest",
    		"id",
    		"prefix",
    		"suffix",
    		"formatter",
    		"handleFormatter",
    		"precision",
    		"springValues"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<RangeSlider> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			slider = $$value;
    			$$invalidate(1, slider);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("slider" in $$props) $$invalidate(1, slider = $$props.slider);
    		if ("range" in $$props) $$invalidate(2, range = $$props.range);
    		if ("pushy" in $$props) $$invalidate(44, pushy = $$props.pushy);
    		if ("min" in $$props) $$invalidate(3, min = $$props.min);
    		if ("max" in $$props) $$invalidate(4, max = $$props.max);
    		if ("step" in $$props) $$invalidate(5, step = $$props.step);
    		if ("values" in $$props) $$invalidate(0, values = $$props.values);
    		if ("vertical" in $$props) $$invalidate(6, vertical = $$props.vertical);
    		if ("float" in $$props) $$invalidate(7, float = $$props.float);
    		if ("reversed" in $$props) $$invalidate(8, reversed = $$props.reversed);
    		if ("hoverable" in $$props) $$invalidate(9, hoverable = $$props.hoverable);
    		if ("disabled" in $$props) $$invalidate(10, disabled = $$props.disabled);
    		if ("pips" in $$props) $$invalidate(11, pips = $$props.pips);
    		if ("pipstep" in $$props) $$invalidate(12, pipstep = $$props.pipstep);
    		if ("all" in $$props) $$invalidate(13, all = $$props.all);
    		if ("first" in $$props) $$invalidate(14, first = $$props.first);
    		if ("last" in $$props) $$invalidate(15, last = $$props.last);
    		if ("rest" in $$props) $$invalidate(16, rest = $$props.rest);
    		if ("id" in $$props) $$invalidate(17, id = $$props.id);
    		if ("prefix" in $$props) $$invalidate(18, prefix = $$props.prefix);
    		if ("suffix" in $$props) $$invalidate(19, suffix = $$props.suffix);
    		if ("formatter" in $$props) $$invalidate(20, formatter = $$props.formatter);
    		if ("handleFormatter" in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
    		if ("precision" in $$props) $$invalidate(45, precision = $$props.precision);
    		if ("springValues" in $$props) $$invalidate(46, springValues = $$props.springValues);
    	};

    	$$self.$capture_state = () => ({
    		spring,
    		createEventDispatcher,
    		RangePips,
    		slider,
    		range,
    		pushy,
    		min,
    		max,
    		step,
    		values,
    		vertical,
    		float,
    		reversed,
    		hoverable,
    		disabled,
    		pips,
    		pipstep,
    		all,
    		first,
    		last,
    		rest,
    		id,
    		prefix,
    		suffix,
    		formatter,
    		handleFormatter,
    		precision,
    		springValues,
    		dispatch,
    		valueLength,
    		focus,
    		handleActivated,
    		handlePressed,
    		keyboardActive,
    		activeHandle,
    		startValue,
    		previousValue,
    		springPositions,
    		fixFloat,
    		index,
    		normalisedClient,
    		targetIsHandle,
    		trimRange,
    		getSliderDimensions,
    		getClosestHandle,
    		handleInteract,
    		moveHandle,
    		rangeStart,
    		rangeEnd,
    		sliderBlurHandle,
    		sliderFocusHandle,
    		sliderKeydown,
    		sliderInteractStart,
    		sliderInteractEnd,
    		bodyInteractStart,
    		bodyInteract,
    		bodyMouseUp,
    		bodyTouchEnd,
    		bodyKeyDown,
    		eStart,
    		eStop,
    		eChange,
    		alignValueToStep,
    		percentOf,
    		clampValue,
    		orientationStart,
    		orientationEnd,
    		$springPositions
    	});

    	$$self.$inject_state = $$props => {
    		if ("slider" in $$props) $$invalidate(1, slider = $$props.slider);
    		if ("range" in $$props) $$invalidate(2, range = $$props.range);
    		if ("pushy" in $$props) $$invalidate(44, pushy = $$props.pushy);
    		if ("min" in $$props) $$invalidate(3, min = $$props.min);
    		if ("max" in $$props) $$invalidate(4, max = $$props.max);
    		if ("step" in $$props) $$invalidate(5, step = $$props.step);
    		if ("values" in $$props) $$invalidate(0, values = $$props.values);
    		if ("vertical" in $$props) $$invalidate(6, vertical = $$props.vertical);
    		if ("float" in $$props) $$invalidate(7, float = $$props.float);
    		if ("reversed" in $$props) $$invalidate(8, reversed = $$props.reversed);
    		if ("hoverable" in $$props) $$invalidate(9, hoverable = $$props.hoverable);
    		if ("disabled" in $$props) $$invalidate(10, disabled = $$props.disabled);
    		if ("pips" in $$props) $$invalidate(11, pips = $$props.pips);
    		if ("pipstep" in $$props) $$invalidate(12, pipstep = $$props.pipstep);
    		if ("all" in $$props) $$invalidate(13, all = $$props.all);
    		if ("first" in $$props) $$invalidate(14, first = $$props.first);
    		if ("last" in $$props) $$invalidate(15, last = $$props.last);
    		if ("rest" in $$props) $$invalidate(16, rest = $$props.rest);
    		if ("id" in $$props) $$invalidate(17, id = $$props.id);
    		if ("prefix" in $$props) $$invalidate(18, prefix = $$props.prefix);
    		if ("suffix" in $$props) $$invalidate(19, suffix = $$props.suffix);
    		if ("formatter" in $$props) $$invalidate(20, formatter = $$props.formatter);
    		if ("handleFormatter" in $$props) $$invalidate(21, handleFormatter = $$props.handleFormatter);
    		if ("precision" in $$props) $$invalidate(45, precision = $$props.precision);
    		if ("springValues" in $$props) $$invalidate(46, springValues = $$props.springValues);
    		if ("valueLength" in $$props) $$invalidate(47, valueLength = $$props.valueLength);
    		if ("focus" in $$props) $$invalidate(24, focus = $$props.focus);
    		if ("handleActivated" in $$props) handleActivated = $$props.handleActivated;
    		if ("handlePressed" in $$props) $$invalidate(25, handlePressed = $$props.handlePressed);
    		if ("keyboardActive" in $$props) keyboardActive = $$props.keyboardActive;
    		if ("activeHandle" in $$props) $$invalidate(26, activeHandle = $$props.activeHandle);
    		if ("startValue" in $$props) startValue = $$props.startValue;
    		if ("previousValue" in $$props) previousValue = $$props.previousValue;
    		if ("springPositions" in $$props) $$subscribe_springPositions($$invalidate(22, springPositions = $$props.springPositions));
    		if ("alignValueToStep" in $$props) $$invalidate(48, alignValueToStep = $$props.alignValueToStep);
    		if ("percentOf" in $$props) $$invalidate(23, percentOf = $$props.percentOf);
    		if ("clampValue" in $$props) $$invalidate(49, clampValue = $$props.clampValue);
    		if ("orientationStart" in $$props) $$invalidate(27, orientationStart = $$props.orientationStart);
    		if ("orientationEnd" in $$props) $$invalidate(28, orientationEnd = $$props.orientationEnd);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
    			/**
     * clamp a value from the range so that it always
     * falls within the min/max values
     * @param {number} val the value to clamp
     * @return {number} the value after it's been clamped
     **/
    			$$invalidate(49, clampValue = function (val) {
    				// return the min/max if outside of that range
    				return val <= min ? min : val >= max ? max : val;
    			});
    		}

    		if ($$self.$$.dirty[0] & /*min, max, step*/ 56 | $$self.$$.dirty[1] & /*clampValue*/ 262144) {
    			/**
     * align the value with the steps so that it
     * always sits on the closest (above/below) step
     * @param {number} val the value to align
     * @return {number} the value after it's been aligned
     **/
    			$$invalidate(48, alignValueToStep = function (val) {
    				// sanity check for performance
    				if (val <= min) {
    					return fixFloat(min);
    				} else if (val >= max) {
    					return fixFloat(max);
    				}

    				// find the middle-point between steps
    				// and see if the value is closer to the
    				// next step, or previous step
    				let remainder = (val - min) % step;

    				let aligned = val - remainder;

    				if (Math.abs(remainder) * 2 >= step) {
    					aligned += remainder > 0 ? step : -step;
    				}

    				// make sure the value is within acceptable limits
    				aligned = clampValue(aligned);

    				// make sure the returned value is set to the precision desired
    				// this is also because javascript often returns weird floats
    				// when dealing with odd numbers and percentages
    				return fixFloat(aligned);
    			});
    		}

    		if ($$self.$$.dirty[0] & /*min, max*/ 24) {
    			/**
     * take in a value, and then calculate that value's percentage
     * of the overall range (min-max);
     * @param {number} val the value we're getting percent for
     * @return {number} the percentage value
     **/
    			$$invalidate(23, percentOf = function (val) {
    				let perc = (val - min) / (max - min) * 100;

    				if (isNaN(perc) || perc <= 0) {
    					return 0;
    				} else if (perc >= 100) {
    					return 100;
    				} else {
    					return fixFloat(perc);
    				}
    			});
    		}

    		if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions*/ 12582937 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/ 229376) {
    			{
    				// check that "values" is an array, or set it as array
    				// to prevent any errors in springs, or range trimming
    				if (!Array.isArray(values)) {
    					$$invalidate(0, values = [(max + min) / 2]);
    					console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
    				}

    				// trim the range so it remains as a min/max (only 2 handles)
    				// and also align the handles to the steps
    				$$invalidate(0, values = trimRange(values.map(v => alignValueToStep(v))));

    				// check if the valueLength (length of values[]) has changed,
    				// because if so we need to re-seed the spring function with the
    				// new values array.
    				if (valueLength !== values.length) {
    					// set the initial spring values when the slider initialises,
    					// or when values array length has changed
    					$$subscribe_springPositions($$invalidate(22, springPositions = spring(values.map(v => percentOf(v)), springValues)));
    				} else {
    					// update the value of the spring function for animated handles
    					// whenever the values has updated
    					springPositions.set(values.map(v => percentOf(v)));
    				}

    				// set the valueLength for the next check
    				$$invalidate(47, valueLength = values.length);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
    			/**
     * the orientation of the handles/pips based on the
     * input values of vertical and reversed
     **/
    			$$invalidate(27, orientationStart = vertical
    			? reversed ? "top" : "bottom"
    			: reversed ? "right" : "left");
    		}

    		if ($$self.$$.dirty[0] & /*vertical, reversed*/ 320) {
    			$$invalidate(28, orientationEnd = vertical
    			? reversed ? "bottom" : "top"
    			: reversed ? "left" : "right");
    		}
    	};

    	return [
    		values,
    		slider,
    		range,
    		min,
    		max,
    		step,
    		vertical,
    		float,
    		reversed,
    		hoverable,
    		disabled,
    		pips,
    		pipstep,
    		all,
    		first,
    		last,
    		rest,
    		id,
    		prefix,
    		suffix,
    		formatter,
    		handleFormatter,
    		springPositions,
    		percentOf,
    		focus,
    		handlePressed,
    		activeHandle,
    		orientationStart,
    		orientationEnd,
    		$springPositions,
    		fixFloat,
    		moveHandle,
    		rangeStart,
    		rangeEnd,
    		sliderBlurHandle,
    		sliderFocusHandle,
    		sliderKeydown,
    		sliderInteractStart,
    		sliderInteractEnd,
    		bodyInteractStart,
    		bodyInteract,
    		bodyMouseUp,
    		bodyTouchEnd,
    		bodyKeyDown,
    		pushy,
    		precision,
    		springValues,
    		valueLength,
    		alignValueToStep,
    		clampValue,
    		div_binding
    	];
    }

    class RangeSlider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$m,
    			create_fragment$m,
    			safe_not_equal,
    			{
    				slider: 1,
    				range: 2,
    				pushy: 44,
    				min: 3,
    				max: 4,
    				step: 5,
    				values: 0,
    				vertical: 6,
    				float: 7,
    				reversed: 8,
    				hoverable: 9,
    				disabled: 10,
    				pips: 11,
    				pipstep: 12,
    				all: 13,
    				first: 14,
    				last: 15,
    				rest: 16,
    				id: 17,
    				prefix: 18,
    				suffix: 19,
    				formatter: 20,
    				handleFormatter: 21,
    				precision: 45,
    				springValues: 46
    			},
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RangeSlider",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get slider() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slider(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get range() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set range(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pushy() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pushy(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get values() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get vertical() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set vertical(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get float() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set float(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reversed() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reversed(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverable() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverable(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pips() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pips(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pipstep() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pipstep(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get all() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set all(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get first() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set first(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get last() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set last(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rest() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rest(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get suffix() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set suffix(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formatter() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formatter(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleFormatter() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set handleFormatter(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precision() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get springValues() {
    		throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set springValues(value) {
    		throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CameraReader.svelte generated by Svelte v3.38.2 */

    const { console: console_1$3 } = globals;
    const file$j = "src/components/parts/CameraReader.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (113:6) {#each videos as video}
    function create_each_block_1$8(ctx) {
    	let option;
    	let t_value = /*video*/ ctx[1].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*video*/ ctx[1].deviceId;
    			option.value = option.__value;
    			add_location(option, file$j, 113, 8, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*videos*/ 8 && t_value !== (t_value = /*video*/ ctx[1].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*videos*/ 8 && option_value_value !== (option_value_value = /*video*/ ctx[1].deviceId)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(113:6) {#each videos as video}",
    		ctx
    	});

    	return block;
    }

    // (119:6) {#each audios as audio}
    function create_each_block$c(ctx) {
    	let option;
    	let t_value = /*audio*/ ctx[2].label + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*audio*/ ctx[2].deviceId;
    			option.value = option.__value;
    			add_location(option, file$j, 119, 8, 4099);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*audios*/ 16 && t_value !== (t_value = /*audio*/ ctx[2].label + "")) set_data_dev(t, t_value);

    			if (dirty & /*audios*/ 16 && option_value_value !== (option_value_value = /*audio*/ ctx[2].deviceId)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(119:6) {#each audios as audio}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div1;
    	let div0;
    	let select0;
    	let option0;
    	let t1;
    	let select1;
    	let option1;
    	let t3;
    	let video_1;
    	let track;
    	let video_1_style_value;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*videos*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	let each_value = /*audios*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "なし";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t1 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "なし";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			video_1 = element("video");
    			track = element("track");
    			option0.__value = null;
    			option0.value = option0.__value;
    			add_location(option0, file$j, 111, 6, 3837);
    			if (/*video*/ ctx[1] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[8].call(select0));
    			add_location(select0, file$j, 110, 4, 3803);
    			option1.__value = null;
    			option1.value = option1.__value;
    			add_location(option1, file$j, 117, 6, 4028);
    			if (/*audio*/ ctx[2] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[9].call(select1));
    			add_location(select1, file$j, 116, 4, 3994);
    			add_location(div0, file$j, 109, 2, 3793);
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$j, 128, 4, 4327);
    			attr_dev(video_1, "width", "1280");
    			attr_dev(video_1, "height", "720");
    			attr_dev(video_1, "style", video_1_style_value = /*isVideoVisible*/ ctx[0] ? "" : "display: none");
    			attr_dev(video_1, "class", "svelte-9cqe1w");
    			add_location(video_1, file$j, 124, 2, 4193);
    			attr_dev(div1, "class", "camera-reader svelte-9cqe1w");
    			add_location(div1, file$j, 108, 0, 3763);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select0, null);
    			}

    			select_option(select0, /*video*/ ctx[1]);
    			append_dev(div0, t1);
    			append_dev(div0, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select1, null);
    			}

    			select_option(select1, /*audio*/ ctx[2]);
    			append_dev(div1, t3);
    			append_dev(div1, video_1);
    			append_dev(video_1, track);
    			/*video_1_binding*/ ctx[10](video_1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[8]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[9])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*videos*/ 8) {
    				each_value_1 = /*videos*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$8(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*video, videos*/ 10) {
    				select_option(select0, /*video*/ ctx[1]);
    			}

    			if (dirty & /*audios*/ 16) {
    				each_value = /*audios*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*audio, audios*/ 20) {
    				select_option(select1, /*audio*/ ctx[2]);
    			}

    			if (dirty & /*isVideoVisible*/ 1 && video_1_style_value !== (video_1_style_value = /*isVideoVisible*/ ctx[0] ? "" : "display: none")) {
    				attr_dev(video_1, "style", video_1_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			/*video_1_binding*/ ctx[10](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const videoWidth$1 = 1280;
    const videoHeight$1 = 720;

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CameraReader", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { isVideoVisible = true } = $$props;
    	let { imageProcessor } = $$props;
    	let videos = [];
    	let audios = [];
    	let video;
    	let audio;
    	let domVideo;
    	let videoStream;

    	function init() {
    		var _a, _b;

    		return __awaiter(this, void 0, void 0, function* () {
    			if (((_a = navigator.mediaDevices) === null || _a === void 0
    			? void 0
    			: _a.getUserMedia) == null) {
    				return;
    			}

    			navigator.mediaDevices.getUserMedia({ audio: true, video: true });
    			const devices = yield getInputDevices();
    			yield new Promise(r => setTimeout(r, 2000));
    			$$invalidate(3, videos = devices.videos);
    			$$invalidate(4, audios = devices.audios);

    			$$invalidate(1, video = (_b = videos.find(i => i.label.includes("USB"))) === null || _b === void 0
    			? void 0
    			: _b.deviceId);
    		});
    	}

    	function getInputDevices() {
    		return __awaiter(this, void 0, void 0, function* () {
    			const devices = yield navigator.mediaDevices.enumerateDevices();

    			return {
    				videos: devices.filter(i => i.kind === "videoinput"),
    				audios: devices.filter(i => i.kind === "audioinput")
    			};
    		});
    	}

    	function onSelectVideoInput({ audio, video }) {
    		return __awaiter(this, void 0, void 0, function* () {
    			const stream = yield getVideoStream({ video, audio });

    			if (stream == null) {
    				return;
    			}

    			videoStream = stream; // show video

    			// domVideo.height = 720
    			$$invalidate(5, domVideo.srcObject = videoStream, domVideo);

    			if (domVideo.paused) {
    				domVideo.play();
    				run();
    			}
    		});
    	}

    	function getVideoStream({ video, audio }) {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (video == null) {
    				return;
    			}

    			const mediaConstraints = {
    				video: {
    					// deviceId: {exact: video},
    					deviceId: video,
    					width: { min: 1280, max: 1280 }, // ideal: 1920,
    					// max: 2560,
    					height: { min: 720, max: 720 }, // ideal: 1080,
    					// max: 1440,
    					
    				}
    			}; // audio: {
    			//   // deviceId: {exact: audio},
    			//   deviceId: audio,

    			// },
    			console.log({ mediaConstraints });

    			return yield navigator.mediaDevices.getUserMedia(mediaConstraints);
    		});
    	}

    	function run() {
    		return __awaiter(this, void 0, void 0, function* () {
    			const capture = new cv__default['default'].VideoCapture(domVideo);
    			let frame = new cv__default['default'].Mat(videoHeight$1, videoWidth$1, cv__default['default'].CV_8UC4);

    			while (true) {
    				yield new Promise(r => requestAnimationFrame(r));
    				yield capture.read(frame);
    				yield imageProcessor(frame); // TODO: 非同期でも？
    			}
    		});
    	}

    	const writable_props = ["isVideoVisible", "imageProcessor"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<CameraReader> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		video = select_value(this);
    		$$invalidate(1, video);
    		$$invalidate(3, videos);
    	}

    	function select1_change_handler() {
    		audio = select_value(this);
    		$$invalidate(2, audio);
    		$$invalidate(4, audios);
    	}

    	function video_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domVideo = $$value;
    			$$invalidate(5, domVideo);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("isVideoVisible" in $$props) $$invalidate(0, isVideoVisible = $$props.isVideoVisible);
    		if ("imageProcessor" in $$props) $$invalidate(6, imageProcessor = $$props.imageProcessor);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		cv: cv__default['default'],
    		dayjs: dayjs_min,
    		videoWidth: videoWidth$1,
    		videoHeight: videoHeight$1,
    		isVideoVisible,
    		imageProcessor,
    		videos,
    		audios,
    		video,
    		audio,
    		domVideo,
    		videoStream,
    		init,
    		getInputDevices,
    		onSelectVideoInput,
    		getVideoStream,
    		run
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("isVideoVisible" in $$props) $$invalidate(0, isVideoVisible = $$props.isVideoVisible);
    		if ("imageProcessor" in $$props) $$invalidate(6, imageProcessor = $$props.imageProcessor);
    		if ("videos" in $$props) $$invalidate(3, videos = $$props.videos);
    		if ("audios" in $$props) $$invalidate(4, audios = $$props.audios);
    		if ("video" in $$props) $$invalidate(1, video = $$props.video);
    		if ("audio" in $$props) $$invalidate(2, audio = $$props.audio);
    		if ("domVideo" in $$props) $$invalidate(5, domVideo = $$props.domVideo);
    		if ("videoStream" in $$props) videoStream = $$props.videoStream;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*audio, video*/ 6) {
    			{
    				onSelectVideoInput({ audio, video });
    			}
    		}
    	};

    	return [
    		isVideoVisible,
    		video,
    		audio,
    		videos,
    		audios,
    		domVideo,
    		imageProcessor,
    		init,
    		select0_change_handler,
    		select1_change_handler,
    		video_1_binding
    	];
    }

    class CameraReader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			isVideoVisible: 0,
    			imageProcessor: 6,
    			init: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CameraReader",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*imageProcessor*/ ctx[6] === undefined && !("imageProcessor" in props)) {
    			console_1$3.warn("<CameraReader> was created without expected prop 'imageProcessor'");
    		}
    	}

    	get isVideoVisible() {
    		throw new Error("<CameraReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVideoVisible(value) {
    		throw new Error("<CameraReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageProcessor() {
    		throw new Error("<CameraReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageProcessor(value) {
    		throw new Error("<CameraReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get init() {
    		return this.$$.ctx[7];
    	}

    	set init(value) {
    		throw new Error("<CameraReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/simple-svelte-autocomplete/src/SimpleAutocomplete.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$4, console: console_1$2 } = globals;
    const file$i = "node_modules/simple-svelte-autocomplete/src/SimpleAutocomplete.svelte";

    const get_no_results_slot_changes = dirty => ({
    	noResultsText: dirty[0] & /*noResultsText*/ 2
    });

    const get_no_results_slot_context = ctx => ({ noResultsText: /*noResultsText*/ ctx[1] });

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[79] = list[i];
    	child_ctx[81] = i;
    	return child_ctx;
    }

    const get_item_slot_changes = dirty => ({
    	item: dirty[0] & /*filteredListItems*/ 131072,
    	label: dirty[0] & /*filteredListItems*/ 131072
    });

    const get_item_slot_context = ctx => ({
    	item: /*listItem*/ ctx[79].item,
    	label: /*listItem*/ ctx[79].highlighted
    	? /*listItem*/ ctx[79].highlighted.label
    	: /*listItem*/ ctx[79].label
    });

    // (775:2) {#if showClear}
    function create_if_block_6$1(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "✖";
    			attr_dev(span, "class", "autocomplete-clear-button svelte-77usy");
    			add_location(span, file$i, 775, 4, 17914);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*clear*/ ctx[27], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(775:2) {#if showClear}",
    		ctx
    	});

    	return block;
    }

    // (812:28) 
    function create_if_block_5$1(ctx) {
    	let div;
    	let current;
    	const no_results_slot_template = /*#slots*/ ctx[50]["no-results"];
    	const no_results_slot = create_slot(no_results_slot_template, ctx, /*$$scope*/ ctx[49], get_no_results_slot_context);
    	const no_results_slot_or_fallback = no_results_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (no_results_slot_or_fallback) no_results_slot_or_fallback.c();
    			attr_dev(div, "class", "autocomplete-list-item-no-results svelte-77usy");
    			add_location(div, file$i, 812, 6, 19343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (no_results_slot_or_fallback) {
    				no_results_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (no_results_slot) {
    				if (no_results_slot.p && (!current || dirty[0] & /*noResultsText*/ 2 | dirty[1] & /*$$scope*/ 262144)) {
    					update_slot(no_results_slot, no_results_slot_template, ctx, /*$$scope*/ ctx[49], dirty, get_no_results_slot_changes, get_no_results_slot_context);
    				}
    			} else {
    				if (no_results_slot_or_fallback && no_results_slot_or_fallback.p && dirty[0] & /*noResultsText*/ 2) {
    					no_results_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(no_results_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(no_results_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (no_results_slot_or_fallback) no_results_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(812:28) ",
    		ctx
    	});

    	return block;
    }

    // (782:4) {#if filteredListItems && filteredListItems.length > 0}
    function create_if_block$7(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;
    	let each_value = /*filteredListItems*/ ctx[17];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block = /*maxItemsToShowInList*/ ctx[0] > 0 && /*filteredListItems*/ ctx[17].length > /*maxItemsToShowInList*/ ctx[0] && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*highlightIndex, onListItemClick, filteredListItems, maxItemsToShowInList*/ 1212417 | dirty[1] & /*$$scope*/ 262144) {
    				each_value = /*filteredListItems*/ ctx[17];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*maxItemsToShowInList*/ ctx[0] > 0 && /*filteredListItems*/ ctx[17].length > /*maxItemsToShowInList*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(782:4) {#if filteredListItems && filteredListItems.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (814:48) {noResultsText}
    function fallback_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*noResultsText*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*noResultsText*/ 2) set_data_dev(t, /*noResultsText*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(814:48) {noResultsText}",
    		ctx
    	});

    	return block;
    }

    // (784:8) {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}
    function create_if_block_2$6(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*listItem*/ ctx[79] && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*listItem*/ ctx[79]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*filteredListItems*/ 131072) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(784:8) {#if listItem && (maxItemsToShowInList <= 0 || i < maxItemsToShowInList)}",
    		ctx
    	});

    	return block;
    }

    // (785:10) {#if listItem}
    function create_if_block_3$2(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const item_slot_template = /*#slots*/ ctx[50].item;
    	const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[49], get_item_slot_context);
    	const item_slot_or_fallback = item_slot || fallback_block(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[53](/*listItem*/ ctx[79]);
    	}

    	function pointerenter_handler() {
    		return /*pointerenter_handler*/ ctx[54](/*i*/ ctx[81]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (item_slot_or_fallback) item_slot_or_fallback.c();

    			attr_dev(div, "class", div_class_value = "autocomplete-list-item " + (/*i*/ ctx[81] === /*highlightIndex*/ ctx[15]
    			? "selected"
    			: "") + " svelte-77usy");

    			add_location(div, file$i, 785, 12, 18369);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (item_slot_or_fallback) {
    				item_slot_or_fallback.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", click_handler, false, false, false),
    					listen_dev(div, "pointerenter", pointerenter_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (item_slot) {
    				if (item_slot.p && (!current || dirty[0] & /*filteredListItems*/ 131072 | dirty[1] & /*$$scope*/ 262144)) {
    					update_slot(item_slot, item_slot_template, ctx, /*$$scope*/ ctx[49], dirty, get_item_slot_changes, get_item_slot_context);
    				}
    			} else {
    				if (item_slot_or_fallback && item_slot_or_fallback.p && dirty[0] & /*filteredListItems*/ 131072) {
    					item_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty[0] & /*highlightIndex*/ 32768 && div_class_value !== (div_class_value = "autocomplete-list-item " + (/*i*/ ctx[81] === /*highlightIndex*/ ctx[15]
    			? "selected"
    			: "") + " svelte-77usy")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(item_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(item_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(785:10) {#if listItem}",
    		ctx
    	});

    	return block;
    }

    // (798:16) {:else}
    function create_else_block$7(ctx) {
    	let html_tag;
    	let raw_value = /*listItem*/ ctx[79].label + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredListItems*/ 131072 && raw_value !== (raw_value = /*listItem*/ ctx[79].label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(798:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (796:16) {#if listItem.highlighted}
    function create_if_block_4$2(ctx) {
    	let html_tag;
    	let raw_value = /*listItem*/ ctx[79].highlighted.label + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredListItems*/ 131072 && raw_value !== (raw_value = /*listItem*/ ctx[79].highlighted.label + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(796:16) {#if listItem.highlighted}",
    		ctx
    	});

    	return block;
    }

    // (795:91)                  
    function fallback_block(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*listItem*/ ctx[79].highlighted) return create_if_block_4$2;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(795:91)                  ",
    		ctx
    	});

    	return block;
    }

    // (783:6) {#each filteredListItems as listItem, i}
    function create_each_block$b(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*listItem*/ ctx[79] && (/*maxItemsToShowInList*/ ctx[0] <= 0 || /*i*/ ctx[81] < /*maxItemsToShowInList*/ ctx[0]) && create_if_block_2$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*listItem*/ ctx[79] && (/*maxItemsToShowInList*/ ctx[0] <= 0 || /*i*/ ctx[81] < /*maxItemsToShowInList*/ ctx[0])) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*filteredListItems, maxItemsToShowInList*/ 131073) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(783:6) {#each filteredListItems as listItem, i}",
    		ctx
    	});

    	return block;
    }

    // (807:6) {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}
    function create_if_block_1$6(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*filteredListItems*/ ctx[17].length - /*maxItemsToShowInList*/ ctx[0] + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("...");
    			t1 = text(t1_value);
    			t2 = text(" results not shown");
    			attr_dev(div, "class", "autocomplete-list-item-no-results svelte-77usy");
    			add_location(div, file$i, 807, 8, 19152);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filteredListItems, maxItemsToShowInList*/ 131073 && t1_value !== (t1_value = /*filteredListItems*/ ctx[17].length - /*maxItemsToShowInList*/ ctx[0] + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(807:6) {#if maxItemsToShowInList > 0 && filteredListItems.length > maxItemsToShowInList}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div1;
    	let input_1;
    	let input_1_class_value;
    	let input_1_id_value;
    	let input_1_autocomplete_value;
    	let t0;
    	let t1;
    	let div0;
    	let current_block_type_index;
    	let if_block1;
    	let div0_class_value;
    	let div1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*showClear*/ ctx[11] && create_if_block_6$1(ctx);
    	const if_block_creators = [create_if_block$7, create_if_block_5$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*filteredListItems*/ ctx[17] && /*filteredListItems*/ ctx[17].length > 0) return 0;
    		if (/*noResultsText*/ ctx[1]) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			input_1 = element("input");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(input_1, "type", "text");

    			attr_dev(input_1, "class", input_1_class_value = "" + ((/*inputClassName*/ ctx[4]
    			? /*inputClassName*/ ctx[4]
    			: "") + " input autocomplete-input" + " svelte-77usy"));

    			attr_dev(input_1, "id", input_1_id_value = /*inputId*/ ctx[5] ? /*inputId*/ ctx[5] : "");
    			attr_dev(input_1, "autocomplete", input_1_autocomplete_value = /*html5autocomplete*/ ctx[8] ? "on" : "off");
    			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[2]);
    			attr_dev(input_1, "name", /*name*/ ctx[6]);
    			input_1.disabled = /*disabled*/ ctx[12];
    			attr_dev(input_1, "title", /*title*/ ctx[7]);
    			add_location(input_1, file$i, 758, 2, 17476);

    			attr_dev(div0, "class", div0_class_value = "" + ((/*dropdownClassName*/ ctx[9]
    			? /*dropdownClassName*/ ctx[9]
    			: "") + " autocomplete-list " + (/*showList*/ ctx[18] ? "" : "hidden") + "\n    is-fullwidth" + " svelte-77usy"));

    			add_location(div0, file$i, 777, 2, 17997);
    			attr_dev(div1, "class", div1_class_value = "" + ((/*className*/ ctx[3] ? /*className*/ ctx[3] : "") + "\n  " + (/*hideArrow*/ ctx[10] ? "hide-arrow is-multiple" : "") + "\n  " + (/*showClear*/ ctx[11] ? "show-clear" : "") + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[19] + " svelte-77usy"));
    			add_location(div1, file$i, 754, 0, 17305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, input_1);
    			/*input_1_binding*/ ctx[51](input_1);
    			set_input_value(input_1, /*text*/ ctx[16]);
    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div0, null);
    			}

    			/*div0_binding*/ ctx[55](div0);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*onDocumentClick*/ ctx[21], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[52]),
    					listen_dev(input_1, "input", /*onInput*/ ctx[24], false, false, false),
    					listen_dev(input_1, "focus", /*onFocus*/ ctx[26], false, false, false),
    					listen_dev(input_1, "keydown", /*onKeyDown*/ ctx[22], false, false, false),
    					listen_dev(input_1, "click", /*onInputClick*/ ctx[25], false, false, false),
    					listen_dev(input_1, "keypress", /*onKeyPress*/ ctx[23], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*inputClassName*/ 16 && input_1_class_value !== (input_1_class_value = "" + ((/*inputClassName*/ ctx[4]
    			? /*inputClassName*/ ctx[4]
    			: "") + " input autocomplete-input" + " svelte-77usy"))) {
    				attr_dev(input_1, "class", input_1_class_value);
    			}

    			if (!current || dirty[0] & /*inputId*/ 32 && input_1_id_value !== (input_1_id_value = /*inputId*/ ctx[5] ? /*inputId*/ ctx[5] : "")) {
    				attr_dev(input_1, "id", input_1_id_value);
    			}

    			if (!current || dirty[0] & /*html5autocomplete*/ 256 && input_1_autocomplete_value !== (input_1_autocomplete_value = /*html5autocomplete*/ ctx[8] ? "on" : "off")) {
    				attr_dev(input_1, "autocomplete", input_1_autocomplete_value);
    			}

    			if (!current || dirty[0] & /*placeholder*/ 4) {
    				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[2]);
    			}

    			if (!current || dirty[0] & /*name*/ 64) {
    				attr_dev(input_1, "name", /*name*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 4096) {
    				prop_dev(input_1, "disabled", /*disabled*/ ctx[12]);
    			}

    			if (!current || dirty[0] & /*title*/ 128) {
    				attr_dev(input_1, "title", /*title*/ ctx[7]);
    			}

    			if (dirty[0] & /*text*/ 65536 && input_1.value !== /*text*/ ctx[16]) {
    				set_input_value(input_1, /*text*/ ctx[16]);
    			}

    			if (/*showClear*/ ctx[11]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					} else {
    						if_block1.p(ctx, dirty);
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				} else {
    					if_block1 = null;
    				}
    			}

    			if (!current || dirty[0] & /*dropdownClassName, showList*/ 262656 && div0_class_value !== (div0_class_value = "" + ((/*dropdownClassName*/ ctx[9]
    			? /*dropdownClassName*/ ctx[9]
    			: "") + " autocomplete-list " + (/*showList*/ ctx[18] ? "" : "hidden") + "\n    is-fullwidth" + " svelte-77usy"))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty[0] & /*className, hideArrow, showClear*/ 3080 && div1_class_value !== (div1_class_value = "" + ((/*className*/ ctx[3] ? /*className*/ ctx[3] : "") + "\n  " + (/*hideArrow*/ ctx[10] ? "hide-arrow is-multiple" : "") + "\n  " + (/*showClear*/ ctx[11] ? "show-clear" : "") + " autocomplete select is-fullwidth " + /*uniqueId*/ ctx[19] + " svelte-77usy"))) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*input_1_binding*/ ctx[51](null);
    			if (if_block0) if_block0.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			/*div0_binding*/ ctx[55](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function safeStringFunction(theFunction, argument) {
    	if (typeof theFunction !== "function") {
    		console.error("Not a function: " + theFunction + ", argument: " + argument);
    	}

    	let originalResult;

    	try {
    		originalResult = theFunction(argument);
    	} catch(error) {
    		console.warn("Error executing Autocomplete function on value: " + argument + " function: " + theFunction);
    	}

    	let result = originalResult;

    	if (result === undefined || result === null) {
    		result = "";
    	}

    	if (typeof result !== "string") {
    		result = result.toString();
    	}

    	return result;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let showList;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SimpleAutocomplete", slots, ['item','no-results']);
    	let { items = [] } = $$props;
    	let { searchFunction = false } = $$props;
    	let { labelFieldName = undefined } = $$props;
    	let { keywordsFieldName = labelFieldName } = $$props;
    	let { valueFieldName = undefined } = $$props;

    	let { labelFunction = function (item) {
    		if (item === undefined || item === null) {
    			return "";
    		}

    		return labelFieldName ? item[labelFieldName] : item;
    	} } = $$props;

    	let { keywordsFunction = function (item) {
    		if (item === undefined || item === null) {
    			return "";
    		}

    		return keywordsFieldName
    		? item[keywordsFieldName]
    		: labelFunction(item);
    	} } = $$props;

    	let { valueFunction = function (item) {
    		if (item === undefined || item === null) {
    			return item;
    		}

    		return valueFieldName ? item[valueFieldName] : item;
    	} } = $$props;

    	let { keywordsCleanFunction = function (keywords) {
    		return keywords;
    	} } = $$props;

    	let { textCleanFunction = function (userEnteredText) {
    		return userEnteredText;
    	} } = $$props;

    	let { beforeChange = function (oldSelectedItem, newSelectedItem) {
    		return true;
    	} } = $$props;

    	let { onChange = function (newSelectedItem) {
    		
    	} } = $$props;

    	let { selectFirstIfEmpty = false } = $$props;
    	let { minCharactersToSearch = 1 } = $$props;
    	let { maxItemsToShowInList = 0 } = $$props;
    	let { delay = 0 } = $$props;
    	let { localFiltering = true } = $$props;
    	let { noResultsText = "No results found" } = $$props;
    	let { placeholder = undefined } = $$props;
    	let { className = undefined } = $$props;
    	let { inputClassName = undefined } = $$props;
    	let { inputId = undefined } = $$props;
    	let { name = undefined } = $$props;
    	let { title = undefined } = $$props;
    	let { html5autocomplete = undefined } = $$props;
    	let { dropdownClassName = undefined } = $$props;
    	let { hideArrow = false } = $$props;
    	let { showClear = false } = $$props;
    	let { disabled = false } = $$props;
    	let { debug = false } = $$props;
    	let { selectedItem = undefined } = $$props;
    	let { value = undefined } = $$props;

    	// --- Internal State ----
    	const uniqueId = "sautocomplete-" + Math.floor(Math.random() * 1000);

    	// HTML elements
    	let input;

    	let list;

    	// UI state
    	let opened = false;

    	let highlightIndex = -1;
    	let text;
    	let filteredTextLength = 0;

    	// view model
    	let filteredListItems;

    	let listItems = [];

    	// other state
    	let inputDelayTimeout;

    	// -- Reactivity --
    	function onSelectedItemChanged() {
    		$$invalidate(30, value = valueFunction(selectedItem));
    		$$invalidate(16, text = safeLabelFunction(selectedItem));
    		onChange(selectedItem);
    	}

    	function safeLabelFunction(item) {
    		// console.log("labelFunction: " + labelFunction);
    		// console.log("safeLabelFunction, item: " + item);
    		return safeStringFunction(labelFunction, item);
    	}

    	function safeKeywordsFunction(item) {
    		// console.log("safeKeywordsFunction");
    		const keywords = safeStringFunction(keywordsFunction, item);

    		let result = safeStringFunction(keywordsCleanFunction, keywords);
    		result = result.toLowerCase().trim();

    		if (debug) {
    			console.log("Extracted keywords: '" + result + "' from item: " + JSON.stringify(item));
    		}

    		return result;
    	}

    	function prepareListItems() {
    		let tStart;

    		if (debug) {
    			tStart = performance.now();
    			console.log("prepare items to search");
    			console.log("items: " + JSON.stringify(items));
    		}

    		if (!Array.isArray(items)) {
    			console.warn("Autocomplete items / search function did not return array but", items);
    			$$invalidate(28, items = []);
    		}

    		const length = items ? items.length : 0;
    		listItems = new Array(length);

    		if (length > 0) {
    			items.forEach((item, i) => {
    				const listItem = getListItem(item);

    				if (listItem == undefined) {
    					console.log("Undefined item for: ", item);
    				}

    				listItems[i] = listItem;
    			});
    		}

    		if (debug) {
    			const tEnd = performance.now();
    			console.log(listItems.length + " items to search prepared in " + (tEnd - tStart) + " milliseconds");
    		}
    	}

    	function getListItem(item) {
    		return {
    			// keywords representation of the item
    			keywords: safeKeywordsFunction(item),
    			// item label
    			label: safeLabelFunction(item),
    			// store reference to the origial item
    			item
    		};
    	}

    	function prepareUserEnteredText(userEnteredText) {
    		if (userEnteredText === undefined || userEnteredText === null) {
    			return "";
    		}

    		const textFiltered = userEnteredText.replace(/[&/\\#,+()$~%.'":*?<>{}]/g, " ").trim();
    		$$invalidate(48, filteredTextLength = textFiltered.length);

    		if (minCharactersToSearch > 1) {
    			if (filteredTextLength < minCharactersToSearch) {
    				return "";
    			}
    		}

    		const cleanUserEnteredText = textCleanFunction(textFiltered);
    		const textFilteredLowerCase = cleanUserEnteredText.toLowerCase().trim();

    		if (debug) {
    			console.log("Change user entered text '" + userEnteredText + "' into '" + textFilteredLowerCase + "'");
    		}

    		return textFilteredLowerCase;
    	}

    	async function search() {
    		let tStart;

    		if (debug) {
    			tStart = performance.now();
    			console.log("Searching user entered text: '" + text + "'");
    		}

    		const textFiltered = prepareUserEnteredText(text);

    		if (textFiltered === "") {
    			$$invalidate(17, filteredListItems = listItems);
    			closeIfMinCharsToSearchReached();

    			if (debug) {
    				console.log("User entered text is empty set the list of items to all items");
    			}

    			return;
    		}

    		// external search which provides items
    		if (searchFunction) {
    			$$invalidate(28, items = await searchFunction(textFiltered));
    			prepareListItems();
    		}

    		// local search
    		let tempfilteredListItems;

    		if (localFiltering) {
    			const searchWords = textFiltered.split(" ");

    			tempfilteredListItems = listItems.filter(listItem => {
    				if (!listItem) {
    					return false;
    				}

    				const itemKeywords = listItem.keywords;
    				let matches = 0;

    				searchWords.forEach(searchWord => {
    					if (itemKeywords.includes(searchWord)) {
    						matches++;
    					}
    				});

    				return matches >= searchWords.length;
    			});
    		} else {
    			tempfilteredListItems = listItems;
    		}

    		const hlfilter = highlightFilter(textFiltered, ["label"]);
    		const filteredListItemsHighlighted = tempfilteredListItems.map(hlfilter);
    		$$invalidate(17, filteredListItems = filteredListItemsHighlighted);
    		closeIfMinCharsToSearchReached();

    		if (debug) {
    			const tEnd = performance.now();
    			console.log("Search took " + (tEnd - tStart) + " milliseconds, found " + filteredListItems.length + " items");
    		}
    	}

    	// $: text, search();
    	function selectListItem(listItem) {
    		if (debug) {
    			console.log("selectListItem");
    		}

    		if ("undefined" === typeof listItem) {
    			if (debug) {
    				console.log(`listItem ${i} is undefined. Can not select.`);
    			}

    			return false;
    		}

    		const newSelectedItem = listItem.item;

    		if (beforeChange(selectedItem, newSelectedItem)) {
    			$$invalidate(29, selectedItem = newSelectedItem);
    		}

    		return true;
    	}

    	function selectItem() {
    		if (debug) {
    			console.log("selectItem");
    		}

    		const listItem = filteredListItems[highlightIndex];

    		if (selectListItem(listItem)) {
    			close();
    		}
    	}

    	function up() {
    		if (debug) {
    			console.log("up");
    		}

    		open();
    		if (highlightIndex > 0) $$invalidate(15, highlightIndex--, highlightIndex);
    		highlight();
    	}

    	function down() {
    		if (debug) {
    			console.log("down");
    		}

    		open();
    		if (highlightIndex < filteredListItems.length - 1) $$invalidate(15, highlightIndex++, highlightIndex);
    		highlight();
    	}

    	function highlight() {
    		if (debug) {
    			console.log("highlight");
    		}

    		const query = ".selected";

    		if (debug) {
    			console.log("Seaching DOM element: " + query + " in " + list);
    		}

    		const el = list && list.querySelector(query);

    		if (el) {
    			if (typeof el.scrollIntoViewIfNeeded === "function") {
    				if (debug) {
    					console.log("Scrolling selected item into view");
    				}

    				el.scrollIntoViewIfNeeded();
    			} else {
    				if (debug) {
    					console.warn("Could not scroll selected item into view, scrollIntoViewIfNeeded not supported");
    				}
    			}
    		} else {
    			if (debug) {
    				console.warn("Selected item not found to scroll into view");
    			}
    		}
    	}

    	function onListItemClick(listItem) {
    		if (debug) {
    			console.log("onListItemClick");
    		}

    		if (selectListItem(listItem)) {
    			close();
    		}
    	}

    	function onDocumentClick(e) {
    		if (debug) {
    			console.log("onDocumentClick: " + JSON.stringify(e.target));
    		}

    		if (e.target.closest("." + uniqueId)) {
    			if (debug) {
    				console.log("onDocumentClick inside");
    			}

    			// resetListToAllItemsAndOpen();
    			highlight();
    		} else {
    			if (debug) {
    				console.log("onDocumentClick outside");
    			}

    			close();
    		}
    	}

    	function onKeyDown(e) {
    		if (debug) {
    			console.log("onKeyDown");
    		}

    		let key = e.key;
    		if (key === "Tab" && e.shiftKey) key = "ShiftTab";

    		const fnmap = {
    			Tab: opened ? down.bind(this) : null,
    			ShiftTab: opened ? up.bind(this) : null,
    			ArrowDown: down.bind(this),
    			ArrowUp: up.bind(this),
    			Escape: onEsc.bind(this)
    		};

    		const fn = fnmap[key];

    		if (typeof fn === "function") {
    			e.preventDefault();
    			fn(e);
    		}
    	}

    	function onKeyPress(e) {
    		if (debug) {
    			console.log("onKeyPress");
    		}

    		if (e.key === "Enter") {
    			e.preventDefault();
    			selectItem();
    		}
    	}

    	function onInput(e) {
    		if (debug) {
    			console.log("onInput");
    		}

    		$$invalidate(16, text = e.target.value);

    		if (inputDelayTimeout) {
    			clearTimeout(inputDelayTimeout);
    		}

    		if (delay) {
    			inputDelayTimeout = setTimeout(processInput, delay);
    		} else {
    			processInput();
    		}
    	}

    	function processInput() {
    		search();
    		$$invalidate(15, highlightIndex = 0);
    		open();
    	}

    	function onInputClick() {
    		if (debug) {
    			console.log("onInputClick");
    		}

    		resetListToAllItemsAndOpen();
    	}

    	function onEsc(e) {
    		if (debug) {
    			console.log("onEsc");
    		}

    		//if (text) return clear();
    		e.stopPropagation();

    		if (opened) {
    			input.focus();
    			close();
    		}
    	}

    	function onFocus() {
    		if (debug) {
    			console.log("onFocus");
    		}

    		resetListToAllItemsAndOpen();
    	}

    	function resetListToAllItemsAndOpen() {
    		if (debug) {
    			console.log("resetListToAllItemsAndOpen");
    		}

    		$$invalidate(17, filteredListItems = listItems);
    		open();

    		// find selected item
    		if (selectedItem) {
    			if (debug) {
    				console.log("Searching currently selected item: " + JSON.stringify(selectedItem));
    			}

    			for (let i = 0; i < listItems.length; i++) {
    				const listItem = listItems[i];

    				if ("undefined" === typeof listItem) {
    					if (debug) {
    						console.log(`listItem ${i} is undefined. Skipping.`);
    					}

    					continue;
    				}

    				if (debug) {
    					console.log("Item " + i + ": " + JSON.stringify(listItem));
    				}

    				if (selectedItem == listItem.item) {
    					$$invalidate(15, highlightIndex = i);

    					if (debug) {
    						console.log("Found selected item: " + i + ": " + JSON.stringify(listItem));
    					}

    					highlight();
    					break;
    				}
    			}
    		}
    	}

    	function open() {
    		if (debug) {
    			console.log("open");
    		}

    		// check if the search text has more than the min chars required
    		if (isMinCharsToSearchReached()) {
    			return;
    		}

    		$$invalidate(47, opened = true);
    	}

    	function close() {
    		if (debug) {
    			console.log("close");
    		}

    		$$invalidate(47, opened = false);

    		if (!text && selectFirstIfEmpty) {
    			highlightFilter = 0;
    			selectItem();
    		}
    	}

    	function isMinCharsToSearchReached() {
    		return minCharactersToSearch > 1 && filteredTextLength < minCharactersToSearch;
    	}

    	function closeIfMinCharsToSearchReached() {
    		if (isMinCharsToSearchReached()) {
    			close();
    		}
    	}

    	function clear() {
    		if (debug) {
    			console.log("clear");
    		}

    		$$invalidate(16, text = "");
    		$$invalidate(29, selectedItem = undefined);

    		setTimeout(() => {
    			input.focus();
    			close();
    		});
    	}

    	function onBlur() {
    		if (debug) {
    			console.log("onBlur");
    		}

    		close();
    	}

    	// 'item number one'.replace(/(it)(.*)(nu)(.*)(one)/ig, '<b>$1</b>$2 <b>$3</b>$4 <b>$5</b>')
    	function highlightFilter(q, fields) {
    		const qs = "(" + q.trim().replace(/\s/g, ")(.*)(") + ")";
    		const reg = new RegExp(qs, "ig");
    		let n = 1;
    		const len = qs.split(")(").length + 1;
    		let repl = "";
    		for (; n < len; n++) repl += n % 2 ? `<b>$${n}</b>` : `$${n}`;

    		return i => {
    			const newI = Object.assign({ highlighted: {} }, i);

    			if (fields) {
    				fields.forEach(f => {
    					if (!newI[f]) return;
    					newI.highlighted[f] = newI[f].replace(reg, repl);
    				});
    			}

    			return newI;
    		};
    	}

    	const writable_props = [
    		"items",
    		"searchFunction",
    		"labelFieldName",
    		"keywordsFieldName",
    		"valueFieldName",
    		"labelFunction",
    		"keywordsFunction",
    		"valueFunction",
    		"keywordsCleanFunction",
    		"textCleanFunction",
    		"beforeChange",
    		"onChange",
    		"selectFirstIfEmpty",
    		"minCharactersToSearch",
    		"maxItemsToShowInList",
    		"delay",
    		"localFiltering",
    		"noResultsText",
    		"placeholder",
    		"className",
    		"inputClassName",
    		"inputId",
    		"name",
    		"title",
    		"html5autocomplete",
    		"dropdownClassName",
    		"hideArrow",
    		"showClear",
    		"disabled",
    		"debug",
    		"selectedItem",
    		"value"
    	];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<SimpleAutocomplete> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(13, input);
    		});
    	}

    	function input_1_input_handler() {
    		text = this.value;
    		$$invalidate(16, text);
    	}

    	const click_handler = listItem => onListItemClick(listItem);

    	const pointerenter_handler = i => {
    		$$invalidate(15, highlightIndex = i);
    	};

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			list = $$value;
    			$$invalidate(14, list);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(28, items = $$props.items);
    		if ("searchFunction" in $$props) $$invalidate(31, searchFunction = $$props.searchFunction);
    		if ("labelFieldName" in $$props) $$invalidate(32, labelFieldName = $$props.labelFieldName);
    		if ("keywordsFieldName" in $$props) $$invalidate(33, keywordsFieldName = $$props.keywordsFieldName);
    		if ("valueFieldName" in $$props) $$invalidate(34, valueFieldName = $$props.valueFieldName);
    		if ("labelFunction" in $$props) $$invalidate(35, labelFunction = $$props.labelFunction);
    		if ("keywordsFunction" in $$props) $$invalidate(36, keywordsFunction = $$props.keywordsFunction);
    		if ("valueFunction" in $$props) $$invalidate(37, valueFunction = $$props.valueFunction);
    		if ("keywordsCleanFunction" in $$props) $$invalidate(38, keywordsCleanFunction = $$props.keywordsCleanFunction);
    		if ("textCleanFunction" in $$props) $$invalidate(39, textCleanFunction = $$props.textCleanFunction);
    		if ("beforeChange" in $$props) $$invalidate(40, beforeChange = $$props.beforeChange);
    		if ("onChange" in $$props) $$invalidate(41, onChange = $$props.onChange);
    		if ("selectFirstIfEmpty" in $$props) $$invalidate(42, selectFirstIfEmpty = $$props.selectFirstIfEmpty);
    		if ("minCharactersToSearch" in $$props) $$invalidate(43, minCharactersToSearch = $$props.minCharactersToSearch);
    		if ("maxItemsToShowInList" in $$props) $$invalidate(0, maxItemsToShowInList = $$props.maxItemsToShowInList);
    		if ("delay" in $$props) $$invalidate(44, delay = $$props.delay);
    		if ("localFiltering" in $$props) $$invalidate(45, localFiltering = $$props.localFiltering);
    		if ("noResultsText" in $$props) $$invalidate(1, noResultsText = $$props.noResultsText);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("className" in $$props) $$invalidate(3, className = $$props.className);
    		if ("inputClassName" in $$props) $$invalidate(4, inputClassName = $$props.inputClassName);
    		if ("inputId" in $$props) $$invalidate(5, inputId = $$props.inputId);
    		if ("name" in $$props) $$invalidate(6, name = $$props.name);
    		if ("title" in $$props) $$invalidate(7, title = $$props.title);
    		if ("html5autocomplete" in $$props) $$invalidate(8, html5autocomplete = $$props.html5autocomplete);
    		if ("dropdownClassName" in $$props) $$invalidate(9, dropdownClassName = $$props.dropdownClassName);
    		if ("hideArrow" in $$props) $$invalidate(10, hideArrow = $$props.hideArrow);
    		if ("showClear" in $$props) $$invalidate(11, showClear = $$props.showClear);
    		if ("disabled" in $$props) $$invalidate(12, disabled = $$props.disabled);
    		if ("debug" in $$props) $$invalidate(46, debug = $$props.debug);
    		if ("selectedItem" in $$props) $$invalidate(29, selectedItem = $$props.selectedItem);
    		if ("value" in $$props) $$invalidate(30, value = $$props.value);
    		if ("$$scope" in $$props) $$invalidate(49, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		items,
    		searchFunction,
    		labelFieldName,
    		keywordsFieldName,
    		valueFieldName,
    		labelFunction,
    		keywordsFunction,
    		valueFunction,
    		keywordsCleanFunction,
    		textCleanFunction,
    		beforeChange,
    		onChange,
    		selectFirstIfEmpty,
    		minCharactersToSearch,
    		maxItemsToShowInList,
    		delay,
    		localFiltering,
    		noResultsText,
    		placeholder,
    		className,
    		inputClassName,
    		inputId,
    		name,
    		title,
    		html5autocomplete,
    		dropdownClassName,
    		hideArrow,
    		showClear,
    		disabled,
    		debug,
    		selectedItem,
    		value,
    		uniqueId,
    		input,
    		list,
    		opened,
    		highlightIndex,
    		text,
    		filteredTextLength,
    		filteredListItems,
    		listItems,
    		inputDelayTimeout,
    		onSelectedItemChanged,
    		safeStringFunction,
    		safeLabelFunction,
    		safeKeywordsFunction,
    		prepareListItems,
    		getListItem,
    		prepareUserEnteredText,
    		search,
    		selectListItem,
    		selectItem,
    		up,
    		down,
    		highlight,
    		onListItemClick,
    		onDocumentClick,
    		onKeyDown,
    		onKeyPress,
    		onInput,
    		processInput,
    		onInputClick,
    		onEsc,
    		onFocus,
    		resetListToAllItemsAndOpen,
    		open,
    		close,
    		isMinCharsToSearchReached,
    		closeIfMinCharsToSearchReached,
    		clear,
    		onBlur,
    		highlightFilter,
    		showList
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(28, items = $$props.items);
    		if ("searchFunction" in $$props) $$invalidate(31, searchFunction = $$props.searchFunction);
    		if ("labelFieldName" in $$props) $$invalidate(32, labelFieldName = $$props.labelFieldName);
    		if ("keywordsFieldName" in $$props) $$invalidate(33, keywordsFieldName = $$props.keywordsFieldName);
    		if ("valueFieldName" in $$props) $$invalidate(34, valueFieldName = $$props.valueFieldName);
    		if ("labelFunction" in $$props) $$invalidate(35, labelFunction = $$props.labelFunction);
    		if ("keywordsFunction" in $$props) $$invalidate(36, keywordsFunction = $$props.keywordsFunction);
    		if ("valueFunction" in $$props) $$invalidate(37, valueFunction = $$props.valueFunction);
    		if ("keywordsCleanFunction" in $$props) $$invalidate(38, keywordsCleanFunction = $$props.keywordsCleanFunction);
    		if ("textCleanFunction" in $$props) $$invalidate(39, textCleanFunction = $$props.textCleanFunction);
    		if ("beforeChange" in $$props) $$invalidate(40, beforeChange = $$props.beforeChange);
    		if ("onChange" in $$props) $$invalidate(41, onChange = $$props.onChange);
    		if ("selectFirstIfEmpty" in $$props) $$invalidate(42, selectFirstIfEmpty = $$props.selectFirstIfEmpty);
    		if ("minCharactersToSearch" in $$props) $$invalidate(43, minCharactersToSearch = $$props.minCharactersToSearch);
    		if ("maxItemsToShowInList" in $$props) $$invalidate(0, maxItemsToShowInList = $$props.maxItemsToShowInList);
    		if ("delay" in $$props) $$invalidate(44, delay = $$props.delay);
    		if ("localFiltering" in $$props) $$invalidate(45, localFiltering = $$props.localFiltering);
    		if ("noResultsText" in $$props) $$invalidate(1, noResultsText = $$props.noResultsText);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("className" in $$props) $$invalidate(3, className = $$props.className);
    		if ("inputClassName" in $$props) $$invalidate(4, inputClassName = $$props.inputClassName);
    		if ("inputId" in $$props) $$invalidate(5, inputId = $$props.inputId);
    		if ("name" in $$props) $$invalidate(6, name = $$props.name);
    		if ("title" in $$props) $$invalidate(7, title = $$props.title);
    		if ("html5autocomplete" in $$props) $$invalidate(8, html5autocomplete = $$props.html5autocomplete);
    		if ("dropdownClassName" in $$props) $$invalidate(9, dropdownClassName = $$props.dropdownClassName);
    		if ("hideArrow" in $$props) $$invalidate(10, hideArrow = $$props.hideArrow);
    		if ("showClear" in $$props) $$invalidate(11, showClear = $$props.showClear);
    		if ("disabled" in $$props) $$invalidate(12, disabled = $$props.disabled);
    		if ("debug" in $$props) $$invalidate(46, debug = $$props.debug);
    		if ("selectedItem" in $$props) $$invalidate(29, selectedItem = $$props.selectedItem);
    		if ("value" in $$props) $$invalidate(30, value = $$props.value);
    		if ("input" in $$props) $$invalidate(13, input = $$props.input);
    		if ("list" in $$props) $$invalidate(14, list = $$props.list);
    		if ("opened" in $$props) $$invalidate(47, opened = $$props.opened);
    		if ("highlightIndex" in $$props) $$invalidate(15, highlightIndex = $$props.highlightIndex);
    		if ("text" in $$props) $$invalidate(16, text = $$props.text);
    		if ("filteredTextLength" in $$props) $$invalidate(48, filteredTextLength = $$props.filteredTextLength);
    		if ("filteredListItems" in $$props) $$invalidate(17, filteredListItems = $$props.filteredListItems);
    		if ("listItems" in $$props) listItems = $$props.listItems;
    		if ("inputDelayTimeout" in $$props) inputDelayTimeout = $$props.inputDelayTimeout;
    		if ("showList" in $$props) $$invalidate(18, showList = $$props.showList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*selectedItem*/ 536870912) {
    			(onSelectedItemChanged());
    		}

    		if ($$self.$$.dirty[0] & /*items*/ 268435456 | $$self.$$.dirty[1] & /*opened, filteredTextLength*/ 196608) {
    			$$invalidate(18, showList = opened && (items && items.length > 0 || filteredTextLength > 0));
    		}

    		if ($$self.$$.dirty[0] & /*items*/ 268435456) {
    			(prepareListItems());
    		}
    	};

    	return [
    		maxItemsToShowInList,
    		noResultsText,
    		placeholder,
    		className,
    		inputClassName,
    		inputId,
    		name,
    		title,
    		html5autocomplete,
    		dropdownClassName,
    		hideArrow,
    		showClear,
    		disabled,
    		input,
    		list,
    		highlightIndex,
    		text,
    		filteredListItems,
    		showList,
    		uniqueId,
    		onListItemClick,
    		onDocumentClick,
    		onKeyDown,
    		onKeyPress,
    		onInput,
    		onInputClick,
    		onFocus,
    		clear,
    		items,
    		selectedItem,
    		value,
    		searchFunction,
    		labelFieldName,
    		keywordsFieldName,
    		valueFieldName,
    		labelFunction,
    		keywordsFunction,
    		valueFunction,
    		keywordsCleanFunction,
    		textCleanFunction,
    		beforeChange,
    		onChange,
    		selectFirstIfEmpty,
    		minCharactersToSearch,
    		delay,
    		localFiltering,
    		debug,
    		opened,
    		filteredTextLength,
    		$$scope,
    		slots,
    		input_1_binding,
    		input_1_input_handler,
    		click_handler,
    		pointerenter_handler,
    		div0_binding
    	];
    }

    class SimpleAutocomplete extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$k,
    			create_fragment$k,
    			safe_not_equal,
    			{
    				items: 28,
    				searchFunction: 31,
    				labelFieldName: 32,
    				keywordsFieldName: 33,
    				valueFieldName: 34,
    				labelFunction: 35,
    				keywordsFunction: 36,
    				valueFunction: 37,
    				keywordsCleanFunction: 38,
    				textCleanFunction: 39,
    				beforeChange: 40,
    				onChange: 41,
    				selectFirstIfEmpty: 42,
    				minCharactersToSearch: 43,
    				maxItemsToShowInList: 0,
    				delay: 44,
    				localFiltering: 45,
    				noResultsText: 1,
    				placeholder: 2,
    				className: 3,
    				inputClassName: 4,
    				inputId: 5,
    				name: 6,
    				title: 7,
    				html5autocomplete: 8,
    				dropdownClassName: 9,
    				hideArrow: 10,
    				showClear: 11,
    				disabled: 12,
    				debug: 46,
    				selectedItem: 29,
    				value: 30
    			},
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SimpleAutocomplete",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get items() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFieldName() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFieldName(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keywordsFieldName() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keywordsFieldName(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueFieldName() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueFieldName(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keywordsFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keywordsFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get keywordsCleanFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set keywordsCleanFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textCleanFunction() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textCleanFunction(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get beforeChange() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set beforeChange(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onChange() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onChange(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectFirstIfEmpty() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectFirstIfEmpty(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minCharactersToSearch() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minCharactersToSearch(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxItemsToShowInList() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxItemsToShowInList(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get delay() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set delay(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get localFiltering() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set localFiltering(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noResultsText() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noResultsText(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputClassName() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputClassName(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputId() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get html5autocomplete() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set html5autocomplete(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dropdownClassName() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dropdownClassName(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideArrow() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideArrow(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClear() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClear(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get debug() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set debug(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedItem() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedItem(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<SimpleAutocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SimpleAutocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CharmPositionInput.svelte generated by Svelte v3.38.2 */
    const file$h = "src/components/parts/CharmPositionInput.svelte";

    function create_fragment$j(ctx) {
    	let div;
    	let autocomplete0;
    	let updating_selectedItem;
    	let t0;
    	let autocomplete1;
    	let updating_selectedItem_1;
    	let t1;
    	let autocomplete2;
    	let updating_selectedItem_2;
    	let current;

    	function autocomplete0_selectedItem_binding(value) {
    		/*autocomplete0_selectedItem_binding*/ ctx[7](value);
    	}

    	let autocomplete0_props = {
    		items: /*PAGE_LIST*/ ctx[4],
    		inputId: "" + (/*inputIdPrefix*/ ctx[3] + "page"),
    		placeholder: "ページ",
    		showClear: false,
    		hideArrow: true,
    		className: "autocomplete-charm-page"
    	};

    	if (/*page*/ ctx[0] !== void 0) {
    		autocomplete0_props.selectedItem = /*page*/ ctx[0];
    	}

    	autocomplete0 = new SimpleAutocomplete({
    			props: autocomplete0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete0, "selectedItem", autocomplete0_selectedItem_binding));

    	function autocomplete1_selectedItem_binding(value) {
    		/*autocomplete1_selectedItem_binding*/ ctx[8](value);
    	}

    	let autocomplete1_props = {
    		items: /*ROW_LIST*/ ctx[5],
    		inputId: "" + (/*inputIdPrefix*/ ctx[3] + "row"),
    		placeholder: "行",
    		showClear: false,
    		hideArrow: true,
    		className: "autocomplete-charm-row"
    	};

    	if (/*row*/ ctx[1] !== void 0) {
    		autocomplete1_props.selectedItem = /*row*/ ctx[1];
    	}

    	autocomplete1 = new SimpleAutocomplete({
    			props: autocomplete1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete1, "selectedItem", autocomplete1_selectedItem_binding));

    	function autocomplete2_selectedItem_binding(value) {
    		/*autocomplete2_selectedItem_binding*/ ctx[9](value);
    	}

    	let autocomplete2_props = {
    		items: /*COL_LIST*/ ctx[6],
    		inputId: "" + (/*inputIdPrefix*/ ctx[3] + "col"),
    		placeholder: "列",
    		showClear: false,
    		hideArrow: true,
    		className: "autocomplete-charm-col"
    	};

    	if (/*col*/ ctx[2] !== void 0) {
    		autocomplete2_props.selectedItem = /*col*/ ctx[2];
    	}

    	autocomplete2 = new SimpleAutocomplete({
    			props: autocomplete2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete2, "selectedItem", autocomplete2_selectedItem_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(autocomplete0.$$.fragment);
    			t0 = space();
    			create_component(autocomplete1.$$.fragment);
    			t1 = space();
    			create_component(autocomplete2.$$.fragment);
    			add_location(div, file$h, 13, 0, 424);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(autocomplete0, div, null);
    			append_dev(div, t0);
    			mount_component(autocomplete1, div, null);
    			append_dev(div, t1);
    			mount_component(autocomplete2, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const autocomplete0_changes = {};
    			if (dirty & /*inputIdPrefix*/ 8) autocomplete0_changes.inputId = "" + (/*inputIdPrefix*/ ctx[3] + "page");

    			if (!updating_selectedItem && dirty & /*page*/ 1) {
    				updating_selectedItem = true;
    				autocomplete0_changes.selectedItem = /*page*/ ctx[0];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete0.$set(autocomplete0_changes);
    			const autocomplete1_changes = {};
    			if (dirty & /*inputIdPrefix*/ 8) autocomplete1_changes.inputId = "" + (/*inputIdPrefix*/ ctx[3] + "row");

    			if (!updating_selectedItem_1 && dirty & /*row*/ 2) {
    				updating_selectedItem_1 = true;
    				autocomplete1_changes.selectedItem = /*row*/ ctx[1];
    				add_flush_callback(() => updating_selectedItem_1 = false);
    			}

    			autocomplete1.$set(autocomplete1_changes);
    			const autocomplete2_changes = {};
    			if (dirty & /*inputIdPrefix*/ 8) autocomplete2_changes.inputId = "" + (/*inputIdPrefix*/ ctx[3] + "col");

    			if (!updating_selectedItem_2 && dirty & /*col*/ 4) {
    				updating_selectedItem_2 = true;
    				autocomplete2_changes.selectedItem = /*col*/ ctx[2];
    				add_flush_callback(() => updating_selectedItem_2 = false);
    			}

    			autocomplete2.$set(autocomplete2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete0.$$.fragment, local);
    			transition_in(autocomplete1.$$.fragment, local);
    			transition_in(autocomplete2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete0.$$.fragment, local);
    			transition_out(autocomplete1.$$.fragment, local);
    			transition_out(autocomplete2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(autocomplete0);
    			destroy_component(autocomplete1);
    			destroy_component(autocomplete2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const MAX_PAGE$1 = 30;
    const MAX_ROW = 5;
    const MAX_COL = 8;

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmPositionInput", slots, []);
    	let { inputIdPrefix } = $$props;
    	let { page } = $$props;
    	let { row } = $$props;
    	let { col } = $$props;
    	const PAGE_LIST = [...Array(MAX_PAGE$1 + 1).keys()].slice(1); // 補完用リスト
    	const ROW_LIST = [...Array(MAX_ROW + 1).keys()].slice(1); // 補完用リスト
    	const COL_LIST = [...Array(MAX_COL + 1).keys()].slice(1); // 補完用リスト
    	const writable_props = ["inputIdPrefix", "page", "row", "col"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmPositionInput> was created with unknown prop '${key}'`);
    	});

    	function autocomplete0_selectedItem_binding(value) {
    		page = value;
    		$$invalidate(0, page);
    	}

    	function autocomplete1_selectedItem_binding(value) {
    		row = value;
    		$$invalidate(1, row);
    	}

    	function autocomplete2_selectedItem_binding(value) {
    		col = value;
    		$$invalidate(2, col);
    	}

    	$$self.$$set = $$props => {
    		if ("inputIdPrefix" in $$props) $$invalidate(3, inputIdPrefix = $$props.inputIdPrefix);
    		if ("page" in $$props) $$invalidate(0, page = $$props.page);
    		if ("row" in $$props) $$invalidate(1, row = $$props.row);
    		if ("col" in $$props) $$invalidate(2, col = $$props.col);
    	};

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		inputIdPrefix,
    		page,
    		row,
    		col,
    		MAX_PAGE: MAX_PAGE$1,
    		PAGE_LIST,
    		MAX_ROW,
    		ROW_LIST,
    		MAX_COL,
    		COL_LIST
    	});

    	$$self.$inject_state = $$props => {
    		if ("inputIdPrefix" in $$props) $$invalidate(3, inputIdPrefix = $$props.inputIdPrefix);
    		if ("page" in $$props) $$invalidate(0, page = $$props.page);
    		if ("row" in $$props) $$invalidate(1, row = $$props.row);
    		if ("col" in $$props) $$invalidate(2, col = $$props.col);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		page,
    		row,
    		col,
    		inputIdPrefix,
    		PAGE_LIST,
    		ROW_LIST,
    		COL_LIST,
    		autocomplete0_selectedItem_binding,
    		autocomplete1_selectedItem_binding,
    		autocomplete2_selectedItem_binding
    	];
    }

    class CharmPositionInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			inputIdPrefix: 3,
    			page: 0,
    			row: 1,
    			col: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmPositionInput",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*inputIdPrefix*/ ctx[3] === undefined && !("inputIdPrefix" in props)) {
    			console.warn("<CharmPositionInput> was created without expected prop 'inputIdPrefix'");
    		}

    		if (/*page*/ ctx[0] === undefined && !("page" in props)) {
    			console.warn("<CharmPositionInput> was created without expected prop 'page'");
    		}

    		if (/*row*/ ctx[1] === undefined && !("row" in props)) {
    			console.warn("<CharmPositionInput> was created without expected prop 'row'");
    		}

    		if (/*col*/ ctx[2] === undefined && !("col" in props)) {
    			console.warn("<CharmPositionInput> was created without expected prop 'col'");
    		}
    	}

    	get inputIdPrefix() {
    		throw new Error("<CharmPositionInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputIdPrefix(value) {
    		throw new Error("<CharmPositionInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get page() {
    		throw new Error("<CharmPositionInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<CharmPositionInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<CharmPositionInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<CharmPositionInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get col() {
    		throw new Error("<CharmPositionInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set col(value) {
    		throw new Error("<CharmPositionInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // 装備一覧のアイコン配列
    const MAX_PAGE = 99;
    const COLS_PER_PAGE_IN_EQLIST = 10;
    const ROWS_PER_PAGE_IN_EQLIST = 5;
    const COLS_PER_PAGE_IN_RINNE = 8;
    const ROWS_PER_PAGE_IN_RINNE = 4;
    // スキル
    const MAX_SKILL_LEVEL$1 = 7;
    // 護石
    const MAX_RARITY = 10;
    const MAX_NUM_SLOTS = 3;
    const MAX_SLOT_LEVEL = 4;

    /* src/components/parts/CharmRarityInput.svelte generated by Svelte v3.38.2 */
    const file$g = "src/components/parts/CharmRarityInput.svelte";

    function create_fragment$i(ctx) {
    	let div;
    	let autocomplete;
    	let updating_selectedItem;
    	let current;

    	function autocomplete_selectedItem_binding(value) {
    		/*autocomplete_selectedItem_binding*/ ctx[7](value);
    	}

    	let autocomplete_props = {
    		items: /*RARITY_LIST*/ ctx[6],
    		inputId: /*inputId*/ ctx[1],
    		placeholder: /*placeholder*/ ctx[2],
    		showClear: /*showClear*/ ctx[3],
    		hideArrow: /*hideArrow*/ ctx[4],
    		className: /*className*/ ctx[5]
    	};

    	if (/*value*/ ctx[0] !== void 0) {
    		autocomplete_props.selectedItem = /*value*/ ctx[0];
    	}

    	autocomplete = new SimpleAutocomplete({
    			props: autocomplete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(autocomplete.$$.fragment);
    			add_location(div, file$g, 11, 0, 400);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(autocomplete, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const autocomplete_changes = {};
    			if (dirty & /*inputId*/ 2) autocomplete_changes.inputId = /*inputId*/ ctx[1];
    			if (dirty & /*placeholder*/ 4) autocomplete_changes.placeholder = /*placeholder*/ ctx[2];
    			if (dirty & /*showClear*/ 8) autocomplete_changes.showClear = /*showClear*/ ctx[3];
    			if (dirty & /*hideArrow*/ 16) autocomplete_changes.hideArrow = /*hideArrow*/ ctx[4];
    			if (dirty & /*className*/ 32) autocomplete_changes.className = /*className*/ ctx[5];

    			if (!updating_selectedItem && dirty & /*value*/ 1) {
    				updating_selectedItem = true;
    				autocomplete_changes.selectedItem = /*value*/ ctx[0];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete.$set(autocomplete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(autocomplete);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmRarityInput", slots, []);
    	const RARITY_LIST = [...Array(MAX_RARITY + 1).keys()].slice(1); // 補完用リスト
    	let { inputId = "input-rarity" } = $$props;
    	let { placeholder = "" } = $$props;
    	let { showClear = false } = $$props;
    	let { hideArrow = true } = $$props;
    	let { className = "autocomplete-rarity" } = $$props;
    	let { value } = $$props;
    	const writable_props = ["inputId", "placeholder", "showClear", "hideArrow", "className", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmRarityInput> was created with unknown prop '${key}'`);
    	});

    	function autocomplete_selectedItem_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ("inputId" in $$props) $$invalidate(1, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		MAX_RARITY,
    		RARITY_LIST,
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		value
    	});

    	$$self.$inject_state = $$props => {
    		if ("inputId" in $$props) $$invalidate(1, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		RARITY_LIST,
    		autocomplete_selectedItem_binding
    	];
    }

    class CharmRarityInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			inputId: 1,
    			placeholder: 2,
    			showClear: 3,
    			hideArrow: 4,
    			className: 5,
    			value: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmRarityInput",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<CharmRarityInput> was created without expected prop 'value'");
    		}
    	}

    	get inputId() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClear() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClear(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideArrow() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideArrow(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<CharmRarityInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<CharmRarityInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const allSkillDetails = [
      // 'あ行のスキル',
      { name: '合気',               hiragana: 'あいき',                           englishCharacters: 'aiki'                         },
      { name: 'アイテム使用強化',   hiragana: 'あいてむしようきょうか',           englishCharacters: 'aitemusiyoukyouka'            },
      { name: '泡沫の舞',           hiragana: 'うたかたのまい',                   englishCharacters: 'utakatanomai'                 },
      { name: '炎鱗の恩恵',         hiragana: 'えんりんのおんけい',               englishCharacters: 'enrinnoonkei'                 },
      { name: '鬼火纏',             hiragana: 'おにびまとい',                     englishCharacters: 'onibimatoi'                   },
      // 'か行のスキル',
      { name: 'ガード強化',         hiragana: 'がーどきょうか',                   englishCharacters: 'ga-dokyouka'                  },
      { name: 'ガード性能',         hiragana: 'がーどせいのう',                   englishCharacters: 'ga-doseinou'                  },
      { name: '会心撃【属性】',     hiragana: 'かいしんげきぞくせい',             englishCharacters: 'kaisingekizokusei'            },
      { name: '回避距離UP',         hiragana: 'かいひきょりあっぷ',               englishcharacters: 'kaihikyoriappu'               },
      { name: '回避性能',           hiragana: 'かいひせいのう',                   englishCharacters: 'kaihiseinou'                  },
      { name: '回復速度',           hiragana: 'かいふくそくど',                   englishCharacters: 'kaihukusokudo'                },
      { name: '翔蟲使い',           hiragana: 'かけりむしつかい',                 englishCharacters: 'kakerimusitukai'              },
      { name: '火事場力',           hiragana: 'かじばりょく',                     englishCharacters: 'kajibaryoku'                  },
      { name: '滑走強化',           hiragana: 'かっそうきょうか',                 englishCharacters: 'kassoukyouka'                 },
      { name: '霞皮の恩恵',         hiragana: 'かすみがわのおんけい',             englishCharacters: 'kasumigawanoonkei'            },
      { name: '雷属性攻撃強化',     hiragana: 'かみなりぞくせいこうげききょうか', englishCharacters: 'kaminarizokuseikougekikyouka' },
      { name: '雷耐性',             hiragana: 'かみなりたいせい',                 englishCharacters: 'kaminaritaisei'               },
      { name: '貫通弾・貫通矢強化', hiragana: 'かんつうだんかんつうやきょうか',   englishCharacters: 'kantuudankantuuyakyouka'      },
      { name: '気絶耐性',           hiragana: 'きぜつたいせい',                   englishCharacters: 'kizetutaisei'                 },
      { name: 'キノコ大好き',       hiragana: 'きのこだいすき',                   englishCharacters: 'kinokodaisuki'                },
      { name: '逆襲',               hiragana: 'ぎゃくしゅう',                     englishCharacters: 'gyakusyuu'                    },
      { name: '供応',               hiragana: 'きょうおう',                       englishCharacters: 'kyouou'                       },
      { name: '強化持続',           hiragana: 'きょうかじぞく',                   englishCharacters: 'kyoukajizoku'                 },
      { name: '狂竜症【蝕】',       hiragana: 'きょうりゅうしょうしょく',         englishCharacters: 'kyouryuusyousyoku'            },
      { name: 'KO術',               hiragana: 'けーおーじゅつ',                   englishcharacters: 'ke-o-jutu'                    },
      { name: '血氣',               hiragana: 'けっき',                           englishcharacters: 'kekki'                        },
      { name: '激昂',               hiragana: 'げっこう',                         englishcharacters: 'gekkou'                       },
      { name: '研磨術【鋭】',       hiragana: 'けんまじゅつえい',                 englishcharacters: 'kenmajyutuei'                 },
      { name: '広域化',             hiragana: 'こういきか',                       englishCharacters: 'kouikika'                     },
      { name: '幸運',               hiragana: 'こううん',                         englishCharacters: 'kouun'                        },
      { name: '鋼殻の恩恵',         hiragana: 'こうかくのおんけい',               englishCharacters: 'koukakunoonkei'               },
      { name: '業鎧【修羅】',       hiragana: 'ごうがいしゅら',                   englishCharacters: 'gougaisyura'                  },
      { name: '攻撃',               hiragana: 'こうげき',                         englishCharacters: 'kougeki'                      },
      { name: '剛刃研磨',           hiragana: 'ごうじんけんま',                   englishCharacters: 'goujinkenma'                  },
      { name: '攻勢',               hiragana: 'こうせい',                         englishCharacters: 'kousei'                       },
      { name: '高速変形',           hiragana: 'こうそくへんけい',                 englishCharacters: 'kousokuhenkei'                },
      { name: '氷属性攻撃強化',     hiragana: 'こおりぞくせいきょうか',           englishCharacters: 'koorizokuseikyouka'           },
      { name: '氷耐性',             hiragana: 'こおりたいせい',                   englishCharacters: 'kooritaisei'                  },
      { name: '渾身',               hiragana: 'こんしん',                         englishCharacters: 'konsin'                       },
      // 'さ行のスキル',
      { name: '災禍転福',           hiragana: 'さいかてんぷく',                   englishCharacters: 'saikatenpuku'                 },
      { name: '逆恨み',             hiragana: 'さかうらみ',                       englishCharacters: 'sakaurami'                    },
      { name: '散弾・拡散矢強化',   hiragana: 'さんだんかんつうやきょうか',       englishCharacters: 'sandankantuuyakyouka'         },
      { name: '死中に活',           hiragana: 'しちゅうにかつ',                   englishCharacters: 'sityuunikatu'                 },
      { name: '疾之息吹',           hiragana: 'しつのいぶき',                     englishCharacters: 'situnoibuki'                  },
      { name: '弱点特効',           hiragana: 'じゃくてんとっこう',               englishCharacters: 'jakutentokkou'                },
      { name: 'ジャンプ鉄人',       hiragana: 'じゃんぷてつじん',                 englishCharacters: 'janputetujin'                 },
      { name: '集中',               hiragana: 'しゅうちゅう',                     englishCharacters: 'syuutyuu'                     },
      { name: '植生学',             hiragana: 'しょくせいがく',                   englishCharacters: 'syokuseigaku'                 },
      { name: '心眼',               hiragana: 'しんがん',                         englishCharacters: 'singan'                       },
      { name: '刃鱗磨き',           hiragana: 'じんりんみがき',                   englishCharacters: 'jinrinmigaki'                 },
      { name: '睡眠属性強化',       hiragana: 'すいみんぞくせいきょうか',         englishCharacters: 'suiminzokuseikyouka'          },
      { name: '睡眠耐性',           hiragana: 'すいみんたいせい',                 englishCharacters: 'suimintaisei'                 },
      { name: 'スタミナ急速回復',   hiragana: 'すたみなきゅうそくかいふく',       englishCharacters: 'sutaminakyuusokukaihuku'      },
      { name: 'スタミナ奪取',       hiragana: 'すたみなだっしゅ',                 englishCharacters: 'sutaminadassyu'               },
      { name: '精霊の加護',         hiragana: 'せいれいのかご',                   englishCharacters: 'seireinokago'                 },
      { name: '攻めの守勢',         hiragana: 'せめのしゅせい',                   englishCharacters: 'semenosyusei'                 },
      { name: '装填拡張',           hiragana: 'そうてんかくちょう',               englishCharacters: 'soutenkakutyou'               },
      { name: '装填速度',           hiragana: 'そうてんそくど',                   englishCharacters: 'soutensokudo'                 },
      { name: '速射強化',           hiragana: 'そくしゃきょうか',                 englishCharacters: 'sokusyakyouka'                },
      { name: '属性やられ耐性',     hiragana: 'ぞくせいやられたいせい',           englishCharacters: 'zokuseiyararetaisei'          },
      // 'た行のスキル',
      { name: '体術',               hiragana: 'たいじゅつ',                       englishCharacters: 'taijutu'                      },
      { name: '耐震',               hiragana: 'たいしん',                         englishCharacters: 'taisin'                       },
      { name: '体力回復量UP',       hiragana: 'たいりょくかいふくりょうあっぷ',   englishcharacters: 'tairyokukaihukuryouappu'      },
      { name: '匠',                 hiragana: 'たくみ',                           englishCharacters: 'takumi'                       },
      { name: '達人芸',             hiragana: 'たつじんげい',                     englishCharacters: 'tatujingei'                   },
      { name: '弾丸節約',           hiragana: 'だんがんせつやく',                 englishCharacters: 'dangansetuyaku'               },
      { name: '弾導強化',           hiragana: 'だんどうきょうか',                 englishCharacters: 'dandoukyouka'                 },
      { name: '力の解放',           hiragana: 'ちからのかいほう',                 englishCharacters: 'tikaranokaihou'               },
      { name: '地質学',             hiragana: 'ちしつがく',                       englishCharacters: 'tisitugaku'                   },
      { name: 'チャージマスター',   hiragana: 'チャージマスター',                 englishCharacters: 'tya-jimasuta-'                },
      { name: 'チューンアップ',     hiragana: 'チューンアップ',                   englishCharacters: 'tyu-nnappu'                   },
      { name: '超会心',             hiragana: 'ちょうかいしん',                   englishCharacters: 'tyoukaisin'                   },
      { name: '挑戦者',             hiragana: 'ちょうせんしゃ',                   englishCharacters: 'tyousensya'                   },
      { name: '通常弾・連射矢強化', hiragana: 'つうじょうだんそくしゃやきょうか', englishCharacters: 'tuujoudansokusyayakyouka'     },
      { name: '泥雪耐性',           hiragana: 'でいせつたいせい',                 englishCharacters: 'deisetutaisei'                },
      { name: '砥石使用高速化',     hiragana: 'といししようこうそくか',           englishCharacters: 'toisisiyoukousokuka'          },
      { name: '特殊射撃強化',       hiragana: 'とくしゅしゃげききょうか',         englishCharacters: 'tokusyusyagekikyouka'         },
      { name: '毒属性強化',         hiragana: 'どくぞくせいきょうか',             englishCharacters: 'dokuzokuseikyouka'            },
      { name: '毒耐性',             hiragana: 'どくたいせい',                     englishCharacters: 'dokutaisei'                   },
      { name: '飛び込み',           hiragana: 'とびこみ',                         englishCharacters: 'tobikomi'                     },
      { name: '鈍器使い',           hiragana: 'どんきつかい',                     englishCharacters: 'donkitukai'                   },
      // 'な行のスキル',
      { name: '納刀術',             hiragana: 'のうとうじゅつ',                   englishCharacters: 'noutoujutu'                   },
      { name: '乗り名人',           hiragana: 'のりめいじん',                     englishCharacters: 'norimeijin'                   },
      // 'は行のスキル',
      { name: '破壊王',             hiragana: 'はかいおう',                       englishCharacters: 'hakaiou'                      },
      { name: '剥ぎ取り鉄人',       hiragana: 'はぎとりてつじん',                 englishCharacters: 'hagitoritetujin'              },
      { name: '剥ぎ取り名人',       hiragana: 'はぎとりめいじん',                 englishCharacters: 'hagitorimeijin'               },
      { name: '爆破属性強化',       hiragana: 'ばくはぞくせいきょうか',           englishCharacters: 'bakuhazokuseikyouka'          },
      { name: '爆破やられ耐性',     hiragana: 'ばくはやられたいせい',             englishCharacters: 'bakuhayararetaisei'           },
      { name: '抜刀術【力】',       hiragana: 'ばっとうじゅつちから',             englishCharacters: 'battoujututikara'             },
      { name: '抜刀術【技】',       hiragana: 'ばっとうじゅつわざ',               englishCharacters: 'battoujutuwaza'               },
      { name: '早食い',             hiragana: 'はやぐい',                         englishCharacters: 'hayagui'                      },
      { name: '腹減り耐性',         hiragana: 'はらへりたいせい',                 englishCharacters: 'haraheritaisei'               },
      { name: '反動軽減',           hiragana: 'はんどうけいげん',                 englishCharacters: 'handoukeigen'                 },
      { name: '火属性攻撃強化',     hiragana: 'ひぞくせいこうげききょうか',       englishCharacters: 'hizokuseikougekikyouka'       },
      { name: '火耐性',             hiragana: 'ひたいせい',                       englishCharacters: 'hitaisei'                     },
      { name: 'ひるみ軽減',         hiragana: 'ひるみけいげん',                   englishCharacters: 'hirumikeigen'                 },
      { name: '風圧耐性',           hiragana: 'ふうあつたいせい',                 englishCharacters: 'huuatutaisei'                 },
      { name: '風紋の一致',         hiragana: 'ふうもんのいっち',                 englishCharacters: 'huumonnoitti'                 },
      { name: '笛吹き名人',         hiragana: 'ふえふきめいじん',                 englishCharacters: 'huehukimeijin'                },
      { name: '不屈',               hiragana: 'ふくつ',                           englishCharacters: 'hukutu'                       },
      { name: '伏魔響命',           hiragana: 'ふくまきょうめい',                 englishCharacters: 'hukumakyoumei'                },
      { name: 'フルチャージ',       hiragana: 'ふるちゃーじ',                     englishCharacters: 'hurutya-ji'                   },
      { name: 'ブレ抑制',           hiragana: 'ぶれよくせい',                     englishCharacters: 'bureyokusei'                  },
      { name: '壁面移動',           hiragana: 'へきめんいどう',                   englishCharacters: 'hekimenidou'                  },
      { name: '壁面移動【翔】',     hiragana: 'へきめんいどうしょう',             englishCharacters: 'hekimenidousyou'              },
      { name: '防御',               hiragana: 'ぼうぎょ',                         englishCharacters: 'bougyo'                       },
      { name: '砲術',               hiragana: 'ほうじゅつ',                       englishCharacters: 'houjutu'                      },
      { name: '砲弾装填',           hiragana: 'ほうだんそうてん',                 englishCharacters: 'houdansouten'                 },
      { name: '捕獲名人',           hiragana: 'ほかくめいじん',                   englishCharacters: 'hokakumeijin'                 },
      { name: 'ボマー',             hiragana: 'ぼまー',                           englishCharacters: 'boma-'                        },
      // 'ま行のスキル',
      { name: '麻痺属性強化',       hiragana: 'まひぞくせいきょうか',             englishCharacters: 'mahizokuseikyouka'            },
      { name: '麻痺耐性',           hiragana: 'まひたいせい',                     englishCharacters: 'mahitaisei'                   },
      { name: '満足感',             hiragana: 'まんぞくかん',                     englishCharacters: 'manzokukan'                   },
      { name: '見切り',             hiragana: 'みきり',                           englishCharacters: 'mikiri'                       },
      { name: '水属性攻撃強化',     hiragana: 'みずぞくせいこうげききょうか',     englishCharacters: 'mizuzokuseikougekikyouka'     },
      { name: '水耐性',             hiragana: 'みずたいせい',                     englishCharacters: 'mizutaisei'                   },
      { name: '耳栓',               hiragana: 'みみせん',                         englishCharacters: 'mimisen'                      },
      // 'や行のスキル',
      { name: '弓溜め段階解放',     hiragana: 'ゆみためだんかいかいほう',         englishCharacters: 'yumitamedankaikaihou'         },
      { name: '陽動',               hiragana: 'ようどう',                         englishCharacters: 'youdou'                       },
      // 'ら行のスキル',
      { name: '雷紋の一致',         hiragana: 'らいもんのいっち',                 englishCharacters: 'raimonnoitti'                 },
      { name: 'ランナー',           hiragana: 'らんなー',                         englishCharacters: 'ranna-'                       },
      { name: '龍属性攻撃強化',     hiragana: 'りゅうぞくせいこうげききょうか',   englishCharacters: 'ryuuzokuseikougekikyouka'     },
      { name: '龍耐性',             hiragana: 'りゅうたいせい',                   englishCharacters: 'ryuutaisei'                   },
      { name: '連撃',               hiragana: 'れんげき',                         englishCharacters: 'rengeki'                      },
      // 'わ行のスキル',
      { name: '業物',               hiragana: 'わざもの',                         englishCharacters: 'wazamono'                     },

      // added in v15 charm farming
      { name: '龍気活性',           hiragana: 'りゅうきかっせい',                   englishCharacters: 'ryuukikassei'                },
      { name: '根性',               hiragana: 'こんじょう',                         englishCharacters: 'konjyou'                     },
      { name: '巧撃',               hiragana: 'こうげき',                           englishCharacters: 'kougeki'                     },
      { name: '闇討ち',             hiragana: 'やみうち',                           englishCharacters: 'yamiuti'                     },
      { name: '弱点特効【属性】',   hiragana: 'じゃくてんとっこうぞくせい',         englishCharacters: 'jakutentokkouzokusei'        },
      { name: '顕如盤石',           hiragana: 'けんにょばんじゃく',                 englishCharacters: 'kennyobanjaku'               },
      { name: '状態異常確定蓄積',   hiragana: 'じょうたいいじょうかくていちくせき', englishCharacters: 'jyoutaiijyoukakuteitikuseki' },
      { name: '煽衛',               hiragana: 'せんえい',                           englishCharacters: 'sennei'                      },
      { name: '剛心',               hiragana: 'ごうしん',                           englishCharacters: 'gousin'                      },
      { name: '蓄積時攻撃強化',     hiragana: 'ちくせきじこうげききょうか',         englishCharacters: 'tikusekijikougekikyouka'     },
      { name: '狂化',               hiragana: 'きょうか',                           englishCharacters: 'kyouka'                      },
      { name: '奮闘',               hiragana: 'ふんとう',                           englishCharacters: 'huntou'                      },
      { name: '風纏',               hiragana: 'かぜまとい',                         englishCharacters: 'kazematoi'                   },
      { name: '粉塵纏',             hiragana: 'ふんじんまとい',                     englishCharacters: 'hunjinmatoi'                 },
      { name: '龍気変換',           hiragana: 'りゅうきかっせい',                   englishCharacters: 'ryuukihenkan'                },
      { name: '冰気錬成',           hiragana: 'ひょうきれんせい',                   englishCharacters: 'hyoukirensei'                },
    ];



    const getAllSkillNames = () => allSkillDetails.map(i => i.name);

    /* src/components/parts/CharmSkillInput.svelte generated by Svelte v3.38.2 */

    function create_fragment$h(ctx) {
    	let autocomplete;
    	let updating_selectedItem;
    	let current;

    	function autocomplete_selectedItem_binding(value) {
    		/*autocomplete_selectedItem_binding*/ ctx[7](value);
    	}

    	let autocomplete_props = {
    		items: allSkillDetails,
    		inputId: /*inputId*/ ctx[0],
    		labelFieldName: "name",
    		valueFieldName: "name",
    		keywordsFunction: func$1,
    		placeholder: /*placeholder*/ ctx[1],
    		showClear: /*showClear*/ ctx[2],
    		hideArrow: /*hideArrow*/ ctx[3],
    		className: /*className*/ ctx[4]
    	};

    	if (/*_value*/ ctx[5] !== void 0) {
    		autocomplete_props.selectedItem = /*_value*/ ctx[5];
    	}

    	autocomplete = new SimpleAutocomplete({
    			props: autocomplete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));

    	const block = {
    		c: function create() {
    			create_component(autocomplete.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(autocomplete, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const autocomplete_changes = {};
    			if (dirty & /*inputId*/ 1) autocomplete_changes.inputId = /*inputId*/ ctx[0];
    			if (dirty & /*placeholder*/ 2) autocomplete_changes.placeholder = /*placeholder*/ ctx[1];
    			if (dirty & /*showClear*/ 4) autocomplete_changes.showClear = /*showClear*/ ctx[2];
    			if (dirty & /*hideArrow*/ 8) autocomplete_changes.hideArrow = /*hideArrow*/ ctx[3];
    			if (dirty & /*className*/ 16) autocomplete_changes.className = /*className*/ ctx[4];

    			if (!updating_selectedItem && dirty & /*_value*/ 32) {
    				updating_selectedItem = true;
    				autocomplete_changes.selectedItem = /*_value*/ ctx[5];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete.$set(autocomplete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(autocomplete, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = s => `${s.name} ${s.hiragana} ${s.englishCharacters}`;

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmSkillInput", slots, []);
    	let { inputId = "input-skill" } = $$props;
    	let { placeholder = "スキル" } = $$props;
    	let { showClear = true } = $$props;
    	let { hideArrow = true } = $$props;
    	let { className = "autocomplete-skill" } = $$props;
    	let { value } = $$props; // スキル名 (親コンポーネントと共有)
    	let _value; // 補完用メタデータを含めたオブジェクト (AutoComplete コンポーネントと共有)

    	function _updateValue(value) {
    		$$invalidate(5, _value = allSkillDetails.find(i => i.name === value));
    	}

    	function updateValue(_value) {
    		$$invalidate(6, value = _value === null || _value === void 0
    		? void 0
    		: _value.name);
    	}

    	const writable_props = ["inputId", "placeholder", "showClear", "hideArrow", "className", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmSkillInput> was created with unknown prop '${key}'`);
    	});

    	function autocomplete_selectedItem_binding(value) {
    		_value = value;
    		$$invalidate(5, _value);
    	}

    	$$self.$$set = $$props => {
    		if ("inputId" in $$props) $$invalidate(0, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(2, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(3, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(4, className = $$props.className);
    		if ("value" in $$props) $$invalidate(6, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		allSkillDetails,
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		value,
    		_value,
    		_updateValue,
    		updateValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("inputId" in $$props) $$invalidate(0, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(1, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(2, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(3, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(4, className = $$props.className);
    		if ("value" in $$props) $$invalidate(6, value = $$props.value);
    		if ("_value" in $$props) $$invalidate(5, _value = $$props._value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 64) {
    			// value と _value を互いに自動更新する
    			// ベタ書きすると cyclical dependency エラーになるので関数にして分析を回避
    			_updateValue(value); // 初期値は親からの値を優先するので value → _value を先に書く
    		}

    		if ($$self.$$.dirty & /*_value*/ 32) {
    			updateValue(_value);
    		}
    	};

    	return [
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		_value,
    		value,
    		autocomplete_selectedItem_binding
    	];
    }

    class CharmSkillInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			inputId: 0,
    			placeholder: 1,
    			showClear: 2,
    			hideArrow: 3,
    			className: 4,
    			value: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmSkillInput",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[6] === undefined && !("value" in props)) {
    			console.warn("<CharmSkillInput> was created without expected prop 'value'");
    		}
    	}

    	get inputId() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClear() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClear(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideArrow() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideArrow(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<CharmSkillInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<CharmSkillInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CharmSkillLevelInput.svelte generated by Svelte v3.38.2 */

    function create_fragment$g(ctx) {
    	let autocomplete;
    	let updating_selectedItem;
    	let current;

    	function autocomplete_selectedItem_binding(value) {
    		/*autocomplete_selectedItem_binding*/ ctx[7](value);
    	}

    	let autocomplete_props = {
    		items: /*SKILL_LEVEL_LIST*/ ctx[6],
    		inputId: /*inputId*/ ctx[1],
    		placeholder: /*placeholder*/ ctx[2],
    		showClear: /*showClear*/ ctx[3],
    		hideArrow: /*hideArrow*/ ctx[4],
    		className: /*className*/ ctx[5]
    	};

    	if (/*value*/ ctx[0] !== void 0) {
    		autocomplete_props.selectedItem = /*value*/ ctx[0];
    	}

    	autocomplete = new SimpleAutocomplete({
    			props: autocomplete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));

    	const block = {
    		c: function create() {
    			create_component(autocomplete.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(autocomplete, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const autocomplete_changes = {};
    			if (dirty & /*inputId*/ 2) autocomplete_changes.inputId = /*inputId*/ ctx[1];
    			if (dirty & /*placeholder*/ 4) autocomplete_changes.placeholder = /*placeholder*/ ctx[2];
    			if (dirty & /*showClear*/ 8) autocomplete_changes.showClear = /*showClear*/ ctx[3];
    			if (dirty & /*hideArrow*/ 16) autocomplete_changes.hideArrow = /*hideArrow*/ ctx[4];
    			if (dirty & /*className*/ 32) autocomplete_changes.className = /*className*/ ctx[5];

    			if (!updating_selectedItem && dirty & /*value*/ 1) {
    				updating_selectedItem = true;
    				autocomplete_changes.selectedItem = /*value*/ ctx[0];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete.$set(autocomplete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(autocomplete, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmSkillLevelInput", slots, []);
    	const SKILL_LEVEL_LIST = [...Array(MAX_SKILL_LEVEL$1 + 1).keys()].slice(1); // 補完用リスト
    	let { inputId = "input-skill-level-0" } = $$props;
    	let { placeholder = "Lv" } = $$props;
    	let { showClear = false } = $$props;
    	let { hideArrow = true } = $$props;
    	let { className = "autocomplete-skill-level" } = $$props;
    	let { value = 0 } = $$props;
    	const writable_props = ["inputId", "placeholder", "showClear", "hideArrow", "className", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmSkillLevelInput> was created with unknown prop '${key}'`);
    	});

    	function autocomplete_selectedItem_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$props => {
    		if ("inputId" in $$props) $$invalidate(1, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		MAX_SKILL_LEVEL: MAX_SKILL_LEVEL$1,
    		SKILL_LEVEL_LIST,
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		value
    	});

    	$$self.$inject_state = $$props => {
    		if ("inputId" in $$props) $$invalidate(1, inputId = $$props.inputId);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		inputId,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		SKILL_LEVEL_LIST,
    		autocomplete_selectedItem_binding
    	];
    }

    class CharmSkillLevelInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			inputId: 1,
    			placeholder: 2,
    			showClear: 3,
    			hideArrow: 4,
    			className: 5,
    			value: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmSkillLevelInput",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get inputId() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputId(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClear() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClear(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideArrow() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideArrow(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<CharmSkillLevelInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CharmSlotsInput.svelte generated by Svelte v3.38.2 */
    const file$f = "src/components/parts/CharmSlotsInput.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[9] = list;
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (14:2) {#each [...Array(MAX_NUM_SLOTS).keys()] as i}
    function create_each_block$a(ctx) {
    	let autocomplete;
    	let updating_selectedItem;
    	let current;

    	function autocomplete_selectedItem_binding(value) {
    		/*autocomplete_selectedItem_binding*/ ctx[7](value, /*i*/ ctx[8]);
    	}

    	let autocomplete_props = {
    		items: /*SLOT_LEVEL_LIST*/ ctx[6],
    		inputId: "" + (/*inputIdPrefix*/ ctx[1] + /*i*/ ctx[8]),
    		placeholder: "" + (/*placeholder*/ ctx[2] + (/*i*/ ctx[8] + 1)),
    		showClear: /*showClear*/ ctx[3],
    		hideArrow: /*hideArrow*/ ctx[4],
    		className: /*className*/ ctx[5]
    	};

    	if (/*values*/ ctx[0][/*i*/ ctx[8]] !== void 0) {
    		autocomplete_props.selectedItem = /*values*/ ctx[0][/*i*/ ctx[8]];
    	}

    	autocomplete = new SimpleAutocomplete({
    			props: autocomplete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));

    	const block = {
    		c: function create() {
    			create_component(autocomplete.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(autocomplete, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const autocomplete_changes = {};
    			if (dirty & /*inputIdPrefix*/ 2) autocomplete_changes.inputId = "" + (/*inputIdPrefix*/ ctx[1] + /*i*/ ctx[8]);
    			if (dirty & /*placeholder*/ 4) autocomplete_changes.placeholder = "" + (/*placeholder*/ ctx[2] + (/*i*/ ctx[8] + 1));
    			if (dirty & /*showClear*/ 8) autocomplete_changes.showClear = /*showClear*/ ctx[3];
    			if (dirty & /*hideArrow*/ 16) autocomplete_changes.hideArrow = /*hideArrow*/ ctx[4];
    			if (dirty & /*className*/ 32) autocomplete_changes.className = /*className*/ ctx[5];

    			if (!updating_selectedItem && dirty & /*values, Array, MAX_NUM_SLOTS*/ 1) {
    				updating_selectedItem = true;
    				autocomplete_changes.selectedItem = /*values*/ ctx[0][/*i*/ ctx[8]];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete.$set(autocomplete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(autocomplete, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(14:2) {#each [...Array(MAX_NUM_SLOTS).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div;
    	let current;
    	let each_value = [...Array(MAX_NUM_SLOTS).keys()];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$f, 12, 0, 487);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*SLOT_LEVEL_LIST, inputIdPrefix, Array, MAX_NUM_SLOTS, placeholder, showClear, hideArrow, className, values*/ 127) {
    				each_value = [...Array(MAX_NUM_SLOTS).keys()];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmSlotsInput", slots, []);
    	const SLOT_LEVEL_LIST = [...Array(MAX_SLOT_LEVEL + 1).keys()].slice(1); // 補完用リスト
    	let { inputIdPrefix = "input-slot-" } = $$props;
    	let { placeholder = "スロット" } = $$props;
    	let { showClear = true } = $$props;
    	let { hideArrow = true } = $$props;
    	let { className = "autocomplete-slot-level" } = $$props;
    	let { values = [] } = $$props;

    	const writable_props = [
    		"inputIdPrefix",
    		"placeholder",
    		"showClear",
    		"hideArrow",
    		"className",
    		"values"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmSlotsInput> was created with unknown prop '${key}'`);
    	});

    	function autocomplete_selectedItem_binding(value, i) {
    		if ($$self.$$.not_equal(values[i], value)) {
    			values[i] = value;
    			$$invalidate(0, values);
    		}
    	}

    	$$self.$$set = $$props => {
    		if ("inputIdPrefix" in $$props) $$invalidate(1, inputIdPrefix = $$props.inputIdPrefix);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("values" in $$props) $$invalidate(0, values = $$props.values);
    	};

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		MAX_NUM_SLOTS,
    		MAX_SLOT_LEVEL,
    		SLOT_LEVEL_LIST,
    		inputIdPrefix,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		values
    	});

    	$$self.$inject_state = $$props => {
    		if ("inputIdPrefix" in $$props) $$invalidate(1, inputIdPrefix = $$props.inputIdPrefix);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("showClear" in $$props) $$invalidate(3, showClear = $$props.showClear);
    		if ("hideArrow" in $$props) $$invalidate(4, hideArrow = $$props.hideArrow);
    		if ("className" in $$props) $$invalidate(5, className = $$props.className);
    		if ("values" in $$props) $$invalidate(0, values = $$props.values);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*values*/ 1) {
    			$$invalidate(0, values = values.sort((a, b) => b - a));
    		}
    	};

    	return [
    		values,
    		inputIdPrefix,
    		placeholder,
    		showClear,
    		hideArrow,
    		className,
    		SLOT_LEVEL_LIST,
    		autocomplete_selectedItem_binding
    	];
    }

    class CharmSlotsInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			inputIdPrefix: 1,
    			placeholder: 2,
    			showClear: 3,
    			hideArrow: 4,
    			className: 5,
    			values: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmSlotsInput",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get inputIdPrefix() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputIdPrefix(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showClear() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showClear(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideArrow() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideArrow(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get values() {
    		throw new Error("<CharmSlotsInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set values(value) {
    		throw new Error("<CharmSlotsInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
     * Dexie.js - a minimalistic wrapper for IndexedDB
     * ===============================================
     *
     * By David Fahlander, david.fahlander@gmail.com
     *
     * Version 3.0.3, Wed Nov 18 2020
     *
     * http://dexie.org
     *
     * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
     */
     
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };










    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var keys = Object.keys;
    var isArray = Array.isArray;
    var _global = typeof self !== 'undefined' ? self :
        typeof window !== 'undefined' ? window :
            global;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend(obj, extension) {
        if (typeof extension !== 'object')
            return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function')
            extension = extension(getProto(proto));
        keys(extension).forEach(function (key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
            { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function (Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b)
            throw new Error("Assertion Failed");
    }
    function asap(fn) {
        if (_global.setImmediate)
            setImmediate(fn);
        else
            setTimeout(fn, 0);
    }

    function arrayToObject(array, extractor) {
        return array.reduce(function (result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
                result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }

    function tryCatch(fn, onerror, args) {
        try {
            fn.apply(null, args);
        }
        catch (ex) {
            onerror && onerror(ex);
        }
    }
    function getByKeyPath(obj, keyPath) {
        if (hasOwn(obj, keyPath))
            return obj[keyPath];
        if (!keyPath)
            return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined)
            return;
        if ('isFrozen' in Object && Object.isFrozen(obj))
            return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        }
        else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "")
                    if (value === undefined) {
                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                            obj.splice(currentKeyPath, 1);
                        else
                            delete obj[currentKeyPath];
                    }
                    else
                        obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj)
                        innerObj = (obj[currentKeyPath] = {});
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            }
            else {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(keyPath)))
                        obj.splice(keyPath, 1);
                    else
                        delete obj[keyPath];
                }
                else
                    obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string')
            setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath)
            [].map.call(keyPath, function (kp) {
                setByKeyPath(obj, kp, undefined);
            });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn(obj, m))
                rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    var intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set"
        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return ["Int", "Uint", "Float"].map(function (t) { return t + num + "Array"; }); }))).filter(function (t) { return _global[t]; });
    var intrinsicTypes = intrinsicTypeNames.map(function (t) { return _global[t]; });
    var intrinsicTypeNameSet = arrayToObject(intrinsicTypeNames, function (x) { return [x, true]; });
    function deepClone(any) {
        if (!any || typeof any !== 'object')
            return any;
        var rv;
        if (isArray(any)) {
            rv = [];
            for (var i = 0, l = any.length; i < l; ++i) {
                rv.push(deepClone(any[i]));
            }
        }
        else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
            rv = any;
        }
        else {
            rv = any.constructor ? Object.create(any.constructor.prototype) : {};
            for (var prop in any) {
                if (hasOwn(any, prop)) {
                    rv[prop] = deepClone(any[prop]);
                }
            }
        }
        return rv;
    }
    var toString = {}.toString;
    function toStringTag(o) {
        return toString.call(o).slice(8, -1);
    }
    var getValueOf = function (val, type) {
        return type === "Array" ? '' + val.map(function (v) { return getValueOf(v, toStringTag(v)); }) :
            type === "ArrayBuffer" ? '' + new Uint8Array(val) :
                type === "Date" ? val.getTime() :
                    ArrayBuffer.isView(val) ? '' + new Uint8Array(val.buffer) :
                        val;
    };
    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function (prop) {
            if (!hasOwn(b, prop))
                rv[prfx + prop] = undefined;
            else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    var apTypeName = toStringTag(ap);
                    var bpTypeName = toStringTag(bp);
                    if (apTypeName === bpTypeName) {
                        if (intrinsicTypeNameSet[apTypeName]) {
                            if (getValueOf(ap, apTypeName) !== getValueOf(bp, bpTypeName)) {
                                rv[prfx + prop] = b[prop];
                            }
                        }
                        else {
                            getObjectDiff(ap, bp, rv, prfx + prop + ".");
                        }
                    }
                    else {
                        rv[prfx + prop] = b[prop];
                    }
                }
                else if (ap !== bp)
                    rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach(function (prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }
    var iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;
    var getIteratorOf = iteratorSymbol ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () { return null; };
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike))
                return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                return [arrayLike];
            if ((it = getIteratorOf(arrayLike))) {
                a = [];
                while (x = it.next(), !x.done)
                    a.push(x.value);
                return a;
            }
            if (arrayLike == null)
                return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--)
                    a[i] = arrayLike[i];
                return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
            a[i] = arguments[i];
        return a;
    }
    var isAsyncFunction = typeof Symbol !== 'undefined'
        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }
        : function () { return false; };

    var debug = typeof location !== 'undefined' &&
        /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
        libraryFilter = filter;
    }
    var libraryFilter = function () { return true; };
    var NEEDS_THROW_FOR_STACK = !new Error("").stack;
    function getErrorWithStack() {
        if (NEEDS_THROW_FOR_STACK)
            try {
                throw new Error();
            }
            catch (e) {
                return e;
            }
        return new Error();
    }
    function prettyStack(exception, numIgnoredFrames) {
        var stack = exception.stack;
        if (!stack)
            return "";
        numIgnoredFrames = (numIgnoredFrames || 0);
        if (stack.indexOf(exception.name) === 0)
            numIgnoredFrames += (exception.name + exception.message).split('\n').length;
        return stack.split('\n')
            .slice(numIgnoredFrames)
            .filter(libraryFilter)
            .map(function (frame) { return "\n" + frame; })
            .join('');
    }

    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed"
    };
    function DexieError(name, msg) {
        this._e = getErrorWithStack();
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        stack: {
            get: function () {
                return this._stack ||
                    (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
            }
        },
        toString: function () { return this.name + ": " + this.message; }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures)
            .map(function (key) { return failures[key].toString(); })
            .filter(function (v, i, s) { return s.indexOf(v) === i; })
            .join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this._e = getErrorWithStack();
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this._e = getErrorWithStack();
        this.name = "BulkError";
        this.failures = failures;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + "Error", obj); }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function (obj, name) {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this._e = getErrorWithStack();
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            }
            else if (typeof msgOrInner === 'string') {
                this.message = "" + msgOrInner + (!inner ? '' : '\n ' + inner);
                this.inner = inner || null;
            }
            else if (typeof msgOrInner === 'object') {
                this.message = msgOrInner.name + " " + msgOrInner.message;
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", { get: function () {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function (obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() { }
    function mirror(val) { return val; }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
            return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined)
                arguments[0] = res;
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ?
                (res2 === undefined ? undefined : res2) :
                (extend(res, res2));
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            if (f2.apply(this, arguments) === false)
                return false;
            return f1.apply(this, arguments);
        };
    }

    function promisableChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while (i--)
                    args[i] = arguments[i];
                return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    var INTERNAL = {};
    var LONG_STACKS_CLIP_LIMIT = 100;
    var MAX_LONG_STACKS = 20;
    var ZONE_ECHO_LIMIT = 100;
    var _a = typeof Promise === 'undefined' ?
        [] :
        (function () {
            var globalP = Promise.resolve();
            if (typeof crypto === 'undefined' || !crypto.subtle)
                return [globalP, globalP.__proto__, globalP];
            var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
            return [
                nativeP,
                nativeP.__proto__,
                globalP
            ];
        })();
    var resolvedNativePromise = _a[0];
    var nativePromiseProto = _a[1];
    var resolvedGlobalPromise = _a[2];
    var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    var stack_being_generated = false;
    var schedulePhysicalTick = resolvedGlobalPromise ?
        function () { resolvedGlobalPromise.then(physicalTick); }
        :
            _global.setImmediate ?
                setImmediate.bind(null, physicalTick) :
                _global.MutationObserver ?
                    function () {
                        var hiddenDiv = document.createElement("div");
                        (new MutationObserver(function () {
                            physicalTick();
                            hiddenDiv = null;
                        })).observe(hiddenDiv, { attributes: true });
                        hiddenDiv.setAttribute('i', '1');
                    } :
                    function () { setTimeout(physicalTick, 0); };
    var asap$1 = function (callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true;
    var needsNewPhysicalTick = true;
    var unhandledErrors = [];
    var rejectingErrors = [];
    var currentFulfiller = null;
    var rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: globalError,
        pgp: false,
        env: {},
        finalize: function () {
            this.unhandleds.forEach(function (uh) {
                try {
                    globalError(uh[0], uh[1]);
                }
                catch (e) { }
            });
        }
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this.onuncatched = nop;
        this._lib = false;
        var psd = (this._PSD = PSD);
        if (debug) {
            this._stackHolder = getErrorWithStack();
            this._prev = null;
            this._numPrev = 0;
        }
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL)
                throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
                handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    var thenProp = {
        get: function () {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                var cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise(function (resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                debug && linkToPreviousPromise(rv, this);
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function (value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ?
                thenProp :
                {
                    get: function () {
                        return value;
                    },
                    set: thenProp.set
                });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function (onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function (onRejected) {
            if (arguments.length === 1)
                return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function (err) {
                return err instanceof type ? handler(err) : PromiseReject(err);
            })
                : this.then(null, function (err) {
                    return err && err.name === type ? handler(err) : PromiseReject(err);
                });
        },
        finally: function (onFinally) {
            return this.then(function (value) {
                onFinally();
                return value;
            }, function (err) {
                onFinally();
                return PromiseReject(err);
            });
        },
        stack: {
            get: function () {
                if (this._stack)
                    return this._stack;
                try {
                    stack_being_generated = true;
                    var stacks = getStack(this, [], MAX_LONG_STACKS);
                    var stack = stacks.join("\nFrom previous: ");
                    if (this._state !== null)
                        this._stack = stack;
                    return stack;
                }
                finally {
                    stack_being_generated = false;
                }
            }
        },
        timeout: function (ms, msg) {
            var _this = this;
            return ms < Infinity ?
                new DexiePromise(function (resolve, reject) {
                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);
                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function () {
            var values = getArrayOf.apply(null, arguments)
                .map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                if (values.length === 0)
                    resolve([]);
                var remaining = values.length;
                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {
                    values[i] = x;
                    if (!--remaining)
                        resolve(values);
                }, reject); });
            });
        },
        resolve: function (value) {
            if (value instanceof DexiePromise)
                return value;
            if (value && typeof value.then === 'function')
                return new DexiePromise(function (resolve, reject) {
                    value.then(resolve, reject);
                });
            var rv = new DexiePromise(INTERNAL, true, value);
            linkToPreviousPromise(rv, currentFulfiller);
            return rv;
        },
        reject: PromiseReject,
        race: function () {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });
            });
        },
        PSD: {
            get: function () { return PSD; },
            set: function (value) { return PSD = value; }
        },
        totalEchoes: { get: function () { return totalEchoes; } },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function () { return asap$1; },
            set: function (value) { asap$1 = value; }
        },
        rejectionMapper: {
            get: function () { return rejectionMapper; },
            set: function (value) { rejectionMapper = value; }
        },
        follow: function (fn, zoneProps) {
            return new DexiePromise(function (resolve, reject) {
                return newScope(function (resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function () {
                        var _this = this;
                        run_at_end_of_this_or_next_physical_tick(function () {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve) {
                    if (possiblePromises.length === 0)
                        resolve([]);
                    var remaining = possiblePromises.length;
                    var results = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: "fulfilled", value: value }; }, function (reason) { return results[i] = { status: "rejected", reason: reason }; })
                        .then(function () { return --remaining || resolve(results); }); });
                });
            });
        if (NativePromise.any && typeof AggregateError !== 'undefined')
            setProp(DexiePromise, "any", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve, reject) {
                    if (possiblePromises.length === 0)
                        reject(new AggregateError([]));
                    var remaining = possiblePromises.length;
                    var failures = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {
                        failures[i] = failure;
                        if (!--remaining)
                            reject(new AggregateError(failures));
                    }); });
                });
            });
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(function (value) {
                if (promise._state !== null)
                    return;
                if (value === promise)
                    throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function (resolve, reject) {
                        value instanceof DexiePromise ?
                            value._then(resolve, reject) :
                            value.then(resolve, reject);
                    });
                }
                else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick)
                    endMicroTickScope();
            }, handleRejection.bind(null, promise));
        }
        catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
            return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {
            var origProp = getPropertyDescriptor(reason, "stack");
            reason._promise = promise;
            setProp(reason, "stack", {
                get: function () {
                    return stack_being_generated ?
                        origProp && (origProp.get ?
                            origProp.get.apply(reason) :
                            origProp.value) :
                        promise.stack;
                }
            });
        });
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
            endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap$1(function () {
                if (--numScheduledCalls === 0)
                    finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap$1(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            currentFulfiller = promise;
            var ret, value = promise._value;
            if (promise._state) {
                ret = cb(value);
            }
            else {
                if (rejectingErrors.length)
                    rejectingErrors = [];
                ret = cb(value);
                if (rejectingErrors.indexOf(value) === -1)
                    markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        }
        catch (e) {
            listener.reject(e);
        }
        finally {
            currentFulfiller = null;
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function getStack(promise, stacks, limit) {
        if (stacks.length === limit)
            return stacks;
        var stack = "";
        if (promise._state === false) {
            var failure = promise._value, errorName, message;
            if (failure != null) {
                errorName = failure.name || "Error";
                message = failure.message || failure;
                stack = prettyStack(failure, 0);
            }
            else {
                errorName = failure;
                message = "";
            }
            stacks.push(errorName + (message ? ": " + message : "") + stack);
        }
        if (debug) {
            stack = prettyStack(promise._stackHolder, 2);
            if (stack && stacks.indexOf(stack) === -1)
                stacks.push(stack);
            if (promise._prev)
                getStack(promise._prev, stacks, limit);
        }
        return stacks;
    }
    function linkToPreviousPromise(promise, prev) {
        var numPrev = prev ? prev._numPrev + 1 : 0;
        if (numPrev < LONG_STACKS_CLIP_LIMIT) {
            promise._prev = prev;
            promise._numPrev = numPrev;
        }
    }
    function physicalTick() {
        beginMicroTickScope() && endMicroTickScope();
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function (p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
            finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap$1(function () {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))
            unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
            if (unhandledErrors[--i]._value === promise._value) {
                unhandledErrors.splice(i, 1);
                return;
            }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            }
            catch (e) {
                errorCatcher && errorCatcher(e);
            }
            finally {
                switchToZone(outerScope, false);
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
    }
    var task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props$$1, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        var globalEnv = globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject,
            nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
            gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
        } : {};
        if (props$$1)
            extend(psd, props$$1);
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
            psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id)
            task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits)
            return false;
        if (--task.awaits === 0)
            task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function (x) {
                decrementExpectedAwaits();
                return x;
            }, function (e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
            return;
        PSD = targetZone;
        if (currentZone === globalPSD)
            globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise_1 = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            nativePromiseProto.then = targetEnv.nthen;
            GlobalPromise_1.prototype.then = targetEnv.gthen;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise_1.all = targetEnv.all;
                GlobalPromise_1.race = targetEnv.race;
                GlobalPromise_1.resolve = targetEnv.resolve;
                GlobalPromise_1.reject = targetEnv.reject;
                if (targetEnv.allSettled)
                    GlobalPromise_1.allSettled = targetEnv.allSettled;
                if (targetEnv.any)
                    GlobalPromise_1.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
            nthen: nativePromiseProto.then,
            gthen: GlobalPromise.prototype.then
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        }
        finally {
            switchToZone(outerScope, false);
        }
    }
    function enqueueNativeMicroTask(job) {
        nativePromiseThen.call(resolvedNativePromise, job);
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait)
                incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                switchToZone(outerZone, false);
                if (cleanup)
                    enqueueNativeMicroTask(decrementExpectedAwaits);
            }
        };
    }
    function getPatchedPromiseThen(origThen, zone) {
        return function (onResolved, onRejected) {
            return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
        };
    }
    var UNHANDLEDREJECTION = "unhandledrejection";
    function globalError(err, promise) {
        var rv;
        try {
            rv = promise.onuncatched(err);
        }
        catch (e) { }
        if (rv !== false)
            try {
                var event, eventData = { promise: promise, reason: err };
                if (_global.document && document.createEvent) {
                    event = document.createEvent('Event');
                    event.initEvent(UNHANDLEDREJECTION, true, true);
                    extend(event, eventData);
                }
                else if (_global.CustomEvent) {
                    event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
                    extend(event, eventData);
                }
                if (event && _global.dispatchEvent) {
                    dispatchEvent(event);
                    if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                        try {
                            _global.onunhandledrejection(event);
                        }
                        catch (_) { }
                }
                if (debug && event && !event.defaultPrevented) {
                    console.warn("Unhandled rejection: " + (err.stack || err));
                }
            }
            catch (e) { }
    }
    var rejection = DexiePromise.reject;

    function tempTransaction(db, mode, storeNames, fn) {
        if (!db._state.openComplete && (!PSD.letThrough)) {
            if (!db._state.isBeingOpened) {
                if (!db._options.autoOpen)
                    return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });
        }
        else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
            }
            catch (ex) {
                return rejection(ex);
            }
            return trans._promise(mode, function (resolve, reject) {
                return newScope(function () {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(function (result) {
                return trans._completion.then(function () { return result; });
            });
        }
    }

    var DEXIE_VERSION = '3.0.3';
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
    var hasIEDeleteObjectStoreBug = isIEOrEdge;
    var hangsOnDeleteLargeKeyRange = isIEOrEdge;
    var dexieStackFrameFilter = function (frame) { return !/(dexie\.js|dexie\.min\.js)/.test(frame); };
    var DBNAMES_DB = '__dbnames';
    var READONLY = 'readonly';
    var READWRITE = 'readwrite';

    function combine(filter1, filter2) {
        return filter1 ?
            filter2 ?
                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                filter1 :
            filter2;
    }

    var AnyRange = {
        type: 3          ,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
    };

    function workaroundForUndefinedPrimKey(keyPath) {
        return function (obj) {
            if (getByKeyPath(obj, keyPath) === undefined) {
                obj = deepClone(obj);
                delByKeyPath(obj, keyPath);
            }
            return obj;
        };
    }

    var Table =               (function () {
        function Table() {
        }
        Table.prototype._trans = function (mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName])
                    throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            var wasRootExec = beginMicroTickScope();
            try {
                return trans && trans.db === this.db ?
                    trans === PSD.trans ?
                        trans._promise(mode, checkTableInTransaction, writeLocked) :
                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :
                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            }
            finally {
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
        Table.prototype.get = function (keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
                return this.where(keyOrCrit).first(cb);
            return this._trans('readonly', function (trans) {
                return _this.core.get({ trans: trans, key: keyOrCrit })
                    .then(function (res) { return _this.hook.reading.fire(res); });
            }).then(cb);
        };
        Table.prototype.where = function (indexOrCrit) {
            if (typeof indexOrCrit === 'string')
                return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit))
                return new this.db.WhereClause(this, "[" + indexOrCrit.join('+') + "]");
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
                return this
                    .where(keyPaths[0])
                    .equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                return ix.compound &&
                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; }) &&
                    ix.keyPath.every(function (keyPath) { return keyPaths.indexOf(keyPath) >= 0; });
            })[0];
            if (compoundIndex && this.db._maxKey !== maxString)
                return this
                    .where(compoundIndex.name)
                    .equals(compoundIndex.keyPath.map(function (kp) { return indexOrCrit[kp]; }));
            if (!compoundIndex && debug)
                console.warn("The query " + JSON.stringify(indexOrCrit) + " on " + this.name + " would benefit of a " +
                    ("compound index [" + keyPaths.join('+') + "]"));
            var idxByName = this.schema.idxByName;
            var idb = this.db._deps.indexedDB;
            function equals(a, b) {
                try {
                    return idb.cmp(a, b) === 0;
                }
                catch (e) {
                    return false;
                }
            }
            var _a = keyPaths.reduce(function (_a, keyPath) {
                var prevIndex = _a[0], prevFilterFn = _a[1];
                var index = idxByName[keyPath];
                var value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ?
                        combine(prevFilterFn, index && index.multi ?
                            function (x) {
                                var prop = getByKeyPath(x, keyPath);
                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });
                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })
                        : prevFilterFn
                ];
            }, [null, null]), idx = _a[0], filterFunction = _a[1];
            return idx ?
                this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                    .filter(filterFunction) :
                compoundIndex ?
                    this.filter(filterFunction) :
                    this.where(keyPaths).equals('');
        };
        Table.prototype.filter = function (filterFunction) {
            return this.toCollection().and(filterFunction);
        };
        Table.prototype.count = function (thenShortcut) {
            return this.toCollection().count(thenShortcut);
        };
        Table.prototype.offset = function (offset) {
            return this.toCollection().offset(offset);
        };
        Table.prototype.limit = function (numRows) {
            return this.toCollection().limit(numRows);
        };
        Table.prototype.each = function (callback) {
            return this.toCollection().each(callback);
        };
        Table.prototype.toArray = function (thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        };
        Table.prototype.toCollection = function () {
            return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table.prototype.orderBy = function (index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
                "[" + index.join('+') + "]" :
                index));
        };
        Table.prototype.reverse = function () {
            return this.toCollection().reverse();
        };
        Table.prototype.mapToClass = function (constructor) {
            this.schema.mappedClass = constructor;
            var readHook = function (obj) {
                if (!obj)
                    return obj;
                var res = Object.create(constructor.prototype);
                for (var m in obj)
                    if (hasOwn(obj, m))
                        try {
                            res[m] = obj[m];
                        }
                        catch (_) { }
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        };
        Table.prototype.defineClass = function () {
            function Class(content) {
                extend(this, content);
            }
            
            return this.mapToClass(Class);
        };
        Table.prototype.add = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                    
                }
                return lastResult;
            });
        };
        Table.prototype.update = function (keyOrObject, modifications) {
            if (typeof modifications !== 'object' || isArray(modifications))
                throw new exceptions.InvalidArgument("Modifications must be an object.");
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                keys(modifications).forEach(function (keyPath) {
                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                });
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined)
                    return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                return this.where(":id").equals(key).modify(modifications);
            }
            else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        };
        Table.prototype.put = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                    
                }
                return lastResult;
            });
        };
        Table.prototype.delete = function (key) {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.clear = function () {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.bulkGet = function (keys$$1) {
            var _this = this;
            return this._trans('readonly', function (trans) {
                return _this.core.getMany({
                    keys: keys$$1,
                    trans: trans
                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });
            });
        };
        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys$$1 = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys$$1 ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys$$1)
                    throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys$$1 && keys$$1.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToAdd = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'add', keys: keys$$1, values: objectsToAdd, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(_this.name + ".bulkAdd(): " + numFailures + " of " + numObjects + " operations failed", Object.keys(failures).map(function (pos) { return failures[pos]; }));
                });
            });
        };
        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys$$1 = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys$$1 ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys$$1)
                    throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys$$1 && keys$$1.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToPut = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'put', keys: keys$$1, values: objectsToPut, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(_this.name + ".bulkPut(): " + numFailures + " of " + numObjects + " operations failed", Object.keys(failures).map(function (pos) { return failures[pos]; }));
                });
            });
        };
        Table.prototype.bulkDelete = function (keys$$1) {
            var _this = this;
            var numKeys = keys$$1.length;
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys$$1 });
            }).then(function (_a) {
                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                if (numFailures === 0)
                    return lastResult;
                throw new BulkError(_this.name + ".bulkDelete(): " + numFailures + " of " + numKeys + " operations failed", failures);
            });
        };
        return Table;
    }());

    function Events(ctx) {
        var evs = {};
        var rv = function (eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            }
            else if (typeof (eventName) === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object')
                return addConfiguredEvents(eventName);
            if (!chainFunction)
                chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
                defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function (cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function (cb) {
                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                }
                else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        context.subscribers.forEach(function (fn) {
                            asap(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                }
                else
                    throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype: prototype });
        return constructor;
    }

    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table$$1(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        });
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) &&
            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
            return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans: trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index: index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        }
        else {
            var set_1 = {};
            var union = function (item, cursor, advance) {
                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]')
                        key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn(set_1, key)) {
                        set_1[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function (cursor) {
            if (cursor) {
                return cursor.start(function () {
                    var c = function () { return cursor.continue(); };
                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))
                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });
                    c();
                });
            }
        });
    }

    var Collection =               (function () {
        function Collection() {
        }
        Collection.prototype._read = function (fn, cb) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readonly', fn).then(cb);
        };
        Collection.prototype._write = function (fn) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readwrite', fn, "locked");
        };
        Collection.prototype._addAlgorithm = function (fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection.prototype._iterate = function (fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection.prototype.clone = function (props$$1) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props$$1)
                extend(ctx, props$$1);
            rv._ctx = ctx;
            return rv;
        };
        Collection.prototype.raw = function () {
            this._ctx.valueMapper = null;
            return this;
        };
        Collection.prototype.each = function (fn) {
            var ctx = this._ctx;
            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });
        };
        Collection.prototype.count = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                var coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans: trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(function (count) { return Math.min(count, ctx.limit); });
                }
                else {
                    var count = 0;
                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)
                        .then(function () { return count; });
                }
            }).then(cb);
        };
        Collection.prototype.sortBy = function (keyPath, cb) {
            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i)
                    return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return aVal < bVal ? -order : aVal > bVal ? order : 0;
            }
            return this.toArray(function (a) {
                return a.sort(sorter);
            }).then(cb);
        };
        Collection.prototype.toArray = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    var valueMapper_1 = ctx.valueMapper;
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    }).then(function (_a) {
                        var result = _a.result;
                        return valueMapper_1 ? result.map(valueMapper_1) : result;
                    });
                }
                else {
                    var a_1 = [];
                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });
                }
            }, cb);
        };
        Collection.prototype.offset = function (offset) {
            var ctx = this._ctx;
            if (offset <= 0)
                return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function (cursor, advance) {
                        if (offsetLeft === 0)
                            return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(function () {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            }
            else {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function () { return (--offsetLeft < 0); };
                });
            }
            return this;
        };
        Collection.prototype.limit = function (numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function () {
                var rowsLeft = numRows;
                return function (cursor, advance, resolve) {
                    if (--rowsLeft <= 0)
                        advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        };
        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function (cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                }
                else {
                    return true;
                }
            });
            return this;
        };
        Collection.prototype.first = function (cb) {
            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.last = function (cb) {
            return this.reverse().first(cb);
        };
        Collection.prototype.filter = function (filterFunction) {
            addFilter(this._ctx, function (cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        };
        Collection.prototype.and = function (filter) {
            return this.filter(filter);
        };
        Collection.prototype.or = function (indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection.prototype.reverse = function () {
            this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
            if (this._ondirectionchange)
                this._ondirectionchange(this._ctx.dir);
            return this;
        };
        Collection.prototype.desc = function () {
            return this.reverse();
        };
        Collection.prototype.eachKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.key, cursor); });
        };
        Collection.prototype.eachUniqueKey = function (cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        };
        Collection.prototype.eachPrimaryKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
        };
        Collection.prototype.keys = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.key);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.primaryKeys = function (cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(function (trans) {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    });
                }).then(function (_a) {
                    var result = _a.result;
                    return result;
                }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.uniqueKeys = function (cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        };
        Collection.prototype.firstKey = function (cb) {
            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.lastKey = function (cb) {
            return this.reverse().firstKey(cb);
        };
        Collection.prototype.distinct = function () {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
                return this;
            var set = {};
            addFilter(this._ctx, function (cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        };
        Collection.prototype.modify = function (changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function (trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                }
                else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i], val = changes[keyPath];
                            if (getByKeyPath(item, keyPath) !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                var coreTable = ctx.table.core;
                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                var limit = 'testmode' in Dexie ? 1 : 2000;
                var cmp = _this.db.core.cmp;
                var totalFailures = [];
                var successCount = 0;
                var failedKeys = [];
                var applyMutateResult = function (expectedCount, res) {
                    var failures = res.failures, numFailures = res.numFailures;
                    successCount += expectedCount - numFailures;
                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
                        var pos = _a[_i];
                        totalFailures.push(failures[pos]);
                    }
                };
                return _this.clone().primaryKeys().then(function (keys$$1) {
                    var nextChunk = function (offset) {
                        var count = Math.min(limit, keys$$1.length - offset);
                        return coreTable.getMany({ trans: trans, keys: keys$$1.slice(offset, offset + count) }).then(function (values) {
                            var addValues = [];
                            var putValues = [];
                            var putKeys = outbound ? [] : null;
                            var deleteKeys = [];
                            for (var i = 0; i < count; ++i) {
                                var origValue = values[i];
                                var ctx_1 = {
                                    value: deepClone(origValue),
                                    primKey: keys$$1[offset + i]
                                };
                                if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                    if (ctx_1.value == null) {
                                        deleteKeys.push(keys$$1[offset + i]);
                                    }
                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                        deleteKeys.push(keys$$1[offset + i]);
                                        addValues.push(ctx_1.value);
                                    }
                                    else {
                                        putValues.push(ctx_1.value);
                                        if (outbound)
                                            putKeys.push(keys$$1[offset + i]);
                                    }
                                }
                            }
                            return Promise.resolve(addValues.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })
                                    .then(function (res) {
                                    for (var pos in res.failures) {
                                        deleteKeys.splice(parseInt(pos), 1);
                                    }
                                    applyMutateResult(addValues.length, res);
                                })).then(function (res) { return putValues.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'put', keys: putKeys, values: putValues })
                                    .then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return deleteKeys.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'delete', keys: deleteKeys })
                                    .then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {
                                return keys$$1.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(function () {
                        if (totalFailures.length > 0)
                            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys$$1.length;
                    });
                });
            });
        };
        Collection.prototype.delete = function () {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) &&
                ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3          ))
             {
                return this._write(function (trans) {
                    var primaryKey = ctx.table.core.schema.primaryKey;
                    var coreRange = range;
                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {
                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })
                            .then(function (_a) {
                            var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;
                            if (numFailures)
                                throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(function (value, ctx) { return ctx.value = null; });
        };
        return Collection;
    }());

    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection$$1(whereClause, keyRangeGenerator) {
            this.db = db;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
                try {
                    keyRange = keyRangeGenerator();
                }
                catch (ex) {
                    error = ex;
                }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ?
            new collectionOrWhereClause.Collection(collectionOrWhereClause) :
            collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function () { return rangeEqual(""); }).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toUpperCase(); } :
            function (s) { return s.toLowerCase(); };
    }
    function lowerFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toLowerCase(); } :
            function (s) { return s.toUpperCase(); };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0)
                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0)
                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0)
                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0)
                llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function (s) { return typeof s === 'string'; })) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
            var needleBounds = needles.map(function (needle) {
                return { lower: lower(needle), upper: upper(needle) };
            }).sort(function (a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
            direction = dir;
            nextKeySuffix = (dir === "next" ? "" : suffix);
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });
        c._ondirectionchange = function (direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function (cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string')
                return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            }
            else {
                var lowestPossibleCasing = null;
                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null)
                        firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                }
                else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2            ,
            lower: lower,
            upper: upper,
            lowerOpen: lowerOpen,
            upperOpen: upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1            ,
            lower: value,
            upper: value
        };
    }

    var WhereClause =               (function () {
        function WhereClause() {
        }
        Object.defineProperty(WhereClause.prototype, "Collection", {
            get: function () {
                return this._ctx.table.db.Collection;
            },
            enumerable: true,
            configurable: true
        });
        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if ((this._cmp(lower, upper) > 0) ||
                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                    return emptyCollection(this);
                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        };
        WhereClause.prototype.equals = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return rangeEqual(value); });
        };
        WhereClause.prototype.above = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, true); });
        };
        WhereClause.prototype.aboveOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, false); });
        };
        WhereClause.prototype.below = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });
        };
        WhereClause.prototype.belowOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value); });
        };
        WhereClause.prototype.startsWith = function (str) {
            if (typeof str !== 'string')
                return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        };
        WhereClause.prototype.startsWithIgnoreCase = function (str) {
            if (str === "")
                return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);
        };
        WhereClause.prototype.equalsIgnoreCase = function (str) {
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], "");
        };
        WhereClause.prototype.anyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, "");
        };
        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);
        };
        WhereClause.prototype.anyOf = function () {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
                set.sort(compare);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
                return emptyCollection(this);
            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });
            c._ondirectionchange = function (direction) {
                compare = (direction === "next" ?
                    _this._ascending :
                    _this._descending);
                set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (compare(key, set[i]) > 0) {
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                }
                else {
                    advance(function () { cursor.continue(set[i]); });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.notEqual = function (value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.noneOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return new this.Collection(this);
            try {
                set.sort(this._ascending);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function (res, val) { return res ?
                res.concat([[res[res.length - 1][1], val]]) :
                [[minKey, val]]; }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.inAnyRange = function (ranges, options) {
            var _this = this;
            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
                return emptyCollection(this);
            if (!ranges.every(function (range) {
                return range[0] !== undefined &&
                    range[1] !== undefined &&
                    ascending(range[0], range[1]) <= 0;
            })) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                var i = 0, l = ranges.length;
                for (; i < l; ++i) {
                    var range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l)
                    ranges.push(newRange);
                return ranges;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
            var set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            }
            catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ?
                function (key) { return ascending(key, set[rangePos][1]) > 0; } :
                function (key) { return ascending(key, set[rangePos][1]) >= 0; };
            var keyIsBeforeCurrentEntry = includeLowers ?
                function (key) { return descending(key, set[rangePos][0]) > 0; } :
                function (key) { return descending(key, set[rangePos][0]) >= 0; };
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });
            c._ondirectionchange = function (direction) {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                }
                else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (checkKey(key)) {
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                }
                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                }
                else {
                    advance(function () {
                        if (sortDirection === ascending)
                            cursor.continue(set[rangePos][0]);
                        else
                            cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.startsWithAnyOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function (s) { return typeof s === 'string'; })) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
                return emptyCollection(this);
            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));
        };
        return WhereClause;
    }());

    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause$$1(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            var indexedDB = db._deps.indexedDB;
            if (!indexedDB)
                throw new exceptions.MissingAPI("indexedDB API missing");
            this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);
            this._descending = function (a, b) { return indexedDB.cmp(b, a); };
            this._max = function (a, b) { return indexedDB.cmp(a, b) > 0 ? a : b; };
            this._min = function (a, b) { return indexedDB.cmp(a, b) < 0 ? a : b; };
            this._IDBKeyRange = db._deps.IDBKeyRange;
        });
    }

    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }

    function getMaxKey(IdbKeyRange) {
        try {
            IdbKeyRange.only([[]]);
            return [[]];
        }
        catch (e) {
            return maxString;
        }
    }

    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }



    function preventDefault(event) {
        if (event.stopPropagation)
            event.stopPropagation();
        if (event.preventDefault)
            event.preventDefault();
    }

    var Transaction =               (function () {
        function Transaction() {
        }
        Transaction.prototype._lock = function () {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
                PSD.lockOwnerFor = this;
            return this;
        };
        Transaction.prototype._unlock = function () {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global)
                    PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    }
                    catch (e) { }
                }
            }
            return this;
        };
        Transaction.prototype._locked = function () {
            return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction.prototype.create = function (idbtrans) {
            var _this = this;
            if (!this.mode)
                return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active)
                throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);
            idbtrans.onerror = wrap(function (ev) {
                preventDefault(ev);
                _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function (ev) {
                preventDefault(ev);
                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                _this.active = false;
                _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function () {
                _this.active = false;
                _this._resolve();
            });
            return this;
        };
        Transaction.prototype._promise = function (mode, fn, bWriteLock) {
            var _this = this;
            if (mode === 'readwrite' && this.mode !== 'readwrite')
                return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
                return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise(function (resolve, reject) {
                    _this._blockedFuncs.push([function () {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                });
            }
            else if (bWriteLock) {
                return newScope(function () {
                    var p = new DexiePromise(function (resolve, reject) {
                        _this._lock();
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then)
                            rv.then(resolve, reject);
                    });
                    p.finally(function () { return _this._unlock(); });
                    p._lib = true;
                    return p;
                });
            }
            else {
                var p = new DexiePromise(function (resolve, reject) {
                    var rv = fn(resolve, reject, _this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        };
        Transaction.prototype._root = function () {
            return this.parent ? this.parent._root() : this;
        };
        Transaction.prototype.waitFor = function (promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(function () { return promise; });
            }
            else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while (root._waitingQueue.length)
                        (root._waitingQueue.shift())();
                    if (root._waitingFor)
                        store.get(-Infinity).onsuccess = spin;
                }());
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function (resolve, reject) {
                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        };
        Transaction.prototype.abort = function () {
            this.active && this._reject(new exceptions.Abort());
            this.active = false;
        };
        Transaction.prototype.table = function (tableName) {
            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
            if (hasOwn(memoizedTables, tableName))
                return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        };
        return Transaction;
    }());

    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction$$1(mode, storeNames, dbschema, parent) {
            var _this = this;
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function () {
                _this.active = false;
                _this.on.complete.fire();
            }, function (e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ?
                    _this.parent._reject(e) :
                    wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e);
            });
        });
    }

    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
            name: name,
            keyPath: keyPath,
            unique: unique,
            multi: multi,
            auto: auto,
            compound: compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ?
            keyPath :
            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
    }

    function createTableSchema(name, primKey, indexes) {
        return {
            name: name,
            primKey: primKey,
            indexes: indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })
        };
    }

    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return function () { return undefined; };
        }
        else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split('.');
        if (split.length === 1) {
            return function (obj) { return obj[keyPath]; };
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }

    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete')
            return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === 'add' ? Promise.resolve(new Array(req.values.length)) :
            table.getMany({ trans: req.trans, keys: effectiveKeys });
    }

    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }

    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ?
            ":id" :
            typeof keyPath === 'string' ?
                keyPath :
                "[" + keyPath.join('+') + "]";
    }
    function createDBCore(db, indexedDB, IdbKeyRange, tmpTrans) {
        var cmp = indexedDB.cmp.bind(indexedDB);
        function extractSchema(db, trans) {
            var tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {
                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                        var compound = isArray(keyPath);
                        var outbound = keyPath == null;
                        var indexByKeyPath = {};
                        var result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound: outbound,
                                compound: compound,
                                keyPath: keyPath,
                                autoIncrement: autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })
                                .map(function (index) {
                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                var compound = isArray(keyPath);
                                var result = {
                                    name: name,
                                    compound: compound,
                                    keyPath: keyPath,
                                    unique: unique,
                                    multiEntry: multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3          )
                return null;
            if (range.type === 4            )
                throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === undefined ?
                upper === undefined ?
                    null :
                    IdbKeyRange.upperBound(upper, !!upperOpen) :
                upper === undefined ?
                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a) {
                var trans = _a.trans, type = _a.type, keys$$1 = _a.keys, values = _a.values, range = _a.range, wantResults = _a.wantResults;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var outbound = store.keyPath == null;
                    var isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                        throw new Error("Invalid operation type: " + type);
                    var length = (keys$$1 || values || { length: 1 }).length;
                    if (keys$$1 && values && keys$$1.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0)
                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                    var results = wantResults && __spreadArrays((keys$$1 ?
                        keys$$1 :
                        getEffectiveKeys(tableSchema.primaryKey, { type: type, keys: keys$$1, values: values })));
                    var req;
                    var failures = [];
                    var numFailures = 0;
                    var errorHandler = function (event) {
                        ++numFailures;
                        preventDefault(event);
                        if (results)
                            results[event.target._reqno] = undefined;
                        failures[event.target._reqno] = event.target.error;
                    };
                    var setResult = function (_a) {
                        var target = _a.target;
                        results[target._reqno] = target.result;
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4            )
                            return resolve({ numFailures: numFailures, failures: failures, results: results, lastResult: undefined });
                        if (range.type === 3          )
                            req = store.clear();
                        else
                            req = store.delete(makeIDBKeyRange(range));
                    }
                    else {
                        var _a = isAddOrPut ?
                            outbound ?
                                [values, keys$$1] :
                                [values, null] :
                            [keys$$1, null], args1 = _a[0], args2 = _a[1];
                        if (isAddOrPut) {
                            for (var i = 0; i < length; ++i) {
                                req = (args2 && args2[i] !== undefined ?
                                    store[type](args1[i], args2[i]) :
                                    store[type](args1[i]));
                                req._reqno = i;
                                if (results && results[i] === undefined) {
                                    req.onsuccess = setResult;
                                }
                                req.onerror = errorHandler;
                            }
                        }
                        else {
                            for (var i = 0; i < length; ++i) {
                                req = store[type](args1[i]);
                                req._reqno = i;
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    var done = function (event) {
                        var lastResult = event.target.result;
                        if (results)
                            results[length - 1] = lastResult;
                        resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: results,
                            lastResult: lastResult
                        });
                    };
                    req.onerror = function (event) {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor(_a) {
                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ?
                        store :
                        store.index(index.name);
                    var direction = reverse ?
                        unique ?
                            "prevunique" :
                            "prev" :
                        unique ?
                            "nextunique" :
                            "next";
                    var req = values || !('openKeyCursor' in source) ?
                        source.openCursor(makeIDBKeyRange(range), direction) :
                        source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function (ev) {
                        var cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        var _cursorContinue = cursor.continue.bind(cursor);
                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey)
                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        var _cursorAdvance = cursor.advance.bind(cursor);
                        var doThrowCursorIsNotStarted = function () { throw new Error("Cursor not started"); };
                        var doThrowCursorIsStopped = function () { throw new Error("Cursor not stopped"); };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function () {
                            var _this = this;
                            var gotOne = 1;
                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });
                        };
                        cursor.start = function (callback) {
                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = function (value) {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            var guardedCallback = function () {
                                if (req.result) {
                                    try {
                                        callback();
                                    }
                                    catch (err) {
                                        cursor.fail(err);
                                    }
                                }
                                else {
                                    cursor.done = true;
                                    cursor.start = function () { throw new Error("Cursor behind last entry"); };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(function (ev) {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return function (request) {
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                        var nonInfinitLimit = limit === Infinity ? undefined : limit;
                        var index = query.index, range = query.range;
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0)
                            return resolve({ result: [] });
                        if (hasGetAll) {
                            var req = values ?
                                source.getAll(idbKeyRange, nonInfinitLimit) :
                                source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };
                            req.onerror = eventRejectHandler(reject);
                        }
                        else {
                            var count_1 = 0;
                            var req_1 = values || !('openKeyCursor' in source) ?
                                source.openCursor(idbKeyRange) :
                                source.openKeyCursor(idbKeyRange);
                            var result_1 = [];
                            req_1.onsuccess = function (event) {
                                var cursor = req_1.result;
                                if (!cursor)
                                    return resolve({ result: result_1 });
                                result_1.push(values ? cursor.value : cursor.primaryKey);
                                if (++count_1 === limit)
                                    return resolve({ result: result_1 });
                                cursor.continue();
                            };
                            req_1.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate: mutate,
                getMany: function (_a) {
                    var trans = _a.trans, keys$$1 = _a.keys;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var length = keys$$1.length;
                        var result = new Array(length);
                        var keyCount = 0;
                        var callbackCount = 0;
                        var req;
                        var successHandler = function (event) {
                            var req = event.target;
                            if ((result[req._pos] = req.result) != null)
                                ;
                            if (++callbackCount === keyCount)
                                resolve(result);
                        };
                        var errorHandler = eventRejectHandler(reject);
                        for (var i = 0; i < length; ++i) {
                            var key = keys$$1[i];
                            if (key != null) {
                                req = store.get(keys$$1[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0)
                            resolve(result);
                    });
                },
                get: function (_a) {
                    var trans = _a.trans, key = _a.key;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var req = store.get(key);
                        req.onsuccess = function (event) { return resolve(event.target.result); };
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor: openCursor,
                count: function (_a) {
                    var query = _a.query, trans = _a.trans;
                    var index = query.index, range = query.range;
                    return new Promise(function (resolve, reject) {
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });
        var tableMap = {};
        tables.forEach(function (table) { return tableMap[table.name] = table; });
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table: function (name) {
                var result = tableMap[name];
                if (!result)
                    throw new Error("Table '" + name + "' not found");
                return tableMap[name];
            },
            cmp: cmp,
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema: schema
        };
    }

    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function (down, _a) {
            var create = _a.create;
            return (__assign(__assign({}, down), create(down)));
        }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
        var IDBKeyRange = _a.IDBKeyRange, indexedDB = _a.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, indexedDB, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore: dbcore
        };
    }
    function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function (table) {
            var tableName = table.name;
            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }

    function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function (tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function (obj) {
                var propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get: function () { return this.table(tableName); },
                            set: function (value) {
                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });
                            }
                        });
                    }
                    else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi(db, objs) {
        objs.forEach(function (obj) {
            for (var key in obj) {
                if (obj[key] instanceof db.Table)
                    delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function () {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(function (tableName) {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);
            }
            else
                updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
        });
    }
    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var anyContentUpgraderHasRun = false;
        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });
        versToRun.forEach(function (version) {
            queue.push(function () {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(function (tuple) {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(function (change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    }
                    else {
                        var store_1 = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });
                        change.change.forEach(function (idx) {
                            store_1.deleteIndex(idx.name);
                            addIndex(store_1, idx);
                        });
                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });
                    }
                });
                var contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    anyContentUpgraderHasRun = true;
                    var upgradeSchema_1 = shallowClone(newSchema);
                    diff.del.forEach(function (table) {
                        upgradeSchema_1[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [db.Transaction.prototype]);
                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                    trans.schema = upgradeSchema_1;
                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync_1) {
                        incrementExpectedAwaits();
                    }
                    var returnValue_1;
                    var promiseFollowed = DexiePromise.follow(function () {
                        returnValue_1 = contentUpgrade(trans);
                        if (returnValue_1) {
                            if (contentUpgradeIsAsync_1) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue_1.then(decrementor, decrementor);
                            }
                        }
                    });
                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?
                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));
                }
            });
            queue.push(function (idbtrans) {
                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                    var newSchema = version._cfg.dbschema;
                    deleteRemovedTables(newSchema, idbtrans);
                }
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                DexiePromise.resolve();
        }
        return runQueue().then(function () {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [],
            add: [],
            change: []
        };
        var table;
        for (table in oldSchema) {
            if (!newSchema[table])
                diff.del.push(table);
        }
        for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            }
            else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ((
                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                    (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))
                 {
                    change.recreate = true;
                    diff.change.push(change);
                }
                else {
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    var idxName = void 0;
                    for (idxName in oldIndexes) {
                        if (!newIndexes[idxName])
                            change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx)
                            change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src)
                            change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
            { autoIncrement: primKey.auto });
        indexes.forEach(function (idx) { return addIndex(store, idx); });
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function (tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {
            var storeName = idbtrans.db.objectStoreNames[i];
            if (newSchema[storeName] == null) {
                idbtrans.db.deleteObjectStore(storeName);
            }
        }
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function (storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));
    }
    function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
            !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
            [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map(function (index, indexNum) {
            index = index.trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0);
        });
    }

    var Version =               (function () {
        function Version() {
        }
        Version.prototype._parseStoresSpec = function (stores, outSchema) {
            keys(stores).forEach(function (tableName) {
                if (stores[tableName] !== null) {
                    var indexes = parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (primKey.multi)
                        throw new exceptions.Schema("Primary key cannot be multi-valued");
                    indexes.forEach(function (idx) {
                        if (idx.auto)
                            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!idx.keyPath)
                            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                    });
                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
                }
            });
        };
        Version.prototype.stores = function (stores) {
            var db = this.db;
            this._cfg.storesSource = this._cfg.storesSource ?
                extend(this._cfg.storesSource, stores) :
                stores;
            var versions = db._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function (version) {
                extend(storesSpec, version._cfg.storesSource);
                dbschema = (version._cfg.dbschema = {});
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        };
        Version.prototype.upgrade = function (upgradeFunction) {
            this._cfg.contentUpgrade = upgradeFunction;
            return this;
        };
        return Version;
    }());

    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version$$1(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }

    var databaseEnumerator;
    function DatabaseEnumerator(indexedDB) {
        var hasDatabasesNative = indexedDB && typeof indexedDB.databases === 'function';
        var dbNamesTable;
        if (!hasDatabasesNative) {
            var db = new Dexie(DBNAMES_DB, { addons: [] });
            db.version(1).stores({ dbnames: 'name' });
            dbNamesTable = db.table('dbnames');
        }
        return {
            getDatabaseNames: function () {
                return hasDatabasesNative
                    ?
                        DexiePromise.resolve(indexedDB.databases()).then(function (infos) { return infos
                            .map(function (info) { return info.name; })
                            .filter(function (name) { return name !== DBNAMES_DB; }); })
                    :
                        dbNamesTable.toCollection().primaryKeys();
            },
            add: function (name) {
                return !hasDatabasesNative && name !== DBNAMES_DB && dbNamesTable.put({ name: name }).catch(nop);
            },
            remove: function (name) {
                return !hasDatabasesNative && name !== DBNAMES_DB && dbNamesTable.delete(name).catch(nop);
            }
        };
    }
    function initDatabaseEnumerator(indexedDB) {
        try {
            databaseEnumerator = DatabaseEnumerator(indexedDB);
        }
        catch (e) { }
    }

    function vip(fn) {
        return newScope(function () {
            PSD.letThrough = true;
            return fn();
        });
    }

    function dexieOpen(db) {
        var state = db._state;
        var indexedDB = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
            return state.dbReadyPromise.then(function () { return state.dbOpenError ?
                rejection(state.dbOpenError) :
                db; });
        debug && (state.openCanceller._stackHolder = getErrorWithStack());
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var resolveDbReady = state.dbReadyResolve,
        upgradeTransaction = null;
        return DexiePromise.race([state.openCanceller, new DexiePromise(function (resolve, reject) {
                if (!indexedDB)
                    throw new exceptions.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL " +
                        "(not locally). If using old Safari versions, make sure to include indexedDB polyfill.");
                var dbName = db.name;
                var req = state.autoSchema ?
                    indexedDB.open(dbName) :
                    indexedDB.open(dbName, Math.round(db.verno * 10));
                if (!req)
                    throw new exceptions.MissingAPI("IndexedDB API not available");
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(db._fireOnBlocked);
                req.onupgradeneeded = wrap(function (e) {
                    upgradeTransaction = req.transaction;
                    if (state.autoSchema && !db._options.allowEmptyDB) {
                        req.onerror = preventDefault;
                        upgradeTransaction.abort();
                        req.result.close();
                        var delreq = indexedDB.deleteDatabase(dbName);
                        delreq.onsuccess = delreq.onerror = wrap(function () {
                            reject(new exceptions.NoSuchDatabase("Database " + dbName + " doesnt exist"));
                        });
                    }
                    else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                        db.idbdb = req.result;
                        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                    }
                }, reject);
                req.onsuccess = wrap(function () {
                    upgradeTransaction = null;
                    var idbdb = db.idbdb = req.result;
                    var objectStoreNames = slice(idbdb.objectStoreNames);
                    if (objectStoreNames.length > 0)
                        try {
                            var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                            if (state.autoSchema)
                                readGlobalSchema(db, idbdb, tmpTrans);
                            else {
                                adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                                if (!verifyInstalledSchema(db, tmpTrans)) {
                                    console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.");
                                }
                            }
                            generateMiddlewareStacks(db, tmpTrans);
                        }
                        catch (e) {
                        }
                    connections.push(db);
                    idbdb.onversionchange = wrap(function (ev) {
                        state.vcFired = true;
                        db.on("versionchange").fire(ev);
                    });
                    databaseEnumerator.add(dbName);
                    resolve();
                }, reject);
            })]).then(function () {
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(db.on.ready.fire)).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    var remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(remainders)).then(fireRemainders);
                }
            });
        }).finally(function () {
            state.onReadyBeingFired = null;
        }).then(function () {
            state.isBeingOpened = false;
            return db;
        }).catch(function (err) {
            try {
                upgradeTransaction && upgradeTransaction.abort();
            }
            catch (e) { }
            state.isBeingOpened = false;
            db.close();
            state.dbOpenError = err;
            return rejection(state.dbOpenError);
        }).finally(function () {
            state.openComplete = true;
            resolveDbReady();
        });
    }

    function awaitIterator(iterator) {
        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return function (val) {
                var next = getNext(val), value = next.value;
                return next.done ? value :
                    (!value || typeof value.then !== 'function' ?
                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                        value.then(onSuccess, onError));
            };
        }
        return step(callNext)();
    }

    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
            args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function () {
            var transless = PSD.transless || PSD;
            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            var zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            }
            else {
                trans.create();
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function () {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    }
                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ?
                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?
                    x
                    : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")); })
                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {
                if (parentTransaction)
                    trans._resolve();
                return trans._completion.then(function () { return x; });
            }).catch(function (e) {
                trans._reject(e);
                return rejection(e);
            });
        });
    }

    function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [a];
        for (var i = 0; i < count; ++i)
            result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function (tableName) {
                var table = down.table(tableName);
                var schema = table.schema;
                var indexLookup = {};
                var allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    var keyPathAlias = getKeyPathAlias(keyPath);
                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    var isVirtual = keyTail > 0;
                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { isVirtual: isVirtual, isPrimaryKey: !isVirtual && lowLevelIndex.isPrimaryKey, keyTail: keyTail,
                        keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        var virtualKeyPath = keyLength === 2 ?
                            keyPath[0] :
                            keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });
                    return virtualIndex;
                }
                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [primaryKey];
                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
                    var index = _a[_i];
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    var result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1             ?
                            2             :
                            range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    var index = req.query.index;
                    return index.isVirtual ? __assign(__assign({}, req), { query: {
                            index: index,
                            range: translateRange(req.query.range, index.keyTail)
                        } }) : req;
                }
                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {
                        return table.count(translateRequest(req));
                    },
                    query: function (req) {
                        return table.query(translateRequest(req));
                    },
                    openCursor: function (req) {
                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                        if (!isVirtual)
                            return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ?
                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                    req.unique ?
                                        cursor.continue(pad(cursor.key, req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) :
                                        cursor.continue();
                            }
                            var virtualCursor = Object.create(cursor, {
                                continue: { value: _continue },
                                continuePrimaryKey: {
                                    value: function (key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                key: {
                                    get: function () {
                                        var key = cursor.key;
                                        return keyLength === 1 ?
                                            key[0] :
                                            key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get: function () {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req))
                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });
                    } });
                return result;
            } });
    }
    var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };

    var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {
                var downTable = downCore.table(tableName);
                var primaryKey = downTable.schema.primaryKey;
                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {
                        var dxTrans = PSD.trans;
                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                        switch (req.type) {
                            case 'add':
                                if (creating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'put':
                                if (creating.fire === nop && updating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'delete':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'deleteRange':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            var dxTrans = PSD.trans;
                            var keys$$1 = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys$$1)
                                throw new Error("Keys missing");
                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys$$1, wantResults: true }) :
                             __assign({}, req);
                            if (req.type !== 'delete')
                                req.values = __spreadArrays(req.values);
                            if (req.keys)
                                req.keys = __spreadArrays(req.keys);
                            return getExistingValues(downTable, req, keys$$1).then(function (existingValues) {
                                var contexts = keys$$1.map(function (key, i) {
                                    var existingValue = existingValues[i];
                                    var ctx = { onerror: null, onsuccess: null };
                                    if (req.type === 'delete') {
                                        deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    }
                                    else if (req.type === 'add' || existingValue === undefined) {
                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) {
                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                            }
                                        }
                                    }
                                    else {
                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges_1) {
                                            var requestedValue_1 = req.values[i];
                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {
                                                if (hasOwn(requestedValue_1, keyPath)) {
                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                }
                                                else {
                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                }
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(function (_a) {
                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                    for (var i = 0; i < keys$$1.length; ++i) {
                                        var primKey = results ? results[i] : keys$$1[i];
                                        var ctx = contexts[i];
                                        if (primKey == null) {
                                            ctx.onerror && ctx.onerror(failures[i]);
                                        }
                                        else {
                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                req.values[i] :
                                                primKey
                                            );
                                        }
                                    }
                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };
                                }).catch(function (error) {
                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })
                                .then(function (_a) {
                                var result = _a.result;
                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {
                                    if (res.numFailures > 0)
                                        return Promise.reject(res.failures[0]);
                                    if (result.length < limit) {
                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                    }
                                    else {
                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                                    }
                                });
                            });
                        }
                    } });
                return tableMiddleware;
            } })); }
    };

    var Dexie =               (function () {
        function Dexie(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie.dependencies;
            this._options = options = __assign({
                addons: Dexie.addons, autoOpen: true,
                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange }, options);
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            var state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true
            };
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
                return function (subscriber, bSticky) {
                    Dexie.vip(function () {
                        var state = _this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError)
                                DexiePromise.resolve().then(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else {
                            subscribe(subscriber);
                            var db_1 = _this;
                            if (!bSticky)
                                subscribe(function unsubscribe() {
                                    db_1.on.ready.unsubscribe(subscriber);
                                    db_1.on.ready.unsubscribe(unsubscribe);
                                });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function (ev) {
                if (ev.newVersion > 0)
                    console.warn("Another connection wants to upgrade database '" + _this.name + "'. Closing db now to resume the upgrade.");
                else
                    console.warn("Another connection wants to delete database '" + _this.name + "'. Closing db now to resume the delete request.");
                _this.close();
            });
            this.on("blocked", function (ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                    console.warn("Dexie.delete('" + _this.name + "') was blocked");
                else
                    console.warn("Upgrade '" + _this.name + "' blocked by other connection holding version " + ev.oldVersion / 10);
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, parentTransaction); };
            this._fireOnBlocked = function (ev) {
                _this.on("blocked").fire(ev);
                connections
                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })
                    .map(function (c) { return c.on("versionchange").fire(ev); });
            };
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            addons.forEach(function (addon) { return addon(_this); });
        }
        Dexie.prototype.version = function (versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
                throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
                throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];
            if (versionInstance)
                return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        };
        Dexie.prototype._whenReady = function (fn) {
            var _this = this;
            return this._state.openComplete || PSD.letThrough ? fn() : new DexiePromise(function (resolve, reject) {
                if (!_this._state.isBeingOpened) {
                    if (!_this._options.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    _this.open().catch(nop);
                }
                _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        Dexie.prototype.use = function (_a) {
            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
            if (name)
                this.unuse({ stack: stack, name: name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });
            middlewares.sort(function (a, b) { return a.level - b.level; });
            return this;
        };
        Dexie.prototype.unuse = function (_a) {
            var stack = _a.stack, name = _a.name, create = _a.create;
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
                    return create ? mw.create !== create :
                        name ? mw.name !== name :
                            false;
                });
            }
            return this;
        };
        Dexie.prototype.open = function () {
            return dexieOpen(this);
        };
        Dexie.prototype.close = function () {
            var idx = connections.indexOf(this), state = this._state;
            if (idx >= 0)
                connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                }
                catch (e) { }
                this.idbdb = null;
            }
            this._options.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
            if (state.isBeingOpened)
                state.cancelOpen(state.dbOpenError);
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
        };
        Dexie.prototype.delete = function () {
            var _this = this;
            var hasArguments = arguments.length > 0;
            var state = this._state;
            return new DexiePromise(function (resolve, reject) {
                var doDelete = function () {
                    _this.close();
                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                    req.onsuccess = wrap(function () {
                        databaseEnumerator.remove(_this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = _this._fireOnBlocked;
                };
                if (hasArguments)
                    throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                }
                else {
                    doDelete();
                }
            });
        };
        Dexie.prototype.backendDB = function () {
            return this.idbdb;
        };
        Dexie.prototype.isOpen = function () {
            return this.idbdb !== null;
        };
        Dexie.prototype.hasBeenClosed = function () {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
        };
        Dexie.prototype.hasFailed = function () {
            return this._state.dbOpenError !== null;
        };
        Dexie.prototype.dynamicallyOpened = function () {
            return this._state.autoSchema;
        };
        Object.defineProperty(Dexie.prototype, "tables", {
            get: function () {
                var _this = this;
                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });
            },
            enumerable: true,
            configurable: true
        });
        Dexie.prototype.transaction = function () {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            var idbMode, storeNames;
            try {
                storeNames = tables.map(function (table) {
                    var storeName = table instanceof _this.Table ? table.name : table;
                    if (typeof storeName !== 'string')
                        throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY)
                    idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE)
                    idbMode = READWRITE;
                else
                    throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        }
                        else
                            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function (storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Table " + storeName +
                                        " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            }
            catch (e) {
                return parentTransaction ?
                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :
                    rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return (parentTransaction ?
                parentTransaction._promise(idbMode, enterTransaction, "lock") :
                PSD.trans ?
                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :
                    this._whenReady(enterTransaction));
        };
        Dexie.prototype.table = function (tableName) {
            if (!hasOwn(this._allTables, tableName)) {
                throw new exceptions.InvalidTable("Table " + tableName + " does not exist");
            }
            return this._allTables[tableName];
        };
        return Dexie;
    }());

    var Dexie$1 = Dexie;
    props(Dexie$1, __assign(__assign({}, fullNameExceptions), {
        delete: function (databaseName) {
            var db = new Dexie$1(databaseName);
            return db.delete();
        },
        exists: function (name) {
            return new Dexie$1(name, { addons: [] }).open().then(function (db) {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', function () { return false; });
        },
        getDatabaseNames: function (cb) {
            return databaseEnumerator ?
                databaseEnumerator.getDatabaseNames().then(cb) :
                DexiePromise.resolve([]);
        },
        defineClass: function () {
            function Class(content) {
                extend(this, content);
            }
            return Class;
        },
        ignoreTransaction: function (scopeFunc) {
            return PSD.trans ?
                usePSD(PSD.transless, scopeFunc) :
                scopeFunc();
        },
        vip: vip, async: function (generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function')
                        return DexiePromise.resolve(rv);
                    return rv;
                }
                catch (e) {
                    return rejection(e);
                }
            };
        }, spawn: function (generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: function () { return PSD.trans || null; }
        }, waitFor: function (promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                Dexie$1.ignoreTransaction(promiseOrFunction) :
                promiseOrFunction)
                .timeout(optionalTimeout || 60000);
            return PSD.trans ?
                PSD.trans.waitFor(promise) :
                promise;
        },
        Promise: DexiePromise,
        debug: {
            get: function () { return debug; },
            set: function (value) {
                setDebug(value, value === 'dexie' ? function () { return true; } : dexieStackFrameFilter);
            }
        },
        derive: derive, extend: extend, props: props, override: override,
        Events: Events,
        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, asap: asap,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: (function () {
            try {
                return {
                    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
                    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
                };
            }
            catch (e) {
                return { indexedDB: null, IDBKeyRange: null };
            }
        })(),
        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')
            .map(function (n) { return parseInt(n); })
            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }),
        default: Dexie$1,
        Dexie: Dexie$1 }));
    Dexie$1.maxKey = getMaxKey(Dexie$1.dependencies.IDBKeyRange);

    initDatabaseEnumerator(Dexie.dependencies.indexedDB);
    DexiePromise.rejectionMapper = mapError;
    setDebug(debug, dexieStackFrameFilter);

    // TODO: 雑に詰め込みすぎなのでいい感じに整理して assets に

    function sleep(msec) {
      return new Promise(resolve => setTimeout(resolve, msec))
    }


    async function fetchImage(path) {
      const img = new Image();
      img.src = path;

      await new Promise(resolve => {img.onload = resolve;});
      console.log(`fetched ${path}`);
      return cv__default['default'].imread(img)
    }


    function countImageDiffAtPoint(image, templateImage, trimRect, diffBinaryThreshold, filter, debug) {
      // const trimmed = filter != null ? filter(image.roi(trimRect)) : image.roi(trimRect)
      const trimmed = image.roi(trimRect);
      if (filter != null) {
        filter(trimmed);
      }

      const diff = new cv__default['default'].Mat();
      cv__default['default'].absdiff(templateImage, trimmed, diff);
      cv__default['default'].cvtColor(diff, diff, cv__default['default'].COLOR_BGR2GRAY);

      const result = new cv__default['default'].Mat();
      cv__default['default'].threshold(diff, result, diffBinaryThreshold, 255, cv__default['default'].THRESH_BINARY);

      // 入力の濃淡で 1px の誤差が出ることがあるので補正
      cv__default['default'].morphologyEx(result, result, cv__default['default'].MORPH_OPEN, cv__default['default'].Mat.ones(2, 2, cv__default['default'].CV_8U));

      const diffCount = cv__default['default'].countNonZero(result);

      if (debug != null) {
        debug({trimmed, templateImage, diff, result});
      }

      result.delete();
      diff.delete();
      trimmed.delete();

      // const buffer = image.roi(trimRect)
      // cv.absdiff(templateImage, buffer, buffer)
      // cv.cvtColor(buffer, buffer, cv.COLOR_BGR2GRAY)
      // cv.threshold(buffer, buffer, diffBinaryThreshold, 255, cv.THRESH_BINARY)
      // const diffCount = cv.countNonZero(buffer)
      // buffer.delete()

      return diffCount
    }


    function getMostMatchedImage(image, templates, trimRect, diffBinaryThreshold = 63, filter = null, debug = null) {
      let minDiffCount = Number.MAX_SAFE_INTEGER;
      let candidate = null;

      for (const [name, template] of Object.entries(templates)) {
        const diffCount = countImageDiffAtPoint(image, template, trimRect, diffBinaryThreshold, filter, debug);

        if ( diffCount === 0 ) {
          return {name, diffCount}
        }
        else if ( minDiffCount > diffCount ) {
          minDiffCount = diffCount;
          candidate = name;
        }
      }

      return {name: candidate, diffCount: minDiffCount}
    }


    function promiseAllRecursive(value) {
      if (value instanceof Promise) {
        return value
      }

      if (Array.isArray(value)) {
        return Promise.all(value.map(promiseAllRecursive))
      }

      if (typeof value === 'object') {
        return resolveObject(value)
      }

      return Promise.resolve(value)
    }

    function resolveObject(obj) {
      const promises = Object
        .keys(obj)
        .map(key => promiseAllRecursive(obj[key]).then(value => ({ key, value }))); // as Promise<{key: any, value: any}>[]

      return Promise.all(promises).then(results => {
        return results.reduce((obj, pair) => {
          obj[pair.key] = pair.value;
          return obj
        }, {})
      })
    }


    // export function bgr2hsv(src) {
    //   const hsv = new cv.Mat()
    //   cv.cvtColor(src, hsv, cv.COLOR_BGR2HSV, 3)

    //   return hsv
    // }

    // export function rgba2gray(src) {
    //   const gray = new cv.Mat()
    //   cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0)

    //   return gray
    // }

    function maskByColor(src, min, max) {
      const mask = new cv__default['default'].Mat();
      const sMin = new cv__default['default'].Mat(src.rows, src.cols, src.type(), min);
      const sMax = new cv__default['default'].Mat(src.rows, src.cols, src.type(), max);
      cv__default['default'].inRange(src, sMin, sMax, mask);

      const dst = new cv__default['default'].Mat();
      src.copyTo(dst, mask);

      sMax.delete();
      sMin.delete();
      mask.delete();

      return dst
    }

    const SCAN_MODE = {
        MODE_EQUIP_LIST: 'equip_list',
        MODE_RINNE: 'rinne',
    };
    const SCAN_SKIP_MODE = {
        SKIP_SCANNED_CHARM: 'skip_scanned_charm',
        SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE: 'skip_same_charm_as_immediately_before',
        NO_SKIP: 'no_skip',
    };
    class MHRiseCharmScanner {
        constructor({ scanMode, scanSkipMode }) {
            this.EQUIPMENT_SPEC_HEADER_BASE_X = 1023;
            this.EQUIPMENT_SPEC_HEADER_BASE_Y = 88;
            this.POINT_RARITY = new cv__default['default'].Point(1190, 176);
            this.POINT_SLOTS = new cv__default['default'].Point(1160, 200);
            this.POINT_SLOT1 = new cv__default['default'].Point(1166, 200);
            this.POINT_SLOT2 = new cv__default['default'].Point(1194, 200);
            this.POINT_SLOT3 = new cv__default['default'].Point(1222, 200);
            this.POINT_SKILL1 = new cv__default['default'].Point(1033, 266);
            this.POINT_SKILL2 = new cv__default['default'].Point(1033, 317);
            this.POINT_SKILL_LEVEL1 = new cv__default['default'].Point(1190, 290);
            this.POINT_SKILL_LEVEL2 = new cv__default['default'].Point(1190, 341);
            // 装備確認画面
            this.POINT_PAGE = new cv__default['default'].Point(787, 582); // ページ番号 (1桁数字 & 2桁数字の1桁目)
            this.POINT_PAGE_SECOND_DIGIT = new cv__default['default'].Point(796, 582); // ページ番号 (2桁数字)
            this.POINT_CHARM_AREA = new cv__default['default'].Point(634, 359); // アイコンリストの左上座標
            this.POINT_CHARM_ICON_BASE = new cv__default['default'].Point(634, 360); // アイコンリストの1つ目の場所
            // private readonly SIZE_CHARM_AREA             = new cv.Size(357, 199)  // アイコンリストのサイズ
            this.SIZE_CHARM_ICON_FRAME = new cv__default['default'].Size(35, 34);
            // 輪廻画面 (位置調整する都合で, EQUIPMENT_SPEC_HEADER_BASE に相対位置を足して定義)
            // offset(-334, 14) で adjust されるはず? 手元のキャプボでは 1px ずれるので (-335, 13) で確認
            this.POINT_PAGE_IN_RINNE = new cv__default['default'].Point(796, 532); // ページ番号
            this.POINT_PAGE_SECOND_DIGIT_IN_RINNE = new cv__default['default'].Point(805, 532); // ページ番号 (2桁数字)
            this.POINT_CHARM_AREA_IN_RINNE = new cv__default['default'].Point(657, 358); // アイコンリストの左上座標 (-366, 270)
            this.SIZE_CHARM_AREA_IN_RINNE = new cv__default['default'].Size(329, 164); // アイコンリストのサイズ
            this.prevPosition = { page: -1, row: -1, col: -1 };
            this.indexeddb = null;
            this.nCharms = 0; // このスキャンで読んだ護石の数
            this.charms = {}; // このスキャンで読んだ護石のスペック
            this.adjustOffset = { x: 0, y: 0 };
            this.scanMode = scanMode !== null && scanMode !== void 0 ? scanMode : SCAN_MODE.MODE_EQUIP_LIST;
            this.scanSkipMode = scanSkipMode !== null && scanSkipMode !== void 0 ? scanSkipMode : SCAN_SKIP_MODE.SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE;
            this.ROWS_PER_PAGE = (scanMode === SCAN_MODE.MODE_RINNE) ? ROWS_PER_PAGE_IN_RINNE : ROWS_PER_PAGE_IN_EQLIST;
            this.COLS_PER_PAGE = (scanMode === SCAN_MODE.MODE_RINNE) ? COLS_PER_PAGE_IN_RINNE : COLS_PER_PAGE_IN_EQLIST;
            this.reset();
            this.indexeddb = new Dexie('charms');
            this.indexeddb.version(1).stores({ images: 'name' });
        }
        static async init() {
            const templateFetchPromises = {
                others: {
                    charmSelectFrame: fetchImage('img/templates/others/charm-select-frame.png'),
                    charmSelectFrameForRinne: fetchImage('img/templates/others/charm-select-frame-for-rinne.png'),
                    equipmentSpecHeader: fetchImage('img/templates/others/equipment-spec-header.png'),
                },
                page: {},
                'page-parts': {
                    0: fetchImage('img/templates/page-parts/0.png'),
                    1: fetchImage('img/templates/page-parts/1.png'),
                    2: fetchImage('img/templates/page-parts/2.png'),
                    3: fetchImage('img/templates/page-parts/3.png'),
                    4: fetchImage('img/templates/page-parts/4.png'),
                    5: fetchImage('img/templates/page-parts/5.png'),
                    6: fetchImage('img/templates/page-parts/6.png'),
                    7: fetchImage('img/templates/page-parts/7.png'),
                    8: fetchImage('img/templates/page-parts/8.png'),
                    9: fetchImage('img/templates/page-parts/9.png'),
                },
                rare: {
                    10: fetchImage('img/templates/rare/10.jpg'),
                    9: fetchImage('img/templates/rare/9.jpg'),
                    8: fetchImage('img/templates/rare/8.jpg'),
                    7: fetchImage('img/templates/rare/7.jpg'),
                    6: fetchImage('img/templates/rare/6.jpg'),
                    5: fetchImage('img/templates/rare/5.jpg'),
                    4: fetchImage('img/templates/rare/4.jpg'),
                },
                lvl: {
                    0: fetchImage('img/templates/lvl/0.jpg'),
                    1: fetchImage('img/templates/lvl/1.jpg'),
                    2: fetchImage('img/templates/lvl/2.jpg'),
                    3: fetchImage('img/templates/lvl/3.jpg'),
                    4: fetchImage('img/templates/lvl/4.jpg'),
                    5: fetchImage('img/templates/lvl/5.jpg'),
                    6: fetchImage('img/templates/lvl/6.jpg'),
                    7: fetchImage('img/templates/lvl/7.jpg'),
                },
                slot: {
                    // '0-0-0':              fetchImage('img/templates/slot/0.jpg'),
                    // '1-0-0':              fetchImage('img/templates/slot/1.jpg'),
                    // '1-1-0':              fetchImage('img/templates/slot/11.jpg'),
                    // '1-1-1':              fetchImage('img/templates/slot/111.jpg'),
                    // '2-0-0':              fetchImage('img/templates/slot/2.jpg'),
                    // '2-1-0':              fetchImage('img/templates/slot/21.jpg'),
                    // '2-1-1':              fetchImage('img/templates/slot/211.jpg'),
                    // '2-2-0':              fetchImage('img/templates/slot/22.jpg'),
                    // '2-2-1':              fetchImage('img/templates/slot/221.jpg'),
                    // '3-0-0':              fetchImage('img/templates/slot/3.jpg'),
                    // '3-1-0':              fetchImage('img/templates/slot/31.jpg'),
                    // '3-1-1':              fetchImage('img/templates/slot/311.jpg'),
                    // '3-2-0':              fetchImage('img/templates/slot/32.jpg'),
                    // '3-2-1':              fetchImage('img/templates/slot/321.jpg'),
                    // '4-0-0':              fetchImage('img/templates/slot/4.jpg'),
                    0: fetchImage('img/templates/slot/0.jpg'),
                    1: fetchImage('img/templates/slot/1.jpg'),
                    2: fetchImage('img/templates/slot/2.jpg'),
                    3: fetchImage('img/templates/slot/3.jpg'),
                    4: fetchImage('img/templates/slot/4.jpg'),
                },
                skill: {
                    'KO術': fetchImage('img/templates/skill/KO術.jpg'),
                    '匠': fetchImage('img/templates/skill/匠.jpg'),
                    '不屈': fetchImage('img/templates/skill/不屈.jpg'),
                    '体術': fetchImage('img/templates/skill/体術.jpg'),
                    '幸運': fetchImage('img/templates/skill/幸運.jpg'),
                    '心眼': fetchImage('img/templates/skill/心眼.jpg'),
                    '攻撃': fetchImage('img/templates/skill/攻撃.jpg'),
                    '業物': fetchImage('img/templates/skill/業物.jpg'),
                    '渾身': fetchImage('img/templates/skill/渾身.jpg'),
                    '無し': fetchImage('img/templates/skill/無し.jpg'),
                    '砲術': fetchImage('img/templates/skill/砲術.jpg'),
                    '耐震': fetchImage('img/templates/skill/耐震.jpg'),
                    '耳栓': fetchImage('img/templates/skill/耳栓.jpg'),
                    '逆襲': fetchImage('img/templates/skill/逆襲.jpg'),
                    '防御': fetchImage('img/templates/skill/防御.jpg'),
                    '陽動': fetchImage('img/templates/skill/陽動.jpg'),
                    '集中': fetchImage('img/templates/skill/集中.jpg'),
                    'ボマー': fetchImage('img/templates/skill/ボマー.jpg'),
                    '地質学': fetchImage('img/templates/skill/地質学.jpg'),
                    '広域化': fetchImage('img/templates/skill/広域化.jpg'),
                    '挑戦者': fetchImage('img/templates/skill/挑戦者.jpg'),
                    '早食い': fetchImage('img/templates/skill/早食い.jpg'),
                    '植生学': fetchImage('img/templates/skill/植生学.jpg'),
                    '毒耐性': fetchImage('img/templates/skill/毒耐性.jpg'),
                    '水耐性': fetchImage('img/templates/skill/水耐性.jpg'),
                    '氷耐性': fetchImage('img/templates/skill/氷耐性.jpg'),
                    '満足感': fetchImage('img/templates/skill/満足感.jpg'),
                    '火耐性': fetchImage('img/templates/skill/火耐性.jpg'),
                    '破壊王': fetchImage('img/templates/skill/破壊王.jpg'),
                    '納刀術': fetchImage('img/templates/skill/納刀術.jpg'),
                    '見切り': fetchImage('img/templates/skill/見切り.jpg'),
                    '超会心': fetchImage('img/templates/skill/超会心.jpg'),
                    '逆恨み': fetchImage('img/templates/skill/逆恨み.jpg'),
                    '達人芸': fetchImage('img/templates/skill/達人芸.jpg'),
                    '雷耐性': fetchImage('img/templates/skill/雷耐性.jpg'),
                    '鬼火纏': fetchImage('img/templates/skill/鬼火纏.jpg'),
                    '龍耐性': fetchImage('img/templates/skill/龍耐性.jpg'),
                    'ブレ抑制': fetchImage('img/templates/skill/ブレ抑制.jpg'),
                    'ランナー': fetchImage('img/templates/skill/ランナー.jpg'),
                    '乗り名人': fetchImage('img/templates/skill/乗り名人.jpg'),
                    '剛刃研磨': fetchImage('img/templates/skill/剛刃研磨.jpg'),
                    '力の解放': fetchImage('img/templates/skill/力の解放.jpg'),
                    '反動軽減': fetchImage('img/templates/skill/反動軽減.jpg'),
                    '回復速度': fetchImage('img/templates/skill/回復速度.jpg'),
                    '回避性能': fetchImage('img/templates/skill/回避性能.jpg'),
                    '壁面移動': fetchImage('img/templates/skill/壁面移動.jpg'),
                    '弱点特効': fetchImage('img/templates/skill/弱点特効.jpg'),
                    '強化持続': fetchImage('img/templates/skill/強化持続.jpg'),
                    '弾丸節約': fetchImage('img/templates/skill/弾丸節約.jpg'),
                    '弾導強化': fetchImage('img/templates/skill/弾導強化.jpg'),
                    '死中に活': fetchImage('img/templates/skill/死中に活.jpg'),
                    '気絶耐性': fetchImage('img/templates/skill/気絶耐性.jpg'),
                    '泡沫の舞': fetchImage('img/templates/skill/泡沫の舞.jpg'),
                    '泥雪耐性': fetchImage('img/templates/skill/泥雪耐性.jpg'),
                    '滑走強化': fetchImage('img/templates/skill/滑走強化.jpg'),
                    '火事場力': fetchImage('img/templates/skill/火事場力.jpg'),
                    '睡眠耐性': fetchImage('img/templates/skill/睡眠耐性.jpg'),
                    '砲弾装填': fetchImage('img/templates/skill/砲弾装填.jpg'),
                    '翔蟲使い': fetchImage('img/templates/skill/翔蟲使い.jpg'),
                    '装填拡張': fetchImage('img/templates/skill/装填拡張.jpg'),
                    '装填速度': fetchImage('img/templates/skill/装填速度.jpg'),
                    '速射強化': fetchImage('img/templates/skill/速射強化.jpg'),
                    '鈍器使い': fetchImage('img/templates/skill/鈍器使い.jpg'),
                    '風圧耐性': fetchImage('img/templates/skill/風圧耐性.jpg'),
                    '飛び込み': fetchImage('img/templates/skill/飛び込み.jpg'),
                    '高速変形': fetchImage('img/templates/skill/高速変形.jpg'),
                    '麻痺耐性': fetchImage('img/templates/skill/麻痺耐性.jpg'),
                    '回避距離UP': fetchImage('img/templates/skill/回避距離UP.jpg'),
                    'ひるみ軽減': fetchImage('img/templates/skill/ひるみ軽減.jpg'),
                    'ガード強化': fetchImage('img/templates/skill/ガード強化.jpg'),
                    'ガード性能': fetchImage('img/templates/skill/ガード性能.jpg'),
                    '攻めの守勢': fetchImage('img/templates/skill/攻めの守勢.jpg'),
                    '毒属性強化': fetchImage('img/templates/skill/毒属性強化.jpg'),
                    '笛吹き名人': fetchImage('img/templates/skill/笛吹き名人.jpg'),
                    '精霊の加護': fetchImage('img/templates/skill/精霊の加護.jpg'),
                    '腹減り耐性': fetchImage('img/templates/skill/腹減り耐性.jpg'),
                    '体力回復量UP': fetchImage('img/templates/skill/体力回復量UP.jpg'),
                    'キノコ大好き': fetchImage('img/templates/skill/キノコ大好き.jpg'),
                    'ジャンプ鉄人': fetchImage('img/templates/skill/ジャンプ鉄人.jpg'),
                    'スタミナ奪取': fetchImage('img/templates/skill/スタミナ奪取.jpg'),
                    'フルチャージ': fetchImage('img/templates/skill/フルチャージ.jpg'),
                    '剥ぎ取り鉄人': fetchImage('img/templates/skill/剥ぎ取り鉄人.jpg'),
                    '抜刀術【力】': fetchImage('img/templates/skill/抜刀術【力】.jpg'),
                    '抜刀術【技】': fetchImage('img/templates/skill/抜刀術【技】.jpg'),
                    '爆破属性強化': fetchImage('img/templates/skill/爆破属性強化.jpg'),
                    '特殊射撃強化': fetchImage('img/templates/skill/特殊射撃強化.jpg'),
                    '睡眠属性強化': fetchImage('img/templates/skill/睡眠属性強化.jpg'),
                    '麻痺属性強化': fetchImage('img/templates/skill/麻痺属性強化.jpg'),
                    '会心撃【属性】': fetchImage('img/templates/skill/会心撃【属性】.jpg'),
                    '属性やられ耐性': fetchImage('img/templates/skill/属性やられ耐性.jpg'),
                    '水属性攻撃強化': fetchImage('img/templates/skill/水属性攻撃強化.jpg'),
                    '氷属性攻撃強化': fetchImage('img/templates/skill/氷属性攻撃強化.jpg'),
                    '火属性攻撃強化': fetchImage('img/templates/skill/火属性攻撃強化.jpg'),
                    '爆破やられ耐性': fetchImage('img/templates/skill/爆破やられ耐性.jpg'),
                    '砥石使用高速化': fetchImage('img/templates/skill/砥石使用高速化.jpg'),
                    '雷属性攻撃強化': fetchImage('img/templates/skill/雷属性攻撃強化.jpg'),
                    '龍属性攻撃強化': fetchImage('img/templates/skill/龍属性攻撃強化.jpg'),
                    'アイテム使用強化': fetchImage('img/templates/skill/アイテム使用強化.jpg'),
                    'スタミナ急速回復': fetchImage('img/templates/skill/スタミナ急速回復.jpg'),
                    '散弾・拡散矢強化': fetchImage('img/templates/skill/散弾・拡散矢強化.jpg'),
                    '貫通弾・貫通矢強化': fetchImage('img/templates/skill/貫通弾・貫通矢強化.jpg'),
                    '通常弾・連射矢強化': fetchImage('img/templates/skill/通常弾・連射矢強化.jpg'),
                    // added in sunbreak
                    'チャージマスター': fetchImage('img/templates/skill/チャージマスター.jpg'),
                    'チューンアップ': fetchImage('img/templates/skill/チューンアップ.jpg'),
                    '供応': fetchImage('img/templates/skill/供応.jpg'),
                    '刃鱗磨き': fetchImage('img/templates/skill/刃鱗磨き.jpg'),
                    '合気': fetchImage('img/templates/skill/合気.jpg'),
                    '壁面移動【翔】': fetchImage('img/templates/skill/壁面移動【翔】.jpg'),
                    '攻勢': fetchImage('img/templates/skill/攻勢.jpg'),
                    '災禍転福': fetchImage('img/templates/skill/災禍転福.jpg'),
                    '研磨術【鋭】': fetchImage('img/templates/skill/研磨術【鋭】.jpg'),
                    '連撃': fetchImage('img/templates/skill/連撃.jpg'),
                    // added in v15 charm farming
                    '炎鱗の恩恵': fetchImage('img/templates/skill/炎鱗の恩恵.jpg'),
                    '鋼殻の恩恵': fetchImage('img/templates/skill/鋼殻の恩恵.jpg'),
                    '霞皮の恩恵': fetchImage('img/templates/skill/霞皮の恩恵.jpg'),
                    '龍気活性': fetchImage('img/templates/skill/龍気活性.jpg'),
                    '血氣': fetchImage('img/templates/skill/血氣.jpg'),
                    '激昂': fetchImage('img/templates/skill/激昂.jpg'),
                    '伏魔響命': fetchImage('img/templates/skill/伏魔響命.jpg'),
                    '狂竜症【蝕】': fetchImage('img/templates/skill/狂竜症【蝕】.jpg'),
                    '業鎧【修羅】': fetchImage('img/templates/skill/業鎧【修羅】.jpg'),
                    '根性': fetchImage('img/templates/skill/根性.jpg'),
                    '巧撃': fetchImage('img/templates/skill/巧撃.jpg'),
                    '闇討ち': fetchImage('img/templates/skill/闇討ち.jpg'),
                    '弱点特効【属性】': fetchImage('img/templates/skill/弱点特効【属性】.jpg'),
                    '顕如盤石': fetchImage('img/templates/skill/顕如盤石.jpg'),
                    '状態異常確定蓄積': fetchImage('img/templates/skill/状態異常確定蓄積.jpg'),
                    '煽衛': fetchImage('img/templates/skill/煽衛.jpg'),
                    '剛心': fetchImage('img/templates/skill/剛心.jpg'),
                    '蓄積時攻撃強化': fetchImage('img/templates/skill/蓄積時攻撃強化.jpg'),
                    '狂化': fetchImage('img/templates/skill/狂化.jpg'),
                    '奮闘': fetchImage('img/templates/skill/奮闘.jpg'),
                    '風纏': fetchImage('img/templates/skill/風纏.jpg'),
                    '粉塵纏': fetchImage('img/templates/skill/粉塵纏.jpg'),
                    '龍気変換': fetchImage('img/templates/skill/龍気変換.jpg'),
                    '冰気錬成': fetchImage('img/templates/skill/冰気錬成.jpg'),
                },
            };
            for (let i = 1; i <= 9; i++) {
                templateFetchPromises.page[i] = fetchImage(`img/templates/page/${i}.png`);
            }
            MHRiseCharmScanner.templates = await promiseAllRecursive(templateFetchPromises);
            const template = MHRiseCharmScanner.templates.others.charmSelectFrame;
            cv__default['default'].cvtColor(template, template, cv__default['default'].COLOR_BGR2GRAY);
            cv__default['default'].threshold(template, template, 63, 255, cv__default['default'].THRESH_BINARY);
        }
        reset() {
            this.nCharms = 0;
            this.charms = {};
            for (let p = 1; p <= MAX_PAGE; p++) {
                this.charms[p] = {};
                for (let r = 1; r <= this.ROWS_PER_PAGE; r++) {
                    this.charms[p][r] = {};
                }
            }
        }
        _isScaned(page, row, col) {
            return this._getCache({ page, row, col }) != null;
        }
        _setCache({ page, row, col }, charm) {
            this.charms[page][row][col] = charm;
        }
        _getCache({ page, row, col }) {
            return this.charms[page][row][col];
        }
        getAdjustOffset(screenshot) {
            const template = MHRiseCharmScanner.templates.others.equipmentSpecHeader;
            const result = new cv__default['default'].Mat();
            cv__default['default'].matchTemplate(screenshot, template, result, cv__default['default'].TM_CCOEFF_NORMED);
            const { maxLoc, maxVal } = cv__default['default'].minMaxLoc(result);
            result.delete();
            return {
                x: maxLoc.x - this.EQUIPMENT_SPEC_HEADER_BASE_X,
                y: maxLoc.y - this.EQUIPMENT_SPEC_HEADER_BASE_Y,
            };
        }
        // 事前に Point オブジェクトの調整をする (無駄にヒープを使って GC 誘発を避けたい)
        adjustPosition(screenshot) {
            const offset = this.getAdjustOffset(screenshot);
            console.log({ offset });
            this.POINT_RARITY.x += (offset.x - this.adjustOffset.x);
            this.POINT_RARITY.y += (offset.y - this.adjustOffset.y);
            this.POINT_SLOTS.x += (offset.x - this.adjustOffset.x);
            this.POINT_SLOTS.y += (offset.y - this.adjustOffset.y);
            this.POINT_SLOT1.x += (offset.x - this.adjustOffset.x);
            this.POINT_SLOT1.y += (offset.y - this.adjustOffset.y);
            this.POINT_SLOT2.x += (offset.x - this.adjustOffset.x);
            this.POINT_SLOT2.y += (offset.y - this.adjustOffset.y);
            this.POINT_SLOT3.x += (offset.x - this.adjustOffset.x);
            this.POINT_SLOT3.y += (offset.y - this.adjustOffset.y);
            this.POINT_SKILL1.x += (offset.x - this.adjustOffset.x);
            this.POINT_SKILL1.y += (offset.y - this.adjustOffset.y);
            this.POINT_SKILL2.x += (offset.x - this.adjustOffset.x);
            this.POINT_SKILL2.y += (offset.y - this.adjustOffset.y);
            this.POINT_SKILL_LEVEL1.x += (offset.x - this.adjustOffset.x);
            this.POINT_SKILL_LEVEL1.y += (offset.y - this.adjustOffset.y);
            this.POINT_SKILL_LEVEL2.x += (offset.x - this.adjustOffset.x);
            this.POINT_SKILL_LEVEL2.y += (offset.y - this.adjustOffset.y);
            this.POINT_PAGE.x += (offset.x - this.adjustOffset.x);
            this.POINT_PAGE.y += (offset.y - this.adjustOffset.y);
            this.POINT_PAGE_SECOND_DIGIT.x += (offset.x - this.adjustOffset.x);
            this.POINT_PAGE_SECOND_DIGIT.y += (offset.y - this.adjustOffset.y);
            this.POINT_PAGE_IN_RINNE.x += (offset.x - this.adjustOffset.x);
            this.POINT_PAGE_IN_RINNE.y += (offset.y - this.adjustOffset.y);
            this.POINT_PAGE_SECOND_DIGIT_IN_RINNE.x += (offset.x - this.adjustOffset.x);
            this.POINT_PAGE_SECOND_DIGIT_IN_RINNE.y += (offset.y - this.adjustOffset.y);
            this.POINT_CHARM_AREA.x += (offset.x - this.adjustOffset.x);
            this.POINT_CHARM_AREA.y += (offset.y - this.adjustOffset.y);
            this.POINT_CHARM_ICON_BASE.x += (offset.x - this.adjustOffset.x);
            this.POINT_CHARM_ICON_BASE.y += (offset.y - this.adjustOffset.y);
            this.POINT_CHARM_AREA_IN_RINNE.x += (offset.x - this.adjustOffset.x);
            this.POINT_CHARM_AREA_IN_RINNE.y += (offset.y - this.adjustOffset.y);
            console.log({ POINT_PAGE_IN_RINNE: this.POINT_PAGE_IN_RINNE });
            this.adjustOffset = offset;
        }
        scan(screenshot, movieName, matchThresholdOverwrite) {
            const page = this._getCurrentPage(screenshot);
            // if (page <= 0 || MAX_PAGE < page) {
            //   console.log(`invalid page number: ${page}`)
            //   return null
            // }
            // スキャンモード (装備確認ページと輪廻ページ) でパラメータ設定を分岐
            const { pos, match, matchThreshold } = (() => {
                switch (this.scanMode) {
                    case SCAN_MODE.MODE_EQUIP_LIST:
                        return Object.assign(Object.assign({}, this._getCurrentCharmPos(screenshot)), { matchThreshold: matchThresholdOverwrite !== null && matchThresholdOverwrite !== void 0 ? matchThresholdOverwrite : 0.31 });
                    case SCAN_MODE.MODE_RINNE:
                        return Object.assign(Object.assign({}, this._getCurrentCharmPosForRinne(screenshot)), { matchThreshold: matchThresholdOverwrite !== null && matchThresholdOverwrite !== void 0 ? matchThresholdOverwrite : 0.28 });
                    default:
                        throw new Error('[internal error] invalid scan mode');
                }
            })();
            if (match < matchThreshold) {
                // 放置すると blink するので一致度が低い時はスキップ
                // console.log(`low match degress ${match} for charm position searching. skip`)
                return null;
            }
            const [col, row] = pos;
            // console.log(`scaned ${row} ${col}`)
            const isCacheEnabled = (() => {
                switch (this.scanSkipMode) {
                    case SCAN_SKIP_MODE.SKIP_SCANNED_CHARM:
                        return true;
                    case SCAN_SKIP_MODE.SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE:
                        return page === this.prevPosition.page && col === this.prevPosition.col && row === this.prevPosition.row;
                    default:
                        return false;
                }
            })();
            this.prevPosition = { page, row, col };
            if (isCacheEnabled) {
                const cache = this._getCache({ page, row, col });
                if (cache != null) {
                    // console.log(`this charm is already scanned. skip: p${page} (${row}, ${col})`);
                    return { charm: cache, isCache: true };
                }
            }
            const rarity = this._getRarity(screenshot);
            const slots = this._getSlots(screenshot);
            const skills = this._getSkills(screenshot);
            const skillLevels = this._getSkillLevels(screenshot);
            skills.forEach((i, idx) => {
                if (i === '無し') {
                    skillLevels[idx] = 0;
                }
            });
            // console.log(JSON.stringify({col, row, match, page, rarity, slots, skills, skillLevels}, null, 2))
            const imageName = `${movieName}_${page}-${row}-${col}`;
            const charm = { page, row, col, rarity, slots, skills, skillLevels, imageName };
            this.nCharms++;
            this._setCache({ page, row, col }, charm);
            return { charm, isCache: false };
        }
        countCharms() {
            return this.nCharms;
        }
        exportAsText() {
            const buf = [];
            for (let p = 1; p <= MAX_PAGE; p++) {
                for (let r = 1; r <= this.ROWS_PER_PAGE; r++) {
                    for (let c = 1; c <= this.COLS_PER_PAGE; c++) {
                        const charm = this.charms[p][r][c];
                        if (charm == null) {
                            continue;
                        }
                        buf.push([
                            charm.skills[0],
                            charm.skillLevels[0],
                            charm.skills[1],
                            charm.skillLevels[1],
                            ...charm.slots,
                        ].join(','));
                    }
                }
            }
            return buf.join('\n');
        }
        getCharms() {
            const buf = [];
            for (let p = 1; p <= MAX_PAGE; p++) {
                for (let r = 1; r <= this.ROWS_PER_PAGE; r++) {
                    for (let c = 1; c <= this.COLS_PER_PAGE; c++) {
                        const charm = this.charms[p][r][c];
                        if (charm == null) {
                            continue;
                        }
                        buf.push(charm);
                    }
                }
            }
            return buf;
        }
        _getTrimRect(templates, point) {
            const template = Object.values(templates).shift();
            const size = new cv__default['default'].Size(template.cols, template.rows);
            const rect = new cv__default['default'].Rect(point, size);
            return rect;
        }
        _getRarity(screenshot) {
            const templates = MHRiseCharmScanner.templates.rare;
            const rect = this._getTrimRect(templates, this.POINT_RARITY);
            const diffThreshold = 63;
            return getMostMatchedImage(screenshot, templates, rect, diffThreshold).name;
        }
        _getSlots(screenshot) {
            const templates = MHRiseCharmScanner.templates.slot;
            const diffThreshold = 63;
            return [
                getMostMatchedImage(screenshot, templates, this._getTrimRect(templates, this.POINT_SLOT1), diffThreshold).name,
                getMostMatchedImage(screenshot, templates, this._getTrimRect(templates, this.POINT_SLOT2), diffThreshold).name,
                getMostMatchedImage(screenshot, templates, this._getTrimRect(templates, this.POINT_SLOT3), diffThreshold).name,
            ].map(i => parseInt(i));
        }
        _getSkills(screenshot) {
            const templates = MHRiseCharmScanner.templates.skill;
            const rect1 = this._getTrimRect(templates, this.POINT_SKILL1);
            const rect2 = this._getTrimRect(templates, this.POINT_SKILL2);
            const diffThreshold = 63;
            return [
                getMostMatchedImage(screenshot, templates, rect1, diffThreshold).name,
                getMostMatchedImage(screenshot, templates, rect2, diffThreshold).name,
            ];
        }
        _getSkillLevels(screenshot) {
            const templates = MHRiseCharmScanner.templates.lvl;
            const rect1 = this._getTrimRect(templates, this.POINT_SKILL_LEVEL1);
            const rect2 = this._getTrimRect(templates, this.POINT_SKILL_LEVEL2);
            const diffThreshold = 127;
            const filter = (input) => {
                const hsv = new cv__default['default'].Mat();
                cv__default['default'].cvtColor(input, hsv, cv__default['default'].COLOR_BGR2HSV, 3);
                const channels = new cv__default['default'].MatVector();
                cv__default['default'].split(hsv, channels);
                const brightness = channels.get(2);
                const binary = new cv__default['default'].Mat();
                cv__default['default'].threshold(brightness, binary, 110, 255, cv__default['default'].THRESH_OTSU);
                cv__default['default'].cvtColor(binary, input, cv__default['default'].COLOR_GRAY2BGRA);
                binary.delete();
                channels.delete();
                hsv.delete();
            };
            return [
                getMostMatchedImage(screenshot, templates, rect1, diffThreshold, filter).name,
                getMostMatchedImage(screenshot, templates, rect2, diffThreshold, filter).name,
            ].map(i => parseInt(i));
        }
        _getCurrentPage(screenshot) {
            // 1桁と仮定してマッチング
            const candidateForAssumingOneDigitNumber = (() => {
                const templates = MHRiseCharmScanner.templates.page;
                const rect = this._getTrimRect(templates, this.scanMode === SCAN_MODE.MODE_RINNE ? this.POINT_PAGE_IN_RINNE : this.POINT_PAGE);
                const diffThreshold = 127;
                return getMostMatchedImage(screenshot, templates, rect, diffThreshold);
            })();
            if (candidateForAssumingOneDigitNumber.diffCount === 0) {
                return parseInt(candidateForAssumingOneDigitNumber.name);
            }
            // setFirstCanvas()
            // const debug = (images: any) => {
            //   setNextCanvas(); dumpImage(images.trimmed)
            //   setNextCanvas(); dumpImage(images.templateImage)
            //   // setNextCanvas(); dumpImage(images.templateMask)
            //   // setNextCanvas(); dumpImage(images.masked)
            //   setNextCanvas(); dumpImage(images.diff)
            //   setNextCanvas(); dumpImage(images.result)
            //   dumpImageNewline()
            // }
            // 2桁と仮定してマッチング
            const candidateForAssumingTwoDigitNumber = (() => {
                const templates = MHRiseCharmScanner.templates['page-parts'];
                const rectForFirstDigit = this._getTrimRect(templates, this.scanMode === SCAN_MODE.MODE_RINNE ? this.POINT_PAGE_IN_RINNE : this.POINT_PAGE);
                const rectForSecondDigit = this._getTrimRect(templates, this.scanMode === SCAN_MODE.MODE_RINNE ? this.POINT_PAGE_SECOND_DIGIT_IN_RINNE : this.POINT_PAGE_SECOND_DIGIT);
                const diffThreshold = 127;
                const firstDigitCandidate = getMostMatchedImage(screenshot, templates, rectForFirstDigit, diffThreshold);
                const secondDigitCandidate = getMostMatchedImage(screenshot, templates, rectForSecondDigit, diffThreshold);
                return {
                    name: '' + firstDigitCandidate.name + secondDigitCandidate.name,
                    diffCount: firstDigitCandidate.diffCount + secondDigitCandidate.diffCount,
                };
            })();
            // 1桁/2桁で一致度が高い方を返す
            if (candidateForAssumingOneDigitNumber.diffCount < candidateForAssumingTwoDigitNumber.diffCount) {
                return parseInt(candidateForAssumingOneDigitNumber.name);
            }
            else {
                return parseInt(candidateForAssumingTwoDigitNumber.name);
            }
        }
        _getCurrentCharmPos(screenshot) {
            const template = MHRiseCharmScanner.templates.others.charmSelectFrame;
            // cv.cvtColor(template, template, cv.COLOR_BGR2GRAY)
            // cv.threshold(template, template, 63, 255, cv.THRESH_BINARY)
            const mask = template;
            const masked = new cv__default['default'].Mat();
            const maskedHsv = new cv__default['default'].Mat();
            const yellowInGrayScale = new cv__default['default'].Mat();
            let candidate = {
                row: null,
                col: null,
                match: 39, // ignore if less than 40
            };
            for (let row = 1; row <= this.ROWS_PER_PAGE; row++) {
                for (let col = 1; col <= this.COLS_PER_PAGE; col++) {
                    const point = new cv__default['default'].Point(this.POINT_CHARM_ICON_BASE.x + (col - 1) * 36, this.POINT_CHARM_ICON_BASE.y + (row - 1) * 41);
                    const rect = new cv__default['default'].Rect(point, this.SIZE_CHARM_ICON_FRAME);
                    const trimmed = screenshot.roi(rect); // アイコンを抽出
                    trimmed.copyTo(masked, mask); // フレーム以外をマスク
                    // 黄色っぽい色を抽出してカウント
                    cv__default['default'].cvtColor(masked, maskedHsv, cv__default['default'].COLOR_BGR2HSV, 3);
                    const yellow = maskByColor(maskedHsv, [70, 100, 100, 0], [120, 255, 255, 255]);
                    cv__default['default'].cvtColor(yellow, yellowInGrayScale, cv__default['default'].COLOR_RGBA2GRAY, 0);
                    const yellowCount = cv__default['default'].countNonZero(yellowInGrayScale);
                    yellow.delete();
                    // console.log({row, col, match: yellowCount})
                    if (yellowCount > candidate.match) {
                        candidate = { row, col, match: yellowCount };
                    }
                }
            }
            // console.log(candidate)
            yellowInGrayScale.delete();
            maskedHsv.delete();
            masked.delete();
            return {
                pos: [candidate.col, candidate.row],
                match: candidate.match / 400,
            };
        }
        // TODO: 元の関数と統合 (mode で分岐するように)
        _getCurrentCharmPosForRinne(screenshot) {
            const rect = new cv__default['default'].Rect(this.POINT_CHARM_AREA_IN_RINNE, this.SIZE_CHARM_AREA_IN_RINNE);
            const trimmed = screenshot.roi(rect);
            const template = MHRiseCharmScanner.templates.others.charmSelectFrameForRinne;
            const result = new cv__default['default'].Mat();
            cv__default['default'].matchTemplate(trimmed, template, result, cv__default['default'].TM_CCOEFF_NORMED);
            const { maxLoc, maxVal } = cv__default['default'].minMaxLoc(result);
            // debug
            // if (maxVal > 0.3) {
            //   console.log({ maxLoc, maxVal })
            //   const color = new cv.Scalar(0, 0, 255)
            //   const p2 = new cv.Point(maxLoc.x + template.cols, maxLoc.y + template.rows)
            //   cv.rectangle(trimmed, maxLoc, p2, color, cv.LINE_4)
            //   setFirstCanvas()
            //   dumpImage(trimmed)
            // }
            result.delete();
            trimmed.delete();
            return {
                pos: [
                    1 + Math.floor(0.5 + maxLoc.x / 41.0),
                    1 + Math.floor(0.5 + maxLoc.y / 41.0),
                ],
                match: maxVal,
            };
        }
    }

    /* src/components/parts/CharmMinimap.svelte generated by Svelte v3.38.2 */
    const file$e = "src/components/parts/CharmMinimap.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (43:8) {#each [...Array(colsPerPage + 1).keys()].slice(1) as col}
    function create_each_block_1$7(ctx) {
    	let td;
    	let td_class_value;

    	const block = {
    		c: function create() {
    			td = element("td");

    			attr_dev(td, "class", td_class_value = "" + (null_to_empty(/*getClassName*/ ctx[4](
    				{
    					row: /*row*/ ctx[8],
    					col: /*col*/ ctx[11]
    				},
    				/*currentCharm*/ ctx[3]
    			)) + " svelte-1epvvxw"));

    			add_location(td, file$e, 45, 8, 1536);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rowsPerPage, colsPerPage, currentCharm*/ 14 && td_class_value !== (td_class_value = "" + (null_to_empty(/*getClassName*/ ctx[4](
    				{
    					row: /*row*/ ctx[8],
    					col: /*col*/ ctx[11]
    				},
    				/*currentCharm*/ ctx[3]
    			)) + " svelte-1epvvxw"))) {
    				attr_dev(td, "class", td_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(43:8) {#each [...Array(colsPerPage + 1).keys()].slice(1) as col}",
    		ctx
    	});

    	return block;
    }

    // (41:6) {#each [...Array(rowsPerPage + 1).keys()].slice(1) as row}
    function create_each_block$9(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = [...Array(/*colsPerPage*/ ctx[2] + 1).keys()].slice(1);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(tr, "class", "svelte-1epvvxw");
    			add_location(tr, file$e, 41, 6, 1296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*getClassName, Array, rowsPerPage, colsPerPage, currentCharm*/ 30) {
    				each_value_1 = [...Array(/*colsPerPage*/ ctx[2] + 1).keys()].slice(1);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(41:6) {#each [...Array(rowsPerPage + 1).keys()].slice(1) as row}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let table;
    	let tbody;
    	let t0;
    	let t1;
    	let each_value = [...Array(/*rowsPerPage*/ ctx[1] + 1).keys()].slice(1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			t1 = text(/*page*/ ctx[0]);
    			attr_dev(tbody, "class", "svelte-1epvvxw");
    			add_location(tbody, file$e, 39, 4, 1217);
    			attr_dev(table, "class", "svelte-1epvvxw");
    			add_location(table, file$e, 38, 2, 1205);
    			attr_dev(div, "class", "minimap svelte-1epvvxw");
    			add_location(div, file$e, 37, 0, 1181);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Array, colsPerPage, getClassName, rowsPerPage, currentCharm*/ 30) {
    				each_value = [...Array(/*rowsPerPage*/ ctx[1] + 1).keys()].slice(1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*page*/ 1) set_data_dev(t1, /*page*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmMinimap", slots, []);
    	
    	let { page } = $$props;
    	let { rowsPerPage = ROWS_PER_PAGE_IN_EQLIST } = $$props;
    	let { colsPerPage = COLS_PER_PAGE_IN_EQLIST } = $$props;
    	let { currentCharm } = $$props;
    	let { charmScanner } = $$props;

    	// TODO: スキャン毎に全セル分呼ばれないようにする？
    	function getClassName({ row, col }) {
    		//  console.log(charmScanner.charms)
    		return [_getCharmClass({ row, col }), _isCurrentCharm({ row, col }) ? "current" : ""].join(" ");
    	}

    	function _getCharmClass({ row, col }) {
    		// return `rare${Math.floor(Math.random() * 7)}` // for debug
    		// const rarity = charmScanner?.charms?.[page]?.[row]?.[col]
    		const charm = charmScanner.charms[page][row][col];

    		if (charm == null) {
    			return "none";
    		}

    		return `rare${charm.rarity}`;
    	}

    	function _isCurrentCharm({ row, col }) {
    		// return row === 2 && col === 2
    		if (currentCharm == null) {
    			return false;
    		}

    		if (page !== currentCharm.page) {
    			return false;
    		}

    		return currentCharm.row === row && currentCharm.col === col;
    	}

    	const writable_props = ["page", "rowsPerPage", "colsPerPage", "currentCharm", "charmScanner"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmMinimap> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("page" in $$props) $$invalidate(0, page = $$props.page);
    		if ("rowsPerPage" in $$props) $$invalidate(1, rowsPerPage = $$props.rowsPerPage);
    		if ("colsPerPage" in $$props) $$invalidate(2, colsPerPage = $$props.colsPerPage);
    		if ("currentCharm" in $$props) $$invalidate(3, currentCharm = $$props.currentCharm);
    		if ("charmScanner" in $$props) $$invalidate(5, charmScanner = $$props.charmScanner);
    	};

    	$$self.$capture_state = () => ({
    		COLS_PER_PAGE_IN_EQLIST,
    		ROWS_PER_PAGE_IN_EQLIST,
    		MHRiseCharmScanner,
    		page,
    		rowsPerPage,
    		colsPerPage,
    		currentCharm,
    		charmScanner,
    		getClassName,
    		_getCharmClass,
    		_isCurrentCharm
    	});

    	$$self.$inject_state = $$props => {
    		if ("page" in $$props) $$invalidate(0, page = $$props.page);
    		if ("rowsPerPage" in $$props) $$invalidate(1, rowsPerPage = $$props.rowsPerPage);
    		if ("colsPerPage" in $$props) $$invalidate(2, colsPerPage = $$props.colsPerPage);
    		if ("currentCharm" in $$props) $$invalidate(3, currentCharm = $$props.currentCharm);
    		if ("charmScanner" in $$props) $$invalidate(5, charmScanner = $$props.charmScanner);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [page, rowsPerPage, colsPerPage, currentCharm, getClassName, charmScanner];
    }

    class CharmMinimap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			page: 0,
    			rowsPerPage: 1,
    			colsPerPage: 2,
    			currentCharm: 3,
    			charmScanner: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmMinimap",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*page*/ ctx[0] === undefined && !("page" in props)) {
    			console.warn("<CharmMinimap> was created without expected prop 'page'");
    		}

    		if (/*currentCharm*/ ctx[3] === undefined && !("currentCharm" in props)) {
    			console.warn("<CharmMinimap> was created without expected prop 'currentCharm'");
    		}

    		if (/*charmScanner*/ ctx[5] === undefined && !("charmScanner" in props)) {
    			console.warn("<CharmMinimap> was created without expected prop 'charmScanner'");
    		}
    	}

    	get page() {
    		throw new Error("<CharmMinimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<CharmMinimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rowsPerPage() {
    		throw new Error("<CharmMinimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rowsPerPage(value) {
    		throw new Error("<CharmMinimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get colsPerPage() {
    		throw new Error("<CharmMinimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set colsPerPage(value) {
    		throw new Error("<CharmMinimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentCharm() {
    		throw new Error("<CharmMinimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentCharm(value) {
    		throw new Error("<CharmMinimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get charmScanner() {
    		throw new Error("<CharmMinimap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set charmScanner(value) {
    		throw new Error("<CharmMinimap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/RecordButton.svelte generated by Svelte v3.38.2 */

    const file$d = "src/components/parts/RecordButton.svelte";

    function create_fragment$d(ctx) {
    	let div;
    	let button;
    	let t0;
    	let label_1;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = space();
    			label_1 = element("label");
    			t1 = text(/*label*/ ctx[1]);
    			attr_dev(button, "id", "rec-button");
    			attr_dev(button, "class", "svelte-1iksj0l");
    			toggle_class(button, "recording", /*isRecording*/ ctx[0]);
    			add_location(button, file$d, 6, 2, 90);
    			attr_dev(label_1, "for", "rec-button");
    			attr_dev(label_1, "class", "svelte-1iksj0l");
    			add_location(label_1, file$d, 10, 2, 223);
    			attr_dev(div, "class", "svelte-1iksj0l");
    			add_location(div, file$d, 5, 0, 82);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(div, t0);
    			append_dev(div, label_1);
    			append_dev(label_1, t1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isRecording*/ 1) {
    				toggle_class(button, "recording", /*isRecording*/ ctx[0]);
    			}

    			if (dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("RecordButton", slots, []);
    	let { isRecording = false } = $$props;
    	let { label = "Recording" } = $$props;
    	const writable_props = ["isRecording", "label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RecordButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, isRecording = !isRecording);

    	$$self.$$set = $$props => {
    		if ("isRecording" in $$props) $$invalidate(0, isRecording = $$props.isRecording);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({ isRecording, label });

    	$$self.$inject_state = $$props => {
    		if ("isRecording" in $$props) $$invalidate(0, isRecording = $$props.isRecording);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isRecording, label, click_handler];
    }

    class RecordButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { isRecording: 0, label: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RecordButton",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get isRecording() {
    		throw new Error("<RecordButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isRecording(value) {
    		throw new Error("<RecordButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<RecordButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<RecordButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/SvelteTable.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$3 } = globals;
    const file$c = "src/components/parts/SvelteTable.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    const get_after_row_slot_changes = dirty => ({ row: dirty[0] & /*c_rows*/ 8192 });
    const get_after_row_slot_context = ctx => ({ row: /*row*/ ctx[35], n: /*n*/ ctx[37] });

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    const get_row_slot_changes = dirty => ({ row: dirty[0] & /*c_rows*/ 8192 });
    const get_row_slot_context = ctx => ({ row: /*row*/ ctx[35], n: /*n*/ ctx[37] });

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    const get_header_slot_changes = dirty => ({
    	sortOrder: dirty[0] & /*sortOrder*/ 2,
    	sortBy: dirty[0] & /*sortBy*/ 1
    });

    const get_header_slot_context = ctx => ({
    	sortOrder: /*sortOrder*/ ctx[1],
    	sortBy: /*sortBy*/ ctx[0]
    });

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	child_ctx[43] = list;
    	child_ctx[44] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	return child_ctx;
    }

    // (125:4) {#if showFilterHeader}
    function create_if_block_4$1(ctx) {
    	let tr;
    	let each_value_3 = /*columns*/ ctx[3];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(tr, "class", "row-filter-header svelte-uczycn");
    			add_location(tr, file$c, 125, 6, 3921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filterSelections, columns, asStringArray, classNameSelect, filterValues*/ 37388) {
    				each_value_3 = /*columns*/ ctx[3];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(125:4) {#if showFilterHeader}",
    		ctx
    	});

    	return block;
    }

    // (131:58) 
    function create_if_block_6(ctx) {
    	let select;
    	let option;
    	let select_class_value;
    	let mounted;
    	let dispose;
    	let each_value_4 = /*filterValues*/ ctx[12][/*col*/ ctx[38].key];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	function select_change_handler() {
    		/*select_change_handler*/ ctx[28].call(select, /*col*/ ctx[38]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option = element("option");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			option.__value = undefined;
    			option.value = option.__value;
    			add_location(option, file$c, 132, 16, 4283);
    			attr_dev(select, "class", select_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameSelect*/ ctx[9])) + " svelte-uczycn"));
    			if (/*filterSelections*/ ctx[2][/*col*/ ctx[38].key] === void 0) add_render_callback(select_change_handler);
    			add_location(select, file$c, 131, 14, 4180);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*filterSelections*/ ctx[2][/*col*/ ctx[38].key]);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", select_change_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*filterValues, columns*/ 4104) {
    				each_value_4 = /*filterValues*/ ctx[12][/*col*/ ctx[38].key];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}

    			if (dirty[0] & /*classNameSelect*/ 512 && select_class_value !== (select_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameSelect*/ ctx[9])) + " svelte-uczycn"))) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty[0] & /*filterSelections, columns, filterValues*/ 4108) {
    				select_option(select, /*filterSelections*/ ctx[2][/*col*/ ctx[38].key]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(131:58) ",
    		ctx
    	});

    	return block;
    }

    // (129:12) {#if col.searchValue !== undefined}
    function create_if_block_5(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	function input_input_handler() {
    		/*input_input_handler*/ ctx[27].call(input, /*col*/ ctx[38]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			add_location(input, file$c, 129, 14, 4060);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*filterSelections*/ ctx[2][/*col*/ ctx[38].key]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_input_handler);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*filterSelections, columns, filterValues*/ 4108 && input.value !== /*filterSelections*/ ctx[2][/*col*/ ctx[38].key]) {
    				set_input_value(input, /*filterSelections*/ ctx[2][/*col*/ ctx[38].key]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(129:12) {#if col.searchValue !== undefined}",
    		ctx
    	});

    	return block;
    }

    // (134:16) {#each filterValues[col.key] as option}
    function create_each_block_4(ctx) {
    	let option;
    	let t_value = /*option*/ ctx[45].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*option*/ ctx[45].value;
    			option.value = option.__value;
    			add_location(option, file$c, 134, 18, 4393);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*filterValues, columns*/ 4104 && t_value !== (t_value = /*option*/ ctx[45].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*filterValues, columns*/ 4104 && option_value_value !== (option_value_value = /*option*/ ctx[45].value)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(134:16) {#each filterValues[col.key] as option}",
    		ctx
    	});

    	return block;
    }

    // (127:8) {#each columns as col}
    function create_each_block_3(ctx) {
    	let th;
    	let t;

    	function select_block_type(ctx, dirty) {
    		if (/*col*/ ctx[38].searchValue !== undefined) return create_if_block_5;
    		if (/*filterValues*/ ctx[12][/*col*/ ctx[38].key] !== undefined) return create_if_block_6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			th = element("th");
    			if (if_block) if_block.c();
    			t = space();
    			add_location(th, file$c, 127, 10, 3993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			if (if_block) if_block.m(th, null);
    			append_dev(th, t);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(th, t);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(127:8) {#each columns as col}",
    		ctx
    	});

    	return block;
    }

    // (156:10) {:else}
    function create_else_block_1$1(ctx) {
    	let th;
    	let t0_value = /*col*/ ctx[38].title + "";
    	let t0;
    	let t1;
    	let t2;
    	let th_class_value;
    	let if_block = /*sortBy*/ ctx[0] === /*col*/ ctx[38].key && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			attr_dev(th, "class", th_class_value = "" + (null_to_empty(/*col*/ ctx[38].headerClass) + " svelte-uczycn"));
    			add_location(th, file$c, 156, 12, 5067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, t0);
    			append_dev(th, t1);
    			if (if_block) if_block.m(th, null);
    			append_dev(th, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columns*/ 8 && t0_value !== (t0_value = /*col*/ ctx[38].title + "")) set_data_dev(t0, t0_value);

    			if (/*sortBy*/ ctx[0] === /*col*/ ctx[38].key) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(th, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*columns, filterValues*/ 4104 && th_class_value !== (th_class_value = "" + (null_to_empty(/*col*/ ctx[38].headerClass) + " svelte-uczycn"))) {
    				attr_dev(th, "class", th_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(156:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (146:10) {#if col.sortable}
    function create_if_block_1$5(ctx) {
    	let th;
    	let t0_value = /*col*/ ctx[38].title + "";
    	let t0;
    	let t1;
    	let t2;
    	let th_class_value;
    	let mounted;
    	let dispose;
    	let if_block = /*sortBy*/ ctx[0] === /*col*/ ctx[38].key && create_if_block_2$5(ctx);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[29](/*col*/ ctx[38], ...args);
    	}

    	const block = {
    		c: function create() {
    			th = element("th");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			attr_dev(th, "class", th_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](["isSortable", /*col*/ ctx[38].headerClass])) + " svelte-uczycn"));
    			add_location(th, file$c, 146, 12, 4736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    			append_dev(th, t0);
    			append_dev(th, t1);
    			if (if_block) if_block.m(th, null);
    			append_dev(th, t2);

    			if (!mounted) {
    				dispose = listen_dev(th, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*columns*/ 8 && t0_value !== (t0_value = /*col*/ ctx[38].title + "")) set_data_dev(t0, t0_value);

    			if (/*sortBy*/ ctx[0] === /*col*/ ctx[38].key) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$5(ctx);
    					if_block.c();
    					if_block.m(th, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*columns, filterValues*/ 4104 && th_class_value !== (th_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](["isSortable", /*col*/ ctx[38].headerClass])) + " svelte-uczycn"))) {
    				attr_dev(th, "class", th_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(146:10) {#if col.sortable}",
    		ctx
    	});

    	return block;
    }

    // (161:14) {#if sortBy === col.key}
    function create_if_block_3$1(ctx) {
    	let t_value = (/*sortOrder*/ ctx[1] === 1
    	? /*iconAsc*/ ctx[4]
    	: /*iconDesc*/ ctx[5]) + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*sortOrder, iconAsc, iconDesc*/ 50 && t_value !== (t_value = (/*sortOrder*/ ctx[1] === 1
    			? /*iconAsc*/ ctx[4]
    			: /*iconDesc*/ ctx[5]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(161:14) {#if sortBy === col.key}",
    		ctx
    	});

    	return block;
    }

    // (152:14) {#if sortBy === col.key}
    function create_if_block_2$5(ctx) {
    	let t_value = (/*sortOrder*/ ctx[1] === 1
    	? /*iconAsc*/ ctx[4]
    	: /*iconDesc*/ ctx[5]) + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*sortOrder, iconAsc, iconDesc*/ 50 && t_value !== (t_value = (/*sortOrder*/ ctx[1] === 1
    			? /*iconAsc*/ ctx[4]
    			: /*iconDesc*/ ctx[5]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(152:14) {#if sortBy === col.key}",
    		ctx
    	});

    	return block;
    }

    // (145:8) {#each columns as col}
    function create_each_block_2$2(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*col*/ ctx[38].sortable) return create_if_block_1$5;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(145:8) {#each columns as col}",
    		ctx
    	});

    	return block;
    }

    // (143:62)        
    function fallback_block_2(ctx) {
    	let tr;
    	let each_value_2 = /*columns*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(tr, "class", "row-title-header");
    			add_location(tr, file$c, 143, 6, 4634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*asStringArray, columns, handleClickCol, sortOrder, iconAsc, iconDesc, sortBy*/ 98363) {
    				each_value_2 = /*columns*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(143:62)        ",
    		ctx
    	});

    	return block;
    }

    // (185:14) {:else}
    function create_else_block$6(ctx) {
    	let html_tag;

    	let raw_value = (/*col*/ ctx[38].renderValue
    	? /*col*/ ctx[38].renderValue(/*row*/ ctx[35])
    	: /*col*/ ctx[38].value(/*row*/ ctx[35])) + "";

    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*columns, c_rows*/ 8200 && raw_value !== (raw_value = (/*col*/ ctx[38].renderValue
    			? /*col*/ ctx[38].renderValue(/*row*/ ctx[35])
    			: /*col*/ ctx[38].value(/*row*/ ctx[35])) + "")) html_tag.p(raw_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(185:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (179:14) {#if col.renderComponent}
    function create_if_block$6(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		/*col*/ ctx[38].renderComponent.props || {},
    		{ row: /*row*/ ctx[35] },
    		{ col: /*col*/ ctx[38] }
    	];

    	var switch_value = /*col*/ ctx[38].renderComponent.component || /*col*/ ctx[38].renderComponent;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*columns, c_rows*/ 8200)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty[0] & /*columns*/ 8 && get_spread_object(/*col*/ ctx[38].renderComponent.props || {}),
    					dirty[0] & /*c_rows*/ 8192 && { row: /*row*/ ctx[35] },
    					dirty[0] & /*columns*/ 8 && { col: /*col*/ ctx[38] }
    				])
    			: {};

    			if (switch_value !== (switch_value = /*col*/ ctx[38].renderComponent.component || /*col*/ ctx[38].renderComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(179:14) {#if col.renderComponent}",
    		ctx
    	});

    	return block;
    }

    // (174:10) {#each columns as col}
    function create_each_block_1$6(ctx) {
    	let td;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let td_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$6, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*col*/ ctx[38].renderComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[30](/*row*/ ctx[35], /*col*/ ctx[38], ...args);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			if_block.c();
    			t = space();
    			attr_dev(td, "class", td_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15]([/*col*/ ctx[38].class, /*classNameCell*/ ctx[11]])) + " svelte-uczycn"));
    			add_location(td, file$c, 174, 12, 5602);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			if_blocks[current_block_type_index].m(td, null);
    			append_dev(td, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(td, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(td, t);
    			}

    			if (!current || dirty[0] & /*columns, classNameCell, filterValues*/ 6152 && td_class_value !== (td_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15]([/*col*/ ctx[38].class, /*classNameCell*/ ctx[11]])) + " svelte-uczycn"))) {
    				attr_dev(td, "class", td_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(174:10) {#each columns as col}",
    		ctx
    	});

    	return block;
    }

    // (172:40)          
    function fallback_block_1(ctx) {
    	let tr;
    	let tr_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*columns*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	function click_handler_2(...args) {
    		return /*click_handler_2*/ ctx[31](/*row*/ ctx[35], ...args);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(tr, "class", tr_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameRow*/ ctx[10])) + " svelte-uczycn"));
    			add_location(tr, file$c, 172, 8, 5475);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*asStringArray, columns, classNameCell, handleClickCell, c_rows*/ 305160) {
    				each_value_1 = /*columns*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tr, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*classNameRow*/ 1024 && tr_class_value !== (tr_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameRow*/ ctx[10])) + " svelte-uczycn"))) {
    				attr_dev(tr, "class", tr_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(172:40)          ",
    		ctx
    	});

    	return block;
    }

    // (171:4) {#each c_rows as row, n}
    function create_each_block$8(ctx) {
    	let t;
    	let current;
    	const row_slot_template = /*#slots*/ ctx[26].row;
    	const row_slot = create_slot(row_slot_template, ctx, /*$$scope*/ ctx[25], get_row_slot_context);
    	const row_slot_or_fallback = row_slot || fallback_block_1(ctx);
    	const after_row_slot_template = /*#slots*/ ctx[26]["after-row"];
    	const after_row_slot = create_slot(after_row_slot_template, ctx, /*$$scope*/ ctx[25], get_after_row_slot_context);

    	const block = {
    		c: function create() {
    			if (row_slot_or_fallback) row_slot_or_fallback.c();
    			t = space();
    			if (after_row_slot) after_row_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (row_slot_or_fallback) {
    				row_slot_or_fallback.m(target, anchor);
    			}

    			insert_dev(target, t, anchor);

    			if (after_row_slot) {
    				after_row_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (row_slot) {
    				if (row_slot.p && (!current || dirty[0] & /*$$scope, c_rows*/ 33562624)) {
    					update_slot(row_slot, row_slot_template, ctx, /*$$scope*/ ctx[25], dirty, get_row_slot_changes, get_row_slot_context);
    				}
    			} else {
    				if (row_slot_or_fallback && row_slot_or_fallback.p && dirty[0] & /*classNameRow, c_rows, columns, classNameCell*/ 11272) {
    					row_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (after_row_slot) {
    				if (after_row_slot.p && (!current || dirty[0] & /*$$scope, c_rows*/ 33562624)) {
    					update_slot(after_row_slot, after_row_slot_template, ctx, /*$$scope*/ ctx[25], dirty, get_after_row_slot_changes, get_after_row_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row_slot_or_fallback, local);
    			transition_in(after_row_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row_slot_or_fallback, local);
    			transition_out(after_row_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (row_slot_or_fallback) row_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t);
    			if (after_row_slot) after_row_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(171:4) {#each c_rows as row, n}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let table;
    	let thead;
    	let t0;
    	let thead_class_value;
    	let t1;
    	let tbody;
    	let tbody_class_value;
    	let table_class_value;
    	let current;
    	let if_block = /*showFilterHeader*/ ctx[14] && create_if_block_4$1(ctx);
    	const header_slot_template = /*#slots*/ ctx[26].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[25], get_header_slot_context);
    	const header_slot_or_fallback = header_slot || fallback_block_2(ctx);
    	let each_value = /*c_rows*/ ctx[13];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			if (if_block) if_block.c();
    			t0 = space();
    			if (header_slot_or_fallback) header_slot_or_fallback.c();
    			t1 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(thead, "class", thead_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameThead*/ ctx[7])) + " svelte-uczycn"));
    			add_location(thead, file$c, 123, 2, 3842);
    			attr_dev(tbody, "class", tbody_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameTbody*/ ctx[8])) + " svelte-uczycn"));
    			add_location(tbody, file$c, 169, 2, 5351);
    			attr_dev(table, "class", table_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameTable*/ ctx[6])) + " svelte-uczycn"));
    			add_location(table, file$c, 122, 0, 3794);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			if (if_block) if_block.m(thead, null);
    			append_dev(thead, t0);

    			if (header_slot_or_fallback) {
    				header_slot_or_fallback.m(thead, null);
    			}

    			append_dev(table, t1);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*showFilterHeader*/ ctx[14]) if_block.p(ctx, dirty);

    			if (header_slot) {
    				if (header_slot.p && (!current || dirty[0] & /*$$scope, sortOrder, sortBy*/ 33554435)) {
    					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[25], dirty, get_header_slot_changes, get_header_slot_context);
    				}
    			} else {
    				if (header_slot_or_fallback && header_slot_or_fallback.p && dirty[0] & /*columns, sortOrder, iconAsc, iconDesc, sortBy*/ 59) {
    					header_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty[0] & /*classNameThead*/ 128 && thead_class_value !== (thead_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameThead*/ ctx[7])) + " svelte-uczycn"))) {
    				attr_dev(thead, "class", thead_class_value);
    			}

    			if (dirty[0] & /*$$scope, c_rows, asStringArray, classNameRow, handleClickRow, columns, classNameCell, handleClickCell*/ 33991688) {
    				each_value = /*c_rows*/ ctx[13];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*classNameTbody*/ 256 && tbody_class_value !== (tbody_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameTbody*/ ctx[8])) + " svelte-uczycn"))) {
    				attr_dev(tbody, "class", tbody_class_value);
    			}

    			if (!current || dirty[0] & /*classNameTable*/ 64 && table_class_value !== (table_class_value = "" + (null_to_empty(/*asStringArray*/ ctx[15](/*classNameTable*/ ctx[6])) + " svelte-uczycn"))) {
    				attr_dev(table, "class", table_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot_or_fallback, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot_or_fallback, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if (if_block) if_block.d();
    			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let c_rows;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SvelteTable", slots, ['header','row','after-row']);
    	const dispatch = createEventDispatcher();
    	let { columns } = $$props;
    	let { rows } = $$props;
    	let { sortBy = "" } = $$props;
    	let { sortOrder = 1 } = $$props;
    	let { iconAsc = "▲" } = $$props;
    	let { iconDesc = "▼" } = $$props;
    	let { classNameTable = "" } = $$props;
    	let { classNameThead = "" } = $$props;
    	let { classNameTbody = "" } = $$props;
    	let { classNameSelect = "" } = $$props;
    	let { classNameRow = "" } = $$props;
    	let { classNameCell = "" } = $$props;
    	let { filterSelections = {} } = $$props;
    	let { sliceBegin = null } = $$props;
    	let { sliceEnd = null } = $$props;
    	let { disableFilterHeader = false } = $$props;
    	let sortFunction = () => "";

    	let showFilterHeader = !disableFilterHeader && columns.some(c => {
    		// check if there are any filter or search headers
    		return c.filterOptions !== undefined || c.searchValue !== undefined;
    	});

    	let filterValues = {};

    	//let searchValues = {};
    	let columnByKey = {};

    	columns.forEach(col => {
    		$$invalidate(24, columnByKey[col.key] = col, columnByKey);
    	});

    	const asStringArray = v => [].concat(v).filter(v => typeof v === "string" && v !== "").join(" ");

    	const calculateFilterValues = () => {
    		$$invalidate(12, filterValues = {});

    		columns.forEach(c => {
    			if (typeof c.filterOptions === "function") {
    				$$invalidate(12, filterValues[c.key] = c.filterOptions(rows), filterValues);
    			} else if (Array.isArray(c.filterOptions)) {
    				// if array of strings is provided, use it for name and value
    				$$invalidate(12, filterValues[c.key] = c.filterOptions.map(val => ({ name: val, value: val })), filterValues);
    			}
    		});
    	};

    	
    	

    	const updateSortOrder = colKey => {
    		if (colKey === sortBy) {
    			$$invalidate(1, sortOrder = sortOrder === 1 ? -1 : 1);
    		} else {
    			$$invalidate(1, sortOrder = 1);
    		}
    	};

    	const handleClickCol = (event, col) => {
    		updateSortOrder(col.key);
    		$$invalidate(0, sortBy = col.key);
    		dispatch("clickCol", { event, col, key: col.key });
    	};

    	const handleClickRow = (event, row) => {
    		dispatch("clickRow", { event, row });
    	};

    	const handleClickCell = (event, row, key) => {
    		dispatch("clickCell", { event, row, key });
    	};

    	const writable_props = [
    		"columns",
    		"rows",
    		"sortBy",
    		"sortOrder",
    		"iconAsc",
    		"iconDesc",
    		"classNameTable",
    		"classNameThead",
    		"classNameTbody",
    		"classNameSelect",
    		"classNameRow",
    		"classNameCell",
    		"filterSelections",
    		"sliceBegin",
    		"sliceEnd",
    		"disableFilterHeader"
    	];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SvelteTable> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler(col) {
    		filterSelections[col.key] = this.value;
    		$$invalidate(2, filterSelections);
    		$$invalidate(3, columns);
    		$$invalidate(12, filterValues);
    	}

    	function select_change_handler(col) {
    		filterSelections[col.key] = select_value(this);
    		$$invalidate(2, filterSelections);
    		$$invalidate(3, columns);
    		$$invalidate(12, filterValues);
    	}

    	const click_handler = (col, e) => handleClickCol(e, col);

    	const click_handler_1 = (row, col, e) => {
    		handleClickCell(e, row, col.key);
    	};

    	const click_handler_2 = (row, e) => {
    		handleClickRow(e, row);
    	};

    	$$self.$$set = $$props => {
    		if ("columns" in $$props) $$invalidate(3, columns = $$props.columns);
    		if ("rows" in $$props) $$invalidate(19, rows = $$props.rows);
    		if ("sortBy" in $$props) $$invalidate(0, sortBy = $$props.sortBy);
    		if ("sortOrder" in $$props) $$invalidate(1, sortOrder = $$props.sortOrder);
    		if ("iconAsc" in $$props) $$invalidate(4, iconAsc = $$props.iconAsc);
    		if ("iconDesc" in $$props) $$invalidate(5, iconDesc = $$props.iconDesc);
    		if ("classNameTable" in $$props) $$invalidate(6, classNameTable = $$props.classNameTable);
    		if ("classNameThead" in $$props) $$invalidate(7, classNameThead = $$props.classNameThead);
    		if ("classNameTbody" in $$props) $$invalidate(8, classNameTbody = $$props.classNameTbody);
    		if ("classNameSelect" in $$props) $$invalidate(9, classNameSelect = $$props.classNameSelect);
    		if ("classNameRow" in $$props) $$invalidate(10, classNameRow = $$props.classNameRow);
    		if ("classNameCell" in $$props) $$invalidate(11, classNameCell = $$props.classNameCell);
    		if ("filterSelections" in $$props) $$invalidate(2, filterSelections = $$props.filterSelections);
    		if ("sliceBegin" in $$props) $$invalidate(20, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(21, sliceEnd = $$props.sliceEnd);
    		if ("disableFilterHeader" in $$props) $$invalidate(22, disableFilterHeader = $$props.disableFilterHeader);
    		if ("$$scope" in $$props) $$invalidate(25, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		columns,
    		rows,
    		sortBy,
    		sortOrder,
    		iconAsc,
    		iconDesc,
    		classNameTable,
    		classNameThead,
    		classNameTbody,
    		classNameSelect,
    		classNameRow,
    		classNameCell,
    		filterSelections,
    		sliceBegin,
    		sliceEnd,
    		disableFilterHeader,
    		sortFunction,
    		showFilterHeader,
    		filterValues,
    		columnByKey,
    		asStringArray,
    		calculateFilterValues,
    		updateSortOrder,
    		handleClickCol,
    		handleClickRow,
    		handleClickCell,
    		c_rows
    	});

    	$$self.$inject_state = $$props => {
    		if ("columns" in $$props) $$invalidate(3, columns = $$props.columns);
    		if ("rows" in $$props) $$invalidate(19, rows = $$props.rows);
    		if ("sortBy" in $$props) $$invalidate(0, sortBy = $$props.sortBy);
    		if ("sortOrder" in $$props) $$invalidate(1, sortOrder = $$props.sortOrder);
    		if ("iconAsc" in $$props) $$invalidate(4, iconAsc = $$props.iconAsc);
    		if ("iconDesc" in $$props) $$invalidate(5, iconDesc = $$props.iconDesc);
    		if ("classNameTable" in $$props) $$invalidate(6, classNameTable = $$props.classNameTable);
    		if ("classNameThead" in $$props) $$invalidate(7, classNameThead = $$props.classNameThead);
    		if ("classNameTbody" in $$props) $$invalidate(8, classNameTbody = $$props.classNameTbody);
    		if ("classNameSelect" in $$props) $$invalidate(9, classNameSelect = $$props.classNameSelect);
    		if ("classNameRow" in $$props) $$invalidate(10, classNameRow = $$props.classNameRow);
    		if ("classNameCell" in $$props) $$invalidate(11, classNameCell = $$props.classNameCell);
    		if ("filterSelections" in $$props) $$invalidate(2, filterSelections = $$props.filterSelections);
    		if ("sliceBegin" in $$props) $$invalidate(20, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(21, sliceEnd = $$props.sliceEnd);
    		if ("disableFilterHeader" in $$props) $$invalidate(22, disableFilterHeader = $$props.disableFilterHeader);
    		if ("sortFunction" in $$props) $$invalidate(23, sortFunction = $$props.sortFunction);
    		if ("showFilterHeader" in $$props) $$invalidate(14, showFilterHeader = $$props.showFilterHeader);
    		if ("filterValues" in $$props) $$invalidate(12, filterValues = $$props.filterValues);
    		if ("columnByKey" in $$props) $$invalidate(24, columnByKey = $$props.columnByKey);
    		if ("c_rows" in $$props) $$invalidate(13, c_rows = $$props.c_rows);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*columnByKey, sortBy*/ 16777217) {
    			{
    				let col = columnByKey[sortBy];

    				if (col !== undefined && col.sortable === true && typeof col.value === "function") {
    					$$invalidate(23, sortFunction = r => col.value(r));
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*rows, filterSelections, columnByKey, sortFunction, sortOrder, sliceBegin, sliceEnd*/ 28835846) {
    			$$invalidate(13, c_rows = rows.filter(r => {
    				// get search and filter results/matches
    				return Object.keys(filterSelections).every(f => {
    					// check search (text input) matches
    					let resSearch = filterSelections[f] === "" || columnByKey[f].searchValue && (columnByKey[f].searchValue(r) + "").toLocaleLowerCase().indexOf((filterSelections[f] + "").toLocaleLowerCase()) >= 0;

    					// check filter (dropdown) matches
    					let resFilter = resSearch || filterSelections[f] === undefined || // default to value() if filterValue() not provided in col
    					filterSelections[f] === (typeof columnByKey[f].filterValue === "function"
    					? columnByKey[f].filterValue(r)
    					: columnByKey[f].value(r));

    					return resFilter;
    				});
    			}).map(r => Object.assign({}, r, { $sortOn: sortFunction(r) })).sort((a, b) => {
    				if (a.$sortOn > b.$sortOn) return sortOrder; else if (a.$sortOn < b.$sortOn) return -sortOrder;
    				return 0;
    			}).slice(sliceBegin || 0, sliceEnd || undefined));
    		}

    		if ($$self.$$.dirty[0] & /*columns, rows*/ 524296) {
    			{
    				// if filters are enabled, watch rows and columns
    				if (showFilterHeader && columns && rows) {
    					calculateFilterValues();
    				}
    			}
    		}
    	};

    	return [
    		sortBy,
    		sortOrder,
    		filterSelections,
    		columns,
    		iconAsc,
    		iconDesc,
    		classNameTable,
    		classNameThead,
    		classNameTbody,
    		classNameSelect,
    		classNameRow,
    		classNameCell,
    		filterValues,
    		c_rows,
    		showFilterHeader,
    		asStringArray,
    		handleClickCol,
    		handleClickRow,
    		handleClickCell,
    		rows,
    		sliceBegin,
    		sliceEnd,
    		disableFilterHeader,
    		sortFunction,
    		columnByKey,
    		$$scope,
    		slots,
    		input_input_handler,
    		select_change_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class SvelteTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$c,
    			create_fragment$c,
    			safe_not_equal,
    			{
    				columns: 3,
    				rows: 19,
    				sortBy: 0,
    				sortOrder: 1,
    				iconAsc: 4,
    				iconDesc: 5,
    				classNameTable: 6,
    				classNameThead: 7,
    				classNameTbody: 8,
    				classNameSelect: 9,
    				classNameRow: 10,
    				classNameCell: 11,
    				filterSelections: 2,
    				sliceBegin: 20,
    				sliceEnd: 21,
    				disableFilterHeader: 22
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvelteTable",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*columns*/ ctx[3] === undefined && !("columns" in props)) {
    			console.warn("<SvelteTable> was created without expected prop 'columns'");
    		}

    		if (/*rows*/ ctx[19] === undefined && !("rows" in props)) {
    			console.warn("<SvelteTable> was created without expected prop 'rows'");
    		}
    	}

    	get columns() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columns(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortBy() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortBy(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortOrder() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortOrder(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconAsc() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconAsc(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDesc() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDesc(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameTable() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameTable(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameThead() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameThead(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameTbody() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameTbody(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameSelect() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameSelect(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameRow() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameRow(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classNameCell() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classNameCell(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterSelections() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterSelections(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliceBegin() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliceBegin(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliceEnd() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliceEnd(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableFilterHeader() {
    		throw new Error("<SvelteTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableFilterHeader(value) {
    		throw new Error("<SvelteTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CharmTable.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$2, console: console_1$1 } = globals;

    const file$b = "src/components/parts/CharmTable.svelte";

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	return child_ctx;
    }

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    // (194:10) {:else}
    function create_else_block_1(ctx) {
    	let html_tag;

    	let raw_value = (/*col*/ ctx[28].renderValue
    	? /*col*/ ctx[28].renderValue(/*row*/ ctx[23])
    	: /*col*/ ctx[28].value(/*row*/ ctx[23])) + "";

    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*row*/ 8388608 && raw_value !== (raw_value = (/*col*/ ctx[28].renderValue
    			? /*col*/ ctx[28].renderValue(/*row*/ ctx[23])
    			: /*col*/ ctx[28].value(/*row*/ ctx[23])) + "")) html_tag.p(raw_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(194:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (188:10) {#if col.renderComponent}
    function create_if_block_4(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		/*col*/ ctx[28].renderComponent.props || {},
    		{ row: /*row*/ ctx[23] },
    		{ col: /*col*/ ctx[28] }
    	];

    	var switch_value = /*col*/ ctx[28].renderComponent.component || /*col*/ ctx[28].renderComponent;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*columns, row*/ 8388736)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty[0] & /*columns*/ 128 && get_spread_object(/*col*/ ctx[28].renderComponent.props || {}),
    					dirty[0] & /*row*/ 8388608 && { row: /*row*/ ctx[23] },
    					dirty[0] & /*columns*/ 128 && { col: /*col*/ ctx[28] }
    				])
    			: {};

    			if (switch_value !== (switch_value = /*col*/ ctx[28].renderComponent.component || /*col*/ ctx[28].renderComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(188:10) {#if col.renderComponent}",
    		ctx
    	});

    	return block;
    }

    // (184:6) {#each columns as col}
    function create_each_block_1$5(ctx) {
    	let td;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_4, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*col*/ ctx[28].renderComponent) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[14](/*col*/ ctx[28], /*row*/ ctx[23], /*n*/ ctx[27], ...args);
    	}

    	const block = {
    		c: function create() {
    			td = element("td");
    			if_block.c();
    			t = space();
    			attr_dev(td, "class", "" + (null_to_empty([/*col*/ ctx[28].class].join(" ")) + " svelte-1bydddo"));
    			add_location(td, file$b, 184, 8, 8026);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			if_blocks[current_block_type_index].m(td, null);
    			append_dev(td, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(td, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(184:6) {#each columns as col}",
    		ctx
    	});

    	return block;
    }

    // (183:4) 
    function create_row_slot(ctx) {
    	let tr;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*columns*/ ctx[7];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[15](/*row*/ ctx[23]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(tr, "slot", "row");
    			add_location(tr, file$b, 182, 4, 7924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*columns, row*/ 8388736) {
    				each_value_1 = /*columns*/ ctx[7];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(tr, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_row_slot.name,
    		type: "slot",
    		source: "(183:4) ",
    		ctx
    	});

    	return block;
    }

    // (201:6) {#if isSubstitutableCharmsShown[row.rowid]}
    function create_if_block_1$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$4, create_if_block_3, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*row*/ ctx[23].substitutableCharms == null) return 0;
    		if (/*row*/ ctx[23].substitutableCharms.length === 0) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(201:6) {#if isSubstitutableCharmsShown[row.rowid]}",
    		ctx
    	});

    	return block;
    }

    // (206:8) {:else}
    function create_else_block$5(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	let each_value = /*row*/ ctx[23].substitutableCharms;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "row-substitutes");
    			add_location(div, file$b, 206, 10, 8939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*row*/ 8388608) {
    				each_value = /*row*/ ctx[23].substitutableCharms;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 150 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 150 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(206:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (204:55) 
    function create_if_block_3(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(204:55) ",
    		ctx
    	});

    	return block;
    }

    // (202:8) {#if row.substitutableCharms == null}
    function create_if_block_2$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "searching...";
    			set_style(div, "width", "100%");
    			set_style(div, "border-bottom", "solid 1px #ddd");
    			add_location(div, file$b, 202, 10, 8758);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(202:8) {#if row.substitutableCharms == null}",
    		ctx
    	});

    	return block;
    }

    // (208:10) {#each row.substitutableCharms as c}
    function create_each_block$7(ctx) {
    	let div;
    	let t0_value = /*c*/ ctx[24].rowid + "";
    	let t0;
    	let t1;
    	let t2_value = /*c*/ ctx[24].skill1 + "";
    	let t2;
    	let t3_value = /*c*/ ctx[24].skill1Level + "";
    	let t3;
    	let t4;
    	let t5_value = /*c*/ ctx[24].skill2 + "";
    	let t5;
    	let t6_value = /*c*/ ctx[24].skill2Level + "";
    	let t6;
    	let t7;
    	let t8_value = /*c*/ ctx[24].slot1 + "";
    	let t8;
    	let t9;
    	let t10_value = /*c*/ ctx[24].slot2 + "";
    	let t10;
    	let t11;
    	let t12_value = /*c*/ ctx[24].slot3 + "";
    	let t12;
    	let t13;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text(": ");
    			t2 = text(t2_value);
    			t3 = text(t3_value);
    			t4 = text(", ");
    			t5 = text(t5_value);
    			t6 = text(t6_value);
    			t7 = text(", ");
    			t8 = text(t8_value);
    			t9 = text("-");
    			t10 = text(t10_value);
    			t11 = text("-");
    			t12 = text(t12_value);
    			t13 = space();
    			set_style(div, "width", "100%");
    			set_style(div, "text-align", "left");
    			set_style(div, "padding", "0.3rem 2rem");
    			add_location(div, file$b, 208, 12, 9063);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			append_dev(div, t5);
    			append_dev(div, t6);
    			append_dev(div, t7);
    			append_dev(div, t8);
    			append_dev(div, t9);
    			append_dev(div, t10);
    			append_dev(div, t11);
    			append_dev(div, t12);
    			append_dev(div, t13);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*row*/ 8388608 && t0_value !== (t0_value = /*c*/ ctx[24].rowid + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*row*/ 8388608 && t2_value !== (t2_value = /*c*/ ctx[24].skill1 + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*row*/ 8388608 && t3_value !== (t3_value = /*c*/ ctx[24].skill1Level + "")) set_data_dev(t3, t3_value);
    			if (dirty[0] & /*row*/ 8388608 && t5_value !== (t5_value = /*c*/ ctx[24].skill2 + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*row*/ 8388608 && t6_value !== (t6_value = /*c*/ ctx[24].skill2Level + "")) set_data_dev(t6, t6_value);
    			if (dirty[0] & /*row*/ 8388608 && t8_value !== (t8_value = /*c*/ ctx[24].slot1 + "")) set_data_dev(t8, t8_value);
    			if (dirty[0] & /*row*/ 8388608 && t10_value !== (t10_value = /*c*/ ctx[24].slot2 + "")) set_data_dev(t10, t10_value);
    			if (dirty[0] & /*row*/ 8388608 && t12_value !== (t12_value = /*c*/ ctx[24].slot3 + "")) set_data_dev(t12, t12_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(208:10) {#each row.substitutableCharms as c}",
    		ctx
    	});

    	return block;
    }

    // (217:6) {#if isScreenshotShown[row.rowid]}
    function create_if_block$5(ctx) {
    	let div;
    	let canvas;
    	let canvas_id_value;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			canvas = element("canvas");
    			attr_dev(canvas, "id", canvas_id_value = "charm-table-row-" + /*row*/ ctx[23].rowid + "-screenshot");
    			set_style(canvas, "width", "100%");
    			add_location(canvas, file$b, 218, 10, 9470);
    			set_style(div, "width", "100%");
    			set_style(div, "border-bottom", "solid 1px #ddd");
    			add_location(div, file$b, 217, 8, 9368);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, canvas);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*row*/ 8388608 && canvas_id_value !== (canvas_id_value = "charm-table-row-" + /*row*/ ctx[23].rowid + "-screenshot")) {
    				attr_dev(canvas, "id", canvas_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 100 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(217:6) {#if isScreenshotShown[row.rowid]}",
    		ctx
    	});

    	return block;
    }

    // (200:4) 
    function create_after_row_slot(ctx) {
    	let div;
    	let t;
    	let div_id_value;
    	let current;
    	let if_block0 = /*isSubstitutableCharmsShown*/ ctx[5][/*row*/ ctx[23].rowid] && create_if_block_1$4(ctx);
    	let if_block1 = /*isScreenshotShown*/ ctx[4][/*row*/ ctx[23].rowid] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "slot", "after-row");
    			attr_dev(div, "id", div_id_value = "charm-table-row-" + /*row*/ ctx[23].rowid);
    			set_style(div, "width", "100%");
    			add_location(div, file$b, 199, 4, 8568);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isSubstitutableCharmsShown*/ ctx[5][/*row*/ ctx[23].rowid]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*isSubstitutableCharmsShown, row*/ 8388640) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isScreenshotShown*/ ctx[4][/*row*/ ctx[23].rowid]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isScreenshotShown, row*/ 8388624) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*row*/ 8388608 && div_id_value !== (div_id_value = "charm-table-row-" + /*row*/ ctx[23].rowid)) {
    				attr_dev(div, "id", div_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_after_row_slot.name,
    		type: "slot",
    		source: "(200:4) ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div;
    	let sveltetable;
    	let updating_sliceBegin;
    	let updating_sliceEnd;
    	let current;

    	function sveltetable_sliceBegin_binding(value) {
    		/*sveltetable_sliceBegin_binding*/ ctx[16](value);
    	}

    	function sveltetable_sliceEnd_binding(value) {
    		/*sveltetable_sliceEnd_binding*/ ctx[17](value);
    	}

    	let sveltetable_props = {
    		columns: /*columns*/ ctx[7],
    		rows: /*charms*/ ctx[3],
    		classNameTable: "table table-striped table-hover table-responsible",
    		classNameThead: "table-dark hide-first-child.disabled",
    		disableFilterHeader: /*disableFilterHeader*/ ctx[2],
    		$$slots: {
    			"after-row": [
    				create_after_row_slot,
    				({ row }) => ({ 23: row }),
    				({ row }) => [row ? 8388608 : 0]
    			],
    			row: [
    				create_row_slot,
    				({ n, row }) => ({ 27: n, 23: row }),
    				({ n, row }) => [(n ? 134217728 : 0) | (row ? 8388608 : 0)]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*sliceBegin*/ ctx[0] !== void 0) {
    		sveltetable_props.sliceBegin = /*sliceBegin*/ ctx[0];
    	}

    	if (/*sliceEnd*/ ctx[1] !== void 0) {
    		sveltetable_props.sliceEnd = /*sliceEnd*/ ctx[1];
    	}

    	sveltetable = new SvelteTable({ props: sveltetable_props, $$inline: true });
    	binding_callbacks.push(() => bind(sveltetable, "sliceBegin", sveltetable_sliceBegin_binding));
    	binding_callbacks.push(() => bind(sveltetable, "sliceEnd", sveltetable_sliceEnd_binding));
    	sveltetable.$on("clickCol", /*onSort*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(sveltetable.$$.fragment);
    			attr_dev(div, "class", "charm-table svelte-1bydddo");
    			attr_dev(div, "style", /*styleVars*/ ctx[6]);
    			add_location(div, file$b, 172, 0, 7483);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(sveltetable, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const sveltetable_changes = {};
    			if (dirty[0] & /*charms*/ 8) sveltetable_changes.rows = /*charms*/ ctx[3];
    			if (dirty[0] & /*disableFilterHeader*/ 4) sveltetable_changes.disableFilterHeader = /*disableFilterHeader*/ ctx[2];

    			if (dirty[0] & /*row, isScreenshotShown, isSubstitutableCharmsShown*/ 8388656 | dirty[1] & /*$$scope*/ 1) {
    				sveltetable_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_sliceBegin && dirty[0] & /*sliceBegin*/ 1) {
    				updating_sliceBegin = true;
    				sveltetable_changes.sliceBegin = /*sliceBegin*/ ctx[0];
    				add_flush_callback(() => updating_sliceBegin = false);
    			}

    			if (!updating_sliceEnd && dirty[0] & /*sliceEnd*/ 2) {
    				updating_sliceEnd = true;
    				sveltetable_changes.sliceEnd = /*sliceEnd*/ ctx[1];
    				add_flush_callback(() => updating_sliceEnd = false);
    			}

    			sveltetable.$set(sveltetable_changes);

    			if (!current || dirty[0] & /*styleVars*/ 64) {
    				attr_dev(div, "style", /*styleVars*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sveltetable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sveltetable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(sveltetable);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let styleVars;
    	let $charmManager;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(18, $charmManager = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmTable", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { headerColor = "mediumseagreen" } = $$props;
    	let { disableFilterHeader = false } = $$props;
    	let { showImageColumn = true } = $$props;
    	let { showSubstitutesColumn = true } = $$props;
    	let { charms } = $$props;
    	let { initialOpenedScreentshots = [] } = $$props;
    	let { sliceBegin } = $$props;
    	let { sliceEnd } = $$props;
    	const allSkills = getAllSkillNames();

    	const columns = [
    		{
    			key: "id",
    			title: "ID",
    			value: v => v.rowid,
    			sortable: true,
    			filterOptions: rows => {
    				const UNIT = 50;

    				// generate groupings of 1-50, 51-100, etc...
    				let nums = {};

    				rows.forEach(row => {
    					let num = Math.floor(row.rowid / UNIT);

    					if (nums[num] === undefined) nums[num] = {
    						name: `${num * UNIT + 1} 〜 ${(num + 1) * UNIT}`,
    						value: num
    					};
    				});

    				// fix order
    				nums = Object.entries(nums).sort().reduce((o, [k, v]) => (o[k] = v, o), {});

    				return Object.values(nums);
    			},
    			filterValue: v => Math.floor((v.rowid - 1) / 50)
    		},
    		{
    			key: "skill1",
    			title: "スキル1",
    			value: v => v.skill1,
    			filterOptions: allSkills,
    			sortable: true
    		},
    		{
    			key: "skill1Level",
    			title: "スキル1 Lv",
    			value: v => v.skill1Level,
    			filterOptions: [...Array(MAX_SKILL_LEVEL$1 + 1).keys()].slice(1),
    			sortable: true
    		},
    		{
    			key: "skill2",
    			title: "スキル2",
    			value: v => v.skill2,
    			filterOptions: allSkills,
    			sortable: true
    		},
    		{
    			key: "skill2Level",
    			title: "スキル2 Lv",
    			value: v => v.skill2Level,
    			filterOptions: [...Array(MAX_SKILL_LEVEL$1 + 1).keys()].slice(1),
    			sortable: true
    		},
    		...Array.from({ length: MAX_NUM_SLOTS }, (_, i) => i + 1).map(i => ({
    			key: `slot${i}`,
    			title: `スロット${i}`,
    			value: v => v[`slot${i}`],
    			renderValue: v => v[`slot${i}`] || "-",
    			sortable: true,
    			filterOptions: [...Array(MAX_SLOT_LEVEL + 1).keys()].slice(1)
    		})),
    		{
    			key: "evaluation",
    			title: "合計Lv",
    			value: v => v.evaluation || "-",
    			// filterOptions: rows => [...new Set(rows.map(i => i.evaluation))],
    			filterOptions: [...Array(21).keys()],
    			sortable: true
    		},
    		{
    			key: "image",
    			title: "画像",
    			value: v => v.imagename ? "有り" : "無し",
    			renderValue: v => v.imagename
    			? "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-camera-fill\" viewBox=\"0 0 16 16\"> <path d=\"M10.5 8.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0z\"/> <path d=\"M2 4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-1.172a2 2 0 0 1-1.414-.586l-.828-.828A2 2 0 0 0 9.172 2H6.828a2 2 0 0 0-1.414.586l-.828.828A2 2 0 0 1 3.172 4H2zm.5 2a.5.5 0 1 1 0-1 .5.5 0 0 1 0 1zm9 2.5a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0z\"/> </svg>"
    			: "",
    			sortable: true,
    			filterOptions: ["有り", "無し"],
    			onClick: toggleScreenshot
    		},
    		{
    			key: "substitutableCharms",
    			title: "代替",
    			value: v => {
    				var _a;

    				return ((_a = v.substitutableCharms) === null || _a === void 0
    				? void 0
    				: _a.length)
    				? "有り"
    				: "無し";
    			},
    			renderValue: v => {
    				const question = "<span style=\"color: gray\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-question-square-fill\" viewBox=\"0 0 16 16\"> <path d=\"M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm3.496 6.033a.237.237 0 0 1-.24-.247C5.35 4.091 6.737 3.5 8.005 3.5c1.396 0 2.672.73 2.672 2.24 0 1.08-.635 1.594-1.244 2.057-.737.559-1.01.768-1.01 1.486v.105a.25.25 0 0 1-.25.25h-.81a.25.25 0 0 1-.25-.246l-.004-.217c-.038-.927.495-1.498 1.168-1.987.59-.444.965-.736.965-1.371 0-.825-.628-1.168-1.314-1.168-.803 0-1.253.478-1.342 1.134-.018.137-.128.25-.266.25h-.825zm2.325 6.443c-.584 0-1.009-.394-1.009-.927 0-.552.425-.94 1.01-.94.609 0 1.028.388 1.028.94 0 .533-.42.927-1.029.927z\"/> </svg> </span>";
    				const up = "<span style=\"color: mediumseagreen\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-arrow-up-square-fill\" viewBox=\"0 0 16 16\"> <path d=\"M2 16a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2zm6.5-4.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 1 0z\"/> </svg> </span>";

    				return v.substitutableCharms == null
    				? question
    				: v.substitutableCharms.length ? up : "";
    			},
    			sortable: true,
    			filterOptions: ["有り", "無し"]
    		}
    	].filter(i => {
    		switch (i.key) {
    			case "image":
    				return showImageColumn;
    			case "substitutableCharms":
    				return showSubstitutesColumn;
    			default:
    				return true;
    		}
    	});

    	// fields
    	let isScreenshotShown = [];

    	let isSubstitutableCharmsShown = [];

    	// handlers
    	function onSort() {
    		init();
    	}

    	function onClickRow({ row }) {
    		const index = row.rowid;
    		$$invalidate(5, isSubstitutableCharmsShown[index] = !isSubstitutableCharmsShown[index], isSubstitutableCharmsShown);
    	}

    	function toggleScreenshot({ e, row }) {
    		return __awaiter(this, void 0, void 0, function* () {
    			e === null || e === void 0
    			? void 0
    			: e.stopPropagation();

    			const index = row.rowid;
    			const toShow = !isScreenshotShown[index];
    			$$invalidate(4, isScreenshotShown[index] = toShow, isScreenshotShown);

    			if (toShow) {
    				// console.log(charms[index].imagename)
    				if (row.imagename == null) {
    					console.log("screenshot is not found");
    					return;
    				}

    				const screenshot = yield $charmManager.getScreenshot(row.imagename);

    				// await new Promise((resolve) => requestAnimationFrame(resolve))
    				cv__default['default'].imshow(`charm-table-row-${index}-screenshot`, screenshot);
    			} // screenshot.delete()
    		});
    	}

    	function init() {
    		// close all accordion
    		$$invalidate(4, isScreenshotShown = []);

    		$$invalidate(5, isSubstitutableCharmsShown = []);

    		for (let id of initialOpenedScreentshots) {
    			const row = charms.find(i => i.rowid === id);
    			toggleScreenshot({ row });
    		}
    	}

    	init();

    	const writable_props = [
    		"headerColor",
    		"disableFilterHeader",
    		"showImageColumn",
    		"showSubstitutesColumn",
    		"charms",
    		"initialOpenedScreentshots",
    		"sliceBegin",
    		"sliceEnd"
    	];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<CharmTable> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (col, row, n, e) => {
    		if (col.onClick != null) {
    			col.onClick({ e, row, col, index: n });
    		}
    	};

    	const click_handler_1 = row => onClickRow({ row });

    	function sveltetable_sliceBegin_binding(value) {
    		sliceBegin = value;
    		$$invalidate(0, sliceBegin);
    	}

    	function sveltetable_sliceEnd_binding(value) {
    		sliceEnd = value;
    		$$invalidate(1, sliceEnd);
    	}

    	$$self.$$set = $$props => {
    		if ("headerColor" in $$props) $$invalidate(10, headerColor = $$props.headerColor);
    		if ("disableFilterHeader" in $$props) $$invalidate(2, disableFilterHeader = $$props.disableFilterHeader);
    		if ("showImageColumn" in $$props) $$invalidate(11, showImageColumn = $$props.showImageColumn);
    		if ("showSubstitutesColumn" in $$props) $$invalidate(12, showSubstitutesColumn = $$props.showSubstitutesColumn);
    		if ("charms" in $$props) $$invalidate(3, charms = $$props.charms);
    		if ("initialOpenedScreentshots" in $$props) $$invalidate(13, initialOpenedScreentshots = $$props.initialOpenedScreentshots);
    		if ("sliceBegin" in $$props) $$invalidate(0, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(1, sliceEnd = $$props.sliceEnd);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		cv: cv__default['default'],
    		slide,
    		SvelteTable,
    		getAllSkillNames,
    		charmManager,
    		MAX_NUM_SLOTS,
    		MAX_SKILL_LEVEL: MAX_SKILL_LEVEL$1,
    		MAX_SLOT_LEVEL,
    		headerColor,
    		disableFilterHeader,
    		showImageColumn,
    		showSubstitutesColumn,
    		charms,
    		initialOpenedScreentshots,
    		sliceBegin,
    		sliceEnd,
    		allSkills,
    		columns,
    		isScreenshotShown,
    		isSubstitutableCharmsShown,
    		onSort,
    		onClickRow,
    		toggleScreenshot,
    		init,
    		$charmManager,
    		styleVars
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("headerColor" in $$props) $$invalidate(10, headerColor = $$props.headerColor);
    		if ("disableFilterHeader" in $$props) $$invalidate(2, disableFilterHeader = $$props.disableFilterHeader);
    		if ("showImageColumn" in $$props) $$invalidate(11, showImageColumn = $$props.showImageColumn);
    		if ("showSubstitutesColumn" in $$props) $$invalidate(12, showSubstitutesColumn = $$props.showSubstitutesColumn);
    		if ("charms" in $$props) $$invalidate(3, charms = $$props.charms);
    		if ("initialOpenedScreentshots" in $$props) $$invalidate(13, initialOpenedScreentshots = $$props.initialOpenedScreentshots);
    		if ("sliceBegin" in $$props) $$invalidate(0, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(1, sliceEnd = $$props.sliceEnd);
    		if ("isScreenshotShown" in $$props) $$invalidate(4, isScreenshotShown = $$props.isScreenshotShown);
    		if ("isSubstitutableCharmsShown" in $$props) $$invalidate(5, isSubstitutableCharmsShown = $$props.isSubstitutableCharmsShown);
    		if ("styleVars" in $$props) $$invalidate(6, styleVars = $$props.styleVars);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*headerColor, showImageColumn, showSubstitutesColumn*/ 7168) {
    			$$invalidate(6, styleVars = Object.entries({
    				"header-background-color": headerColor,
    				"table-width": `${61 + (showImageColumn ? 3 : 0) + (showSubstitutesColumn ? 3 : 0)}rem`
    			}).map(([k, v]) => `--${k}:${v}`).join(";"));
    		}

    		if ($$self.$$.dirty[0] & /*charms*/ 8) {
    			{
    				init();
    			}
    		}
    	};

    	return [
    		sliceBegin,
    		sliceEnd,
    		disableFilterHeader,
    		charms,
    		isScreenshotShown,
    		isSubstitutableCharmsShown,
    		styleVars,
    		columns,
    		onSort,
    		onClickRow,
    		headerColor,
    		showImageColumn,
    		showSubstitutesColumn,
    		initialOpenedScreentshots,
    		click_handler,
    		click_handler_1,
    		sveltetable_sliceBegin_binding,
    		sveltetable_sliceEnd_binding
    	];
    }

    class CharmTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$b,
    			create_fragment$b,
    			safe_not_equal,
    			{
    				headerColor: 10,
    				disableFilterHeader: 2,
    				showImageColumn: 11,
    				showSubstitutesColumn: 12,
    				charms: 3,
    				initialOpenedScreentshots: 13,
    				sliceBegin: 0,
    				sliceEnd: 1
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmTable",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*charms*/ ctx[3] === undefined && !("charms" in props)) {
    			console_1$1.warn("<CharmTable> was created without expected prop 'charms'");
    		}

    		if (/*sliceBegin*/ ctx[0] === undefined && !("sliceBegin" in props)) {
    			console_1$1.warn("<CharmTable> was created without expected prop 'sliceBegin'");
    		}

    		if (/*sliceEnd*/ ctx[1] === undefined && !("sliceEnd" in props)) {
    			console_1$1.warn("<CharmTable> was created without expected prop 'sliceEnd'");
    		}
    	}

    	get headerColor() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerColor(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableFilterHeader() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableFilterHeader(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showImageColumn() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showImageColumn(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showSubstitutesColumn() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showSubstitutesColumn(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get charms() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set charms(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initialOpenedScreentshots() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initialOpenedScreentshots(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliceBegin() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliceBegin(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sliceEnd() {
    		throw new Error("<CharmTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sliceEnd(value) {
    		throw new Error("<CharmTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/CharmTableWithPager.svelte generated by Svelte v3.38.2 */
    const file$a = "src/components/parts/CharmTableWithPager.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (51:6) {#each [...Array(nPages).keys()] as i}
    function create_each_block$6(ctx) {
    	let li;
    	let span;
    	let t_value = /*i*/ ctx[16] + 1 + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[13](/*i*/ ctx[16]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "page-link");
    			add_location(span, file$a, 52, 10, 1618);
    			attr_dev(li, "class", "page-item");
    			toggle_class(li, "active", /*i*/ ctx[16] === /*currentPage*/ ctx[4]);
    			add_location(li, file$a, 51, 8, 1552);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*nPages*/ 64 && t_value !== (t_value = /*i*/ ctx[16] + 1 + "")) set_data_dev(t, t_value);

    			if (dirty & /*Array, nPages, currentPage*/ 80) {
    				toggle_class(li, "active", /*i*/ ctx[16] === /*currentPage*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(51:6) {#each [...Array(nPages).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t5;
    	let t6;
    	let charmtable;
    	let t7;
    	let div1;
    	let ul;
    	let li0;
    	let span1;
    	let span0;
    	let t9;
    	let li1;
    	let span3;
    	let span2;
    	let t11;
    	let t12;
    	let li2;
    	let span5;
    	let span4;
    	let t14;
    	let li3;
    	let span7;
    	let span6;
    	let current;
    	let mounted;
    	let dispose;

    	charmtable = new CharmTable({
    			props: {
    				charms: /*charms*/ ctx[0],
    				sliceBegin: /*sliceBegin*/ ctx[7],
    				sliceEnd: /*sliceEnd*/ ctx[8],
    				disableFilterHeader: /*disableFilterHeader*/ ctx[1],
    				headerColor: /*headerColor*/ ctx[2],
    				initialOpenedScreentshots: /*initialOpenedScreentshots*/ ctx[3]
    			},
    			$$inline: true
    		});

    	let each_value = [...Array(/*nPages*/ ctx[6]).keys()];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text("show\n    ");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "10";
    			option1 = element("option");
    			option1.textContent = "25";
    			option2 = element("option");
    			option2.textContent = "50";
    			option3 = element("option");
    			option3.textContent = "100";
    			t5 = text("\n    charms");
    			t6 = space();
    			create_component(charmtable.$$.fragment);
    			t7 = space();
    			div1 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "«";
    			t9 = space();
    			li1 = element("li");
    			span3 = element("span");
    			span2 = element("span");
    			span2.textContent = "<";
    			t11 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			li2 = element("li");
    			span5 = element("span");
    			span4 = element("span");
    			span4.textContent = ">";
    			t14 = space();
    			li3 = element("li");
    			span7 = element("span");
    			span6 = element("span");
    			span6.textContent = "»";
    			option0.__value = "10";
    			option0.value = option0.__value;
    			add_location(option0, file$a, 22, 6, 667);
    			option1.__value = "25";
    			option1.value = option1.__value;
    			add_location(option1, file$a, 23, 6, 693);
    			option2.__value = "50";
    			option2.value = option2.__value;
    			add_location(option2, file$a, 24, 6, 719);
    			option3.__value = "100";
    			option3.value = option3.__value;
    			add_location(option3, file$a, 25, 6, 745);
    			if (/*itemsPerPage*/ ctx[5] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[10].call(select));
    			add_location(select, file$a, 21, 4, 626);
    			add_location(div0, file$a, 19, 2, 607);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$a, 42, 10, 1206);
    			attr_dev(span1, "class", "page-link");
    			add_location(span1, file$a, 41, 8, 1138);
    			attr_dev(li0, "class", "page-item");
    			attr_dev(li0, "aria-label", "First");
    			toggle_class(li0, "disabled", /*currentPage*/ ctx[4] === 0);
    			add_location(li0, file$a, 40, 6, 1053);
    			attr_dev(span2, "aria-hidden", "true");
    			add_location(span2, file$a, 47, 10, 1434);
    			attr_dev(span3, "class", "page-link");
    			add_location(span3, file$a, 46, 8, 1368);
    			attr_dev(li1, "class", "page-item");
    			attr_dev(li1, "aria-label", "Previous");
    			toggle_class(li1, "disabled", /*currentPage*/ ctx[4] === 0);
    			add_location(li1, file$a, 45, 6, 1280);
    			attr_dev(span4, "aria-hidden", "true");
    			add_location(span4, file$a, 57, 10, 1885);
    			attr_dev(span5, "class", "page-link");
    			add_location(span5, file$a, 56, 8, 1819);
    			attr_dev(li2, "class", "page-item");
    			attr_dev(li2, "aria-label", "Next");
    			toggle_class(li2, "disabled", /*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1);
    			add_location(li2, file$a, 55, 6, 1724);
    			attr_dev(span6, "aria-hidden", "true");
    			add_location(span6, file$a, 62, 10, 2128);
    			attr_dev(span7, "class", "page-link");
    			add_location(span7, file$a, 61, 8, 2051);
    			attr_dev(li3, "class", "page-item");
    			attr_dev(li3, "aria-label", "Last");
    			toggle_class(li3, "disabled", /*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1);
    			add_location(li3, file$a, 60, 6, 1956);
    			attr_dev(ul, "class", "pagination");
    			add_location(ul, file$a, 39, 4, 1023);
    			attr_dev(div1, "id", "pager");
    			add_location(div1, file$a, 38, 2, 1002);
    			add_location(div2, file$a, 18, 0, 599);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			select_option(select, /*itemsPerPage*/ ctx[5]);
    			append_dev(div0, t5);
    			append_dev(div2, t6);
    			mount_component(charmtable, div2, null);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			append_dev(div1, ul);
    			append_dev(ul, li0);
    			append_dev(li0, span1);
    			append_dev(span1, span0);
    			append_dev(ul, t9);
    			append_dev(ul, li1);
    			append_dev(li1, span3);
    			append_dev(span3, span2);
    			append_dev(ul, t11);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t12);
    			append_dev(ul, li2);
    			append_dev(li2, span5);
    			append_dev(span5, span4);
    			append_dev(ul, t14);
    			append_dev(ul, li3);
    			append_dev(li3, span7);
    			append_dev(span7, span6);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[10]),
    					listen_dev(span1, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(span3, "click", /*click_handler_1*/ ctx[12], false, false, false),
    					listen_dev(span5, "click", /*click_handler_3*/ ctx[14], false, false, false),
    					listen_dev(span7, "click", /*click_handler_4*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*itemsPerPage*/ 32) {
    				select_option(select, /*itemsPerPage*/ ctx[5]);
    			}

    			const charmtable_changes = {};
    			if (dirty & /*charms*/ 1) charmtable_changes.charms = /*charms*/ ctx[0];
    			if (dirty & /*sliceBegin*/ 128) charmtable_changes.sliceBegin = /*sliceBegin*/ ctx[7];
    			if (dirty & /*sliceEnd*/ 256) charmtable_changes.sliceEnd = /*sliceEnd*/ ctx[8];
    			if (dirty & /*disableFilterHeader*/ 2) charmtable_changes.disableFilterHeader = /*disableFilterHeader*/ ctx[1];
    			if (dirty & /*headerColor*/ 4) charmtable_changes.headerColor = /*headerColor*/ ctx[2];
    			if (dirty & /*initialOpenedScreentshots*/ 8) charmtable_changes.initialOpenedScreentshots = /*initialOpenedScreentshots*/ ctx[3];
    			charmtable.$set(charmtable_changes);

    			if (dirty & /*currentPage*/ 16) {
    				toggle_class(li0, "disabled", /*currentPage*/ ctx[4] === 0);
    			}

    			if (dirty & /*currentPage*/ 16) {
    				toggle_class(li1, "disabled", /*currentPage*/ ctx[4] === 0);
    			}

    			if (dirty & /*Array, nPages, currentPage*/ 80) {
    				each_value = [...Array(/*nPages*/ ctx[6]).keys()];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t12);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*currentPage, nPages*/ 80) {
    				toggle_class(li2, "disabled", /*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1);
    			}

    			if (dirty & /*currentPage, nPages*/ 80) {
    				toggle_class(li3, "disabled", /*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmtable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmtable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(charmtable);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let nPages;
    	let sliceBegin;
    	let sliceEnd;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmTableWithPager", slots, []);
    	var _a;
    	let { charms = [] } = $$props;
    	let { disableFilterHeader = true } = $$props;
    	let { headerColor = "dodgerblue" } = $$props;
    	let { initialOpenedScreentshots = [] } = $$props;
    	let currentPage = 1;
    	let itemsPerPage = 10;
    	const writable_props = ["charms", "disableFilterHeader", "headerColor", "initialOpenedScreentshots"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmTableWithPager> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		itemsPerPage = select_value(this);
    		$$invalidate(5, itemsPerPage);
    	}

    	const click_handler = () => $$invalidate(4, currentPage = 0);
    	const click_handler_1 = () => $$invalidate(4, currentPage--, currentPage);
    	const click_handler_2 = i => $$invalidate(4, currentPage = i);
    	const click_handler_3 = () => $$invalidate(4, currentPage++, currentPage);
    	const click_handler_4 = () => $$invalidate(4, currentPage = nPages - 1);

    	$$self.$$set = $$props => {
    		if ("charms" in $$props) $$invalidate(0, charms = $$props.charms);
    		if ("disableFilterHeader" in $$props) $$invalidate(1, disableFilterHeader = $$props.disableFilterHeader);
    		if ("headerColor" in $$props) $$invalidate(2, headerColor = $$props.headerColor);
    		if ("initialOpenedScreentshots" in $$props) $$invalidate(3, initialOpenedScreentshots = $$props.initialOpenedScreentshots);
    	};

    	$$self.$capture_state = () => ({
    		_a,
    		CharmTable,
    		charms,
    		disableFilterHeader,
    		headerColor,
    		initialOpenedScreentshots,
    		currentPage,
    		itemsPerPage,
    		nPages,
    		sliceBegin,
    		sliceEnd
    	});

    	$$self.$inject_state = $$props => {
    		if ("_a" in $$props) $$invalidate(9, _a = $$props._a);
    		if ("charms" in $$props) $$invalidate(0, charms = $$props.charms);
    		if ("disableFilterHeader" in $$props) $$invalidate(1, disableFilterHeader = $$props.disableFilterHeader);
    		if ("headerColor" in $$props) $$invalidate(2, headerColor = $$props.headerColor);
    		if ("initialOpenedScreentshots" in $$props) $$invalidate(3, initialOpenedScreentshots = $$props.initialOpenedScreentshots);
    		if ("currentPage" in $$props) $$invalidate(4, currentPage = $$props.currentPage);
    		if ("itemsPerPage" in $$props) $$invalidate(5, itemsPerPage = $$props.itemsPerPage);
    		if ("nPages" in $$props) $$invalidate(6, nPages = $$props.nPages);
    		if ("sliceBegin" in $$props) $$invalidate(7, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(8, sliceEnd = $$props.sliceEnd);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*charms, _a, itemsPerPage*/ 545) {
    			$$invalidate(6, nPages = Math.ceil(($$invalidate(9, _a = charms === null || charms === void 0
    			? void 0
    			: charms.length) !== null && _a !== void 0
    			? _a
    			: 0) / itemsPerPage));
    		}

    		if ($$self.$$.dirty & /*charms, nPages*/ 65) {
    			{
    				// reset page on update
    				if (charms && nPages) {
    					$$invalidate(4, currentPage = 0);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*itemsPerPage, currentPage*/ 48) {
    			$$invalidate(7, sliceBegin = itemsPerPage * currentPage);
    		}

    		if ($$self.$$.dirty & /*itemsPerPage, currentPage*/ 48) {
    			$$invalidate(8, sliceEnd = itemsPerPage * (currentPage + 1));
    		}
    	};

    	return [
    		charms,
    		disableFilterHeader,
    		headerColor,
    		initialOpenedScreentshots,
    		currentPage,
    		itemsPerPage,
    		nPages,
    		sliceBegin,
    		sliceEnd,
    		_a,
    		select_change_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class CharmTableWithPager extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			charms: 0,
    			disableFilterHeader: 1,
    			headerColor: 2,
    			initialOpenedScreentshots: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmTableWithPager",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get charms() {
    		throw new Error("<CharmTableWithPager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set charms(value) {
    		throw new Error("<CharmTableWithPager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disableFilterHeader() {
    		throw new Error("<CharmTableWithPager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disableFilterHeader(value) {
    		throw new Error("<CharmTableWithPager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerColor() {
    		throw new Error("<CharmTableWithPager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerColor(value) {
    		throw new Error("<CharmTableWithPager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get initialOpenedScreentshots() {
    		throw new Error("<CharmTableWithPager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set initialOpenedScreentshots(value) {
    		throw new Error("<CharmTableWithPager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // TODO: class にして equals にする
    function isSameCharm(c1, c2) {
        const isSameArray = (a1, a2) => {
            return a1.length === a2.length && a1.every(i => a2.includes(i));
        };
        return isSameArray(c1.skills, c2.skills)
            && isSameArray(c1.skillLevels, c2.skillLevels)
            && isSameArray(c1.slots, c2.slots);
    }
    function flatCharm2charm(c) {
        return {
            skills: [c.skill1, c.skill2],
            skillLevels: [c.skill1Level, c.skill2Level],
            slots: [c.slot1, c.slot2, c.slot3],
        };
    }

    const isAppReady = writable(false);

    /* src/pages/CharmDisposalSupporter.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1$1 } = globals;
    const file$9 = "src/pages/CharmDisposalSupporter.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	child_ctx[33] = list;
    	child_ctx[34] = i;
    	return child_ctx;
    }

    // (151:12) <MDBBtn on:click={() => {reset()}}>
    function create_default_slot$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Reset Minimap");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(151:12) <MDBBtn on:click={() => {reset()}}>",
    		ctx
    	});

    	return block;
    }

    // (170:14) {#each [...Array(2).keys()] as i}
    function create_each_block_1$4(ctx) {
    	let div;
    	let skillinput;
    	let updating_value;
    	let t0;
    	let skilllevelinput;
    	let updating_value_1;
    	let t1;
    	let current;

    	function skillinput_value_binding(value) {
    		/*skillinput_value_binding*/ ctx[17](value, /*i*/ ctx[32]);
    	}

    	let skillinput_props = {
    		inputId: "input-skill-" + /*i*/ ctx[32],
    		placeholder: "スキル" + (/*i*/ ctx[32] + 1)
    	};

    	if (/*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]] !== void 0) {
    		skillinput_props.value = /*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]];
    	}

    	skillinput = new CharmSkillInput({ props: skillinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(skillinput, "value", skillinput_value_binding));

    	function skilllevelinput_value_binding(value) {
    		/*skilllevelinput_value_binding*/ ctx[18](value, /*i*/ ctx[32]);
    	}

    	let skilllevelinput_props = {
    		inputId: "input-skill-level-" + /*i*/ ctx[32]
    	};

    	if (/*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]] !== void 0) {
    		skilllevelinput_props.value = /*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]];
    	}

    	skilllevelinput = new CharmSkillLevelInput({
    			props: skilllevelinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(skilllevelinput, "value", skilllevelinput_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(skillinput.$$.fragment);
    			t0 = space();
    			create_component(skilllevelinput.$$.fragment);
    			t1 = space();
    			add_location(div, file$9, 170, 16, 7007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(skillinput, div, null);
    			append_dev(div, t0);
    			mount_component(skilllevelinput, div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const skillinput_changes = {};

    			if (!updating_value && dirty[0] & /*currentCharm*/ 2) {
    				updating_value = true;
    				skillinput_changes.value = /*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]];
    				add_flush_callback(() => updating_value = false);
    			}

    			skillinput.$set(skillinput_changes);
    			const skilllevelinput_changes = {};

    			if (!updating_value_1 && dirty[0] & /*currentCharm*/ 2) {
    				updating_value_1 = true;
    				skilllevelinput_changes.value = /*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			skilllevelinput.$set(skilllevelinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skillinput.$$.fragment, local);
    			transition_in(skilllevelinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skillinput.$$.fragment, local);
    			transition_out(skilllevelinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(skillinput);
    			destroy_component(skilllevelinput);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(170:14) {#each [...Array(2).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    // (194:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}
    function create_each_block$5(ctx) {
    	let charmminimap;
    	let current;

    	charmminimap = new CharmMinimap({
    			props: {
    				page: /*page*/ ctx[29],
    				rowsPerPage: ROWS_PER_PAGE_IN_EQLIST,
    				colsPerPage: COLS_PER_PAGE_IN_EQLIST,
    				currentCharm: /*currentCharm*/ ctx[1],
    				charmScanner: /*charmScanner*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charmminimap.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmminimap, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmminimap_changes = {};
    			if (dirty[0] & /*currentCharm*/ 2) charmminimap_changes.currentCharm = /*currentCharm*/ ctx[1];
    			charmminimap.$set(charmminimap_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmminimap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmminimap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmminimap, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(194:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}",
    		ctx
    	});

    	return block;
    }

    // (212:4) {:else}
    function create_else_block$4(ctx) {
    	let charmtablewithpager;
    	let current;

    	charmtablewithpager = new CharmTableWithPager({
    			props: { charms: /*searchResults*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charmtablewithpager.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmtablewithpager, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmtablewithpager_changes = {};
    			if (dirty[0] & /*searchResults*/ 32) charmtablewithpager_changes.charms = /*searchResults*/ ctx[5];
    			charmtablewithpager.$set(charmtablewithpager_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmtablewithpager.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmtablewithpager.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmtablewithpager, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(212:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (210:41) 
    function create_if_block_2$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "not found";
    			set_style(div, "text-align", "center");
    			add_location(div, file$9, 210, 6, 8441);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(210:41) ",
    		ctx
    	});

    	return block;
    }

    // (208:36) 
    function create_if_block_1$3(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(208:36) ",
    		ctx
    	});

    	return block;
    }

    // (206:4) {#if isSpinnerShown}
    function create_if_block$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spinner-border text-info");
    			attr_dev(div, "role", "status");
    			add_location(div, file$9, 206, 6, 8276);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(206:4) {#if isSpinnerShown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div12;
    	let div10;
    	let div9;
    	let div7;
    	let camerareader;
    	let t0;
    	let div6;
    	let div0;
    	let recordbutton;
    	let updating_isRecording;
    	let t1;
    	let rangeslider;
    	let updating_values;
    	let t2;
    	let mdbbtn;
    	let t3;
    	let div5;
    	let div1;
    	let t4;
    	let charmpositioninput;
    	let updating_page;
    	let updating_row;
    	let updating_col;
    	let t5;
    	let div2;
    	let t6;
    	let rarityinput;
    	let updating_value;
    	let t7;
    	let div3;
    	let t8;
    	let t9;
    	let div4;
    	let t10;
    	let slotsinput;
    	let updating_values_1;
    	let t11;
    	let div8;
    	let t12;
    	let div11;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	let camerareader_props = {
    		imageProcessor: /*imageProcessor*/ ctx[7]
    	};

    	camerareader = new CameraReader({
    			props: camerareader_props,
    			$$inline: true
    		});

    	/*camerareader_binding*/ ctx[9](camerareader);

    	function recordbutton_isRecording_binding(value) {
    		/*recordbutton_isRecording_binding*/ ctx[10](value);
    	}

    	let recordbutton_props = { label: "スキャン" };

    	if (/*isRecording*/ ctx[3] !== void 0) {
    		recordbutton_props.isRecording = /*isRecording*/ ctx[3];
    	}

    	recordbutton = new RecordButton({
    			props: recordbutton_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(recordbutton, "isRecording", recordbutton_isRecording_binding));

    	function rangeslider_values_binding(value) {
    		/*rangeslider_values_binding*/ ctx[11](value);
    	}

    	let rangeslider_props = {
    		min: 0.1,
    		max: 0.4,
    		step: 0.01,
    		float: true,
    		pips: true,
    		pipstep: 5,
    		all: "label",
    		hoverable: false
    	};

    	if (/*charmPosMatchThresholdSliderValues*/ ctx[0] !== void 0) {
    		rangeslider_props.values = /*charmPosMatchThresholdSliderValues*/ ctx[0];
    	}

    	rangeslider = new RangeSlider({ props: rangeslider_props, $$inline: true });
    	binding_callbacks.push(() => bind(rangeslider, "values", rangeslider_values_binding));

    	mdbbtn = new MDBBtn({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbbtn.$on("click", /*click_handler*/ ctx[12]);

    	function charmpositioninput_page_binding(value) {
    		/*charmpositioninput_page_binding*/ ctx[13](value);
    	}

    	function charmpositioninput_row_binding(value) {
    		/*charmpositioninput_row_binding*/ ctx[14](value);
    	}

    	function charmpositioninput_col_binding(value) {
    		/*charmpositioninput_col_binding*/ ctx[15](value);
    	}

    	let charmpositioninput_props = { inputIdPrefix: "input-position-" };

    	if (/*currentCharm*/ ctx[1].page !== void 0) {
    		charmpositioninput_props.page = /*currentCharm*/ ctx[1].page;
    	}

    	if (/*currentCharm*/ ctx[1].row !== void 0) {
    		charmpositioninput_props.row = /*currentCharm*/ ctx[1].row;
    	}

    	if (/*currentCharm*/ ctx[1].col !== void 0) {
    		charmpositioninput_props.col = /*currentCharm*/ ctx[1].col;
    	}

    	charmpositioninput = new CharmPositionInput({
    			props: charmpositioninput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(charmpositioninput, "page", charmpositioninput_page_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "row", charmpositioninput_row_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "col", charmpositioninput_col_binding));

    	function rarityinput_value_binding(value) {
    		/*rarityinput_value_binding*/ ctx[16](value);
    	}

    	let rarityinput_props = { inputId: "input-rarity" };

    	if (/*currentCharm*/ ctx[1].rarity !== void 0) {
    		rarityinput_props.value = /*currentCharm*/ ctx[1].rarity;
    	}

    	rarityinput = new CharmRarityInput({ props: rarityinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(rarityinput, "value", rarityinput_value_binding));
    	let each_value_1 = [...Array(2).keys()];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	function slotsinput_values_binding(value) {
    		/*slotsinput_values_binding*/ ctx[19](value);
    	}

    	let slotsinput_props = {
    		inputIdPrefix: "input-slot-level-",
    		placeholder: "スロット"
    	};

    	if (/*currentCharm*/ ctx[1].slots !== void 0) {
    		slotsinput_props.values = /*currentCharm*/ ctx[1].slots;
    	}

    	slotsinput = new CharmSlotsInput({ props: slotsinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(slotsinput, "values", slotsinput_values_binding));
    	let each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block$4, create_if_block_1$3, create_if_block_2$3, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSpinnerShown*/ ctx[4]) return 0;
    		if (/*searchResults*/ ctx[5] == null) return 1;
    		if (/*searchResults*/ ctx[5].length === 0) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div12 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div7 = element("div");
    			create_component(camerareader.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			div0 = element("div");
    			create_component(recordbutton.$$.fragment);
    			t1 = space();
    			create_component(rangeslider.$$.fragment);
    			t2 = space();
    			create_component(mdbbtn.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			div1 = element("div");
    			t4 = text("位置:\n              ");
    			create_component(charmpositioninput.$$.fragment);
    			t5 = space();
    			div2 = element("div");
    			t6 = text("レア度:\n              ");
    			create_component(rarityinput.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			t8 = text("スキル:\n              ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t9 = space();
    			div4 = element("div");
    			t10 = text("スロット:\n              ");
    			create_component(slotsinput.$$.fragment);
    			t11 = space();
    			div8 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			div11 = element("div");
    			if_block.c();
    			attr_dev(div0, "id", "scan-settings");
    			attr_dev(div0, "class", "svelte-5qt75h");
    			add_location(div0, file$9, 139, 10, 5724);
    			attr_dev(div1, "id", "charm-spec-position");
    			attr_dev(div1, "class", "svelte-5qt75h");
    			add_location(div1, file$9, 153, 12, 6305);
    			attr_dev(div2, "id", "charm-spec-rarity");
    			attr_dev(div2, "class", "svelte-5qt75h");
    			add_location(div2, file$9, 161, 12, 6676);
    			attr_dev(div3, "id", "charm-spec-skills");
    			attr_dev(div3, "class", "svelte-5qt75h");
    			add_location(div3, file$9, 167, 12, 6895);
    			attr_dev(div4, "id", "charm-spec-slots");
    			attr_dev(div4, "class", "svelte-5qt75h");
    			add_location(div4, file$9, 181, 12, 7478);
    			attr_dev(div5, "id", "charm-spec");
    			attr_dev(div5, "class", "svelte-5qt75h");
    			add_location(div5, file$9, 152, 10, 6271);
    			attr_dev(div6, "id", "scan-status");
    			attr_dev(div6, "class", "svelte-5qt75h");
    			add_location(div6, file$9, 138, 8, 5691);
    			attr_dev(div7, "id", "main");
    			attr_dev(div7, "class", "svelte-5qt75h");
    			add_location(div7, file$9, 135, 6, 5561);
    			attr_dev(div8, "class", "charm-box-overview svelte-5qt75h");
    			add_location(div8, file$9, 192, 6, 7790);
    			attr_dev(div9, "id", "status");
    			attr_dev(div9, "class", "svelte-5qt75h");
    			add_location(div9, file$9, 134, 4, 5537);
    			attr_dev(div10, "id", "scanner");
    			attr_dev(div10, "class", "svelte-5qt75h");
    			add_location(div10, file$9, 133, 2, 5514);
    			attr_dev(div11, "id", "result");
    			attr_dev(div11, "class", "svelte-5qt75h");
    			add_location(div11, file$9, 204, 2, 8227);
    			attr_dev(div12, "class", "tab-content svelte-5qt75h");
    			add_location(div12, file$9, 131, 0, 5450);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div7);
    			mount_component(camerareader, div7, null);
    			append_dev(div7, t0);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			mount_component(recordbutton, div0, null);
    			append_dev(div0, t1);
    			mount_component(rangeslider, div0, null);
    			append_dev(div0, t2);
    			mount_component(mdbbtn, div0, null);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div1);
    			append_dev(div1, t4);
    			mount_component(charmpositioninput, div1, null);
    			append_dev(div5, t5);
    			append_dev(div5, div2);
    			append_dev(div2, t6);
    			mount_component(rarityinput, div2, null);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, t8);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div3, null);
    			}

    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, t10);
    			mount_component(slotsinput, div4, null);
    			append_dev(div9, t11);
    			append_dev(div9, div8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			append_dev(div12, t12);
    			append_dev(div12, div11);
    			if_blocks[current_block_type_index].m(div11, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const camerareader_changes = {};
    			camerareader.$set(camerareader_changes);
    			const recordbutton_changes = {};

    			if (!updating_isRecording && dirty[0] & /*isRecording*/ 8) {
    				updating_isRecording = true;
    				recordbutton_changes.isRecording = /*isRecording*/ ctx[3];
    				add_flush_callback(() => updating_isRecording = false);
    			}

    			recordbutton.$set(recordbutton_changes);
    			const rangeslider_changes = {};

    			if (!updating_values && dirty[0] & /*charmPosMatchThresholdSliderValues*/ 1) {
    				updating_values = true;
    				rangeslider_changes.values = /*charmPosMatchThresholdSliderValues*/ ctx[0];
    				add_flush_callback(() => updating_values = false);
    			}

    			rangeslider.$set(rangeslider_changes);
    			const mdbbtn_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				mdbbtn_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtn.$set(mdbbtn_changes);
    			const charmpositioninput_changes = {};

    			if (!updating_page && dirty[0] & /*currentCharm*/ 2) {
    				updating_page = true;
    				charmpositioninput_changes.page = /*currentCharm*/ ctx[1].page;
    				add_flush_callback(() => updating_page = false);
    			}

    			if (!updating_row && dirty[0] & /*currentCharm*/ 2) {
    				updating_row = true;
    				charmpositioninput_changes.row = /*currentCharm*/ ctx[1].row;
    				add_flush_callback(() => updating_row = false);
    			}

    			if (!updating_col && dirty[0] & /*currentCharm*/ 2) {
    				updating_col = true;
    				charmpositioninput_changes.col = /*currentCharm*/ ctx[1].col;
    				add_flush_callback(() => updating_col = false);
    			}

    			charmpositioninput.$set(charmpositioninput_changes);
    			const rarityinput_changes = {};

    			if (!updating_value && dirty[0] & /*currentCharm*/ 2) {
    				updating_value = true;
    				rarityinput_changes.value = /*currentCharm*/ ctx[1].rarity;
    				add_flush_callback(() => updating_value = false);
    			}

    			rarityinput.$set(rarityinput_changes);

    			if (dirty[0] & /*currentCharm*/ 2) {
    				each_value_1 = [...Array(2).keys()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$4(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const slotsinput_changes = {};

    			if (!updating_values_1 && dirty[0] & /*currentCharm*/ 2) {
    				updating_values_1 = true;
    				slotsinput_changes.values = /*currentCharm*/ ctx[1].slots;
    				add_flush_callback(() => updating_values_1 = false);
    			}

    			slotsinput.$set(slotsinput_changes);

    			if (dirty[0] & /*currentCharm, charmScanner*/ 66) {
    				each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div8, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div11, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(camerareader.$$.fragment, local);
    			transition_in(recordbutton.$$.fragment, local);
    			transition_in(rangeslider.$$.fragment, local);
    			transition_in(mdbbtn.$$.fragment, local);
    			transition_in(charmpositioninput.$$.fragment, local);
    			transition_in(rarityinput.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(slotsinput.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(camerareader.$$.fragment, local);
    			transition_out(recordbutton.$$.fragment, local);
    			transition_out(rangeslider.$$.fragment, local);
    			transition_out(mdbbtn.$$.fragment, local);
    			transition_out(charmpositioninput.$$.fragment, local);
    			transition_out(rarityinput.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(slotsinput.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div12);
    			/*camerareader_binding*/ ctx[9](null);
    			destroy_component(camerareader);
    			destroy_component(recordbutton);
    			destroy_component(rangeslider);
    			destroy_component(mdbbtn);
    			destroy_component(charmpositioninput);
    			destroy_component(rarityinput);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(slotsinput);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $charmManager;
    	let $isAppReady;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(22, $charmManager = $$value));
    	validate_store(isAppReady, "isAppReady");
    	component_subscribe($$self, isAppReady, $$value => $$invalidate(23, $isAppReady = $$value));
    	let { $$slots: slots$1 = {}, $$scope } = $$props;
    	validate_slots("CharmDisposalSupporter", slots$1, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	

    	// const VIDEO_WIDTH      = 1280 // switch のキャプチャ解像度
    	// const VIDEO_HEIGHT     = 720
    	// const VIDEO_FRAME_RATE = 29.97
    	let charmScanner = new MHRiseCharmScanner({
    			scanMode: SCAN_MODE.MODE_EQUIP_LIST,
    			scanSkipMode: SCAN_SKIP_MODE.SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE
    		});

    	let domCameraReader;
    	let isRecording = false;
    	let isRegisterEnabled = false;
    	let isPositionAdjustRequired = true;
    	let charmPosMatchThreshold;
    	let charmPosMatchThresholdSliderValues = [0.29];

    	// form to show and fix scanned data
    	let currentCharm = { skills: [], skillLevels: [], slots: [] };

    	const imageProcessor = frame => __awaiter(void 0, void 0, void 0, function* () {
    		if (!isRecording) {
    			return;
    		}

    		if (isPositionAdjustRequired) {
    			isPositionAdjustRequired = false;
    			charmScanner.adjustPosition(frame);
    		}

    		const result = charmScanner.scan(frame, dayjs_min().format(), charmPosMatchThreshold);

    		if (result == null) {
    			return;
    		}

    		const { charm, isCache } = result;

    		// 表示を更新
    		if (!isSameCharm(currentCharm, charm)) {
    			$$invalidate(1, currentCharm = charm);
    		}

    		if (!isCache && isRegisterEnabled) {
    			// nScanedCharms = charmScanner.countCharms()
    			yield $charmManager.registerCharm(charm, frame);
    		}
    	});

    	function init() {
    		return __awaiter(this, void 0, void 0, function* () {
    			while (!$isAppReady) {
    				yield new Promise(r => setTimeout(r, 1000));
    			}

    			yield domCameraReader.init();
    		});
    	}

    	init();

    	// result table
    	let domCharmTable;

    	let isSpinnerShown = false;
    	let searchResults = null;

    	function updateResult(baseSpec) {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (Object.keys(baseSpec.skills).length === 0) {
    				return;
    			}

    			if (isSpinnerShown) {
    				return;
    			}

    			$$invalidate(4, isSpinnerShown = true);
    			const { skills, skillLevels, slots } = baseSpec;

    			if (skills.filter(i => i && i !== "無し").length == 0 && slots.filter(i => i !== 0).length == 0) {
    				$$invalidate(5, searchResults = null);
    				$$invalidate(4, isSpinnerShown = false);
    				return;
    			}

    			const input = {
    				skills: skills.map(i => i !== null && i !== void 0 ? i : "無し"),
    				skillLevels: skillLevels.map(i => i !== null && i !== void 0 ? i : 0),
    				slots: slots.map(i => i !== null && i !== void 0 ? i : 0)
    			};

    			const inputJson = JSON.stringify(input);

    			// console.log(input)
    			while (typeof Module.getSubstitutes !== "function") {
    				yield sleep(100);
    			}

    			const result = Module.getSubstitutes(
    				JSON.stringify($charmManager.charms.map(i => {
    					// 余分なデータを落としてから渡す
    					const { rowid, skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3 } = i;

    					return {
    						rowid,
    						skill1,
    						skill1Level,
    						skill2,
    						skill2Level,
    						slot1,
    						slot2,
    						slot3
    					};
    				})),
    				inputJson
    			);

    			const matchIds = JSON.parse(result);
    			$$invalidate(5, searchResults = matchIds.map(id => $charmManager.charms.find(i => i.rowid === id)).filter(c => !isSameCharm(flatCharm2charm(c), input)));
    			$$invalidate(4, isSpinnerShown = false);
    		});
    	}

    	function reset() {
    		$$invalidate(1, currentCharm = { skills: [], skillLevels: [], slots: [] });
    		charmScanner.reset();
    	}

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmDisposalSupporter> was created with unknown prop '${key}'`);
    	});

    	function camerareader_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domCameraReader = $$value;
    			$$invalidate(2, domCameraReader);
    		});
    	}

    	function recordbutton_isRecording_binding(value) {
    		isRecording = value;
    		$$invalidate(3, isRecording);
    	}

    	function rangeslider_values_binding(value) {
    		charmPosMatchThresholdSliderValues = value;
    		$$invalidate(0, charmPosMatchThresholdSliderValues);
    	}

    	const click_handler = () => {
    		reset();
    	};

    	function charmpositioninput_page_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.page, value)) {
    			currentCharm.page = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function charmpositioninput_row_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.row, value)) {
    			currentCharm.row = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function charmpositioninput_col_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.col, value)) {
    			currentCharm.col = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function rarityinput_value_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.rarity, value)) {
    			currentCharm.rarity = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function skillinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skills[i], value)) {
    			currentCharm.skills[i] = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function skilllevelinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skillLevels[i], value)) {
    			currentCharm.skillLevels[i] = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function slotsinput_values_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.slots, value)) {
    			currentCharm.slots = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		dayjs: dayjs_min,
    		writable,
    		MDBBtn,
    		RangeSlider,
    		CameraReader,
    		CharmPositionInput,
    		RarityInput: CharmRarityInput,
    		SkillInput: CharmSkillInput,
    		SkillLevelInput: CharmSkillLevelInput,
    		SlotsInput: CharmSlotsInput,
    		CharmMinimap,
    		RecordButton,
    		CharmTableWithPager,
    		MAX_PAGE,
    		ROWS_PER_PAGE_IN_EQLIST,
    		COLS_PER_PAGE_IN_EQLIST,
    		isSameCharm,
    		flatCharm2charm,
    		MHRiseCharmScanner,
    		SCAN_MODE,
    		SCAN_SKIP_MODE,
    		charmManager,
    		isAppReady,
    		sleep,
    		charmScanner,
    		domCameraReader,
    		isRecording,
    		isRegisterEnabled,
    		isPositionAdjustRequired,
    		charmPosMatchThreshold,
    		charmPosMatchThresholdSliderValues,
    		currentCharm,
    		imageProcessor,
    		init,
    		domCharmTable,
    		isSpinnerShown,
    		searchResults,
    		updateResult,
    		reset,
    		$charmManager,
    		$isAppReady
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("charmScanner" in $$props) $$invalidate(6, charmScanner = $$props.charmScanner);
    		if ("domCameraReader" in $$props) $$invalidate(2, domCameraReader = $$props.domCameraReader);
    		if ("isRecording" in $$props) $$invalidate(3, isRecording = $$props.isRecording);
    		if ("isRegisterEnabled" in $$props) isRegisterEnabled = $$props.isRegisterEnabled;
    		if ("isPositionAdjustRequired" in $$props) isPositionAdjustRequired = $$props.isPositionAdjustRequired;
    		if ("charmPosMatchThreshold" in $$props) charmPosMatchThreshold = $$props.charmPosMatchThreshold;
    		if ("charmPosMatchThresholdSliderValues" in $$props) $$invalidate(0, charmPosMatchThresholdSliderValues = $$props.charmPosMatchThresholdSliderValues);
    		if ("currentCharm" in $$props) $$invalidate(1, currentCharm = $$props.currentCharm);
    		if ("domCharmTable" in $$props) domCharmTable = $$props.domCharmTable;
    		if ("isSpinnerShown" in $$props) $$invalidate(4, isSpinnerShown = $$props.isSpinnerShown);
    		if ("searchResults" in $$props) $$invalidate(5, searchResults = $$props.searchResults);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*charmPosMatchThresholdSliderValues*/ 1) {
    			charmPosMatchThreshold = charmPosMatchThresholdSliderValues[0];
    		}

    		if ($$self.$$.dirty[0] & /*currentCharm*/ 2) {
    			// $: updateResult({
    			//   skills:      currentCharm.skills,
    			//   skillLevels: currentCharm.skillLevels,
    			//   slots:       currentCharm.slots,
    			// })
    			updateResult(currentCharm);
    		}
    	};

    	return [
    		charmPosMatchThresholdSliderValues,
    		currentCharm,
    		domCameraReader,
    		isRecording,
    		isSpinnerShown,
    		searchResults,
    		charmScanner,
    		imageProcessor,
    		reset,
    		camerareader_binding,
    		recordbutton_isRecording_binding,
    		rangeslider_values_binding,
    		click_handler,
    		charmpositioninput_page_binding,
    		charmpositioninput_row_binding,
    		charmpositioninput_col_binding,
    		rarityinput_value_binding,
    		skillinput_value_binding,
    		skilllevelinput_value_binding,
    		slotsinput_values_binding
    	];
    }

    class CharmDisposalSupporter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmDisposalSupporter",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/pages/CharmRinneSupporter.svelte generated by Svelte v3.38.2 */

    const { Object: Object_1 } = globals;
    const file$8 = "src/pages/CharmRinneSupporter.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	child_ctx[33] = list;
    	child_ctx[34] = i;
    	return child_ctx;
    }

    // (151:12) <MDBBtn on:click={() => {reset()}}>
    function create_default_slot(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Reset Minimap");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(151:12) <MDBBtn on:click={() => {reset()}}>",
    		ctx
    	});

    	return block;
    }

    // (170:14) {#each [...Array(2).keys()] as i}
    function create_each_block_1$3(ctx) {
    	let div;
    	let skillinput;
    	let updating_value;
    	let t0;
    	let skilllevelinput;
    	let updating_value_1;
    	let t1;
    	let current;

    	function skillinput_value_binding(value) {
    		/*skillinput_value_binding*/ ctx[17](value, /*i*/ ctx[32]);
    	}

    	let skillinput_props = {
    		inputId: "input-skill-" + /*i*/ ctx[32],
    		placeholder: "スキル" + (/*i*/ ctx[32] + 1)
    	};

    	if (/*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]] !== void 0) {
    		skillinput_props.value = /*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]];
    	}

    	skillinput = new CharmSkillInput({ props: skillinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(skillinput, "value", skillinput_value_binding));

    	function skilllevelinput_value_binding(value) {
    		/*skilllevelinput_value_binding*/ ctx[18](value, /*i*/ ctx[32]);
    	}

    	let skilllevelinput_props = {
    		inputId: "input-skill-level-" + /*i*/ ctx[32]
    	};

    	if (/*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]] !== void 0) {
    		skilllevelinput_props.value = /*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]];
    	}

    	skilllevelinput = new CharmSkillLevelInput({
    			props: skilllevelinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(skilllevelinput, "value", skilllevelinput_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(skillinput.$$.fragment);
    			t0 = space();
    			create_component(skilllevelinput.$$.fragment);
    			t1 = space();
    			add_location(div, file$8, 170, 16, 6942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(skillinput, div, null);
    			append_dev(div, t0);
    			mount_component(skilllevelinput, div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const skillinput_changes = {};

    			if (!updating_value && dirty[0] & /*currentCharm*/ 2) {
    				updating_value = true;
    				skillinput_changes.value = /*currentCharm*/ ctx[1].skills[/*i*/ ctx[32]];
    				add_flush_callback(() => updating_value = false);
    			}

    			skillinput.$set(skillinput_changes);
    			const skilllevelinput_changes = {};

    			if (!updating_value_1 && dirty[0] & /*currentCharm*/ 2) {
    				updating_value_1 = true;
    				skilllevelinput_changes.value = /*currentCharm*/ ctx[1].skillLevels[/*i*/ ctx[32]];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			skilllevelinput.$set(skilllevelinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skillinput.$$.fragment, local);
    			transition_in(skilllevelinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skillinput.$$.fragment, local);
    			transition_out(skilllevelinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(skillinput);
    			destroy_component(skilllevelinput);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(170:14) {#each [...Array(2).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    // (194:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}
    function create_each_block$4(ctx) {
    	let charmminimap;
    	let current;

    	charmminimap = new CharmMinimap({
    			props: {
    				page: /*page*/ ctx[29],
    				rowsPerPage: ROWS_PER_PAGE_IN_RINNE,
    				colsPerPage: COLS_PER_PAGE_IN_RINNE,
    				currentCharm: /*currentCharm*/ ctx[1],
    				charmScanner: /*charmScanner*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charmminimap.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmminimap, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmminimap_changes = {};
    			if (dirty[0] & /*currentCharm*/ 2) charmminimap_changes.currentCharm = /*currentCharm*/ ctx[1];
    			charmminimap.$set(charmminimap_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmminimap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmminimap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmminimap, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(194:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}",
    		ctx
    	});

    	return block;
    }

    // (212:4) {:else}
    function create_else_block$3(ctx) {
    	let charmtablewithpager;
    	let current;

    	charmtablewithpager = new CharmTableWithPager({
    			props: { charms: /*searchResults*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charmtablewithpager.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmtablewithpager, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmtablewithpager_changes = {};
    			if (dirty[0] & /*searchResults*/ 32) charmtablewithpager_changes.charms = /*searchResults*/ ctx[5];
    			charmtablewithpager.$set(charmtablewithpager_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmtablewithpager.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmtablewithpager.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmtablewithpager, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(212:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (210:41) 
    function create_if_block_2$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "not found";
    			set_style(div, "text-align", "center");
    			add_location(div, file$8, 210, 6, 8374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(210:41) ",
    		ctx
    	});

    	return block;
    }

    // (208:36) 
    function create_if_block_1$2(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(208:36) ",
    		ctx
    	});

    	return block;
    }

    // (206:4) {#if isSpinnerShown}
    function create_if_block$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spinner-border text-info");
    			attr_dev(div, "role", "status");
    			add_location(div, file$8, 206, 6, 8209);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(206:4) {#if isSpinnerShown}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div12;
    	let div10;
    	let div9;
    	let div7;
    	let camerareader;
    	let t0;
    	let div6;
    	let div0;
    	let recordbutton;
    	let updating_isRecording;
    	let t1;
    	let rangeslider;
    	let updating_values;
    	let t2;
    	let mdbbtn;
    	let t3;
    	let div5;
    	let div1;
    	let t4;
    	let charmpositioninput;
    	let updating_page;
    	let updating_row;
    	let updating_col;
    	let t5;
    	let div2;
    	let t6;
    	let rarityinput;
    	let updating_value;
    	let t7;
    	let div3;
    	let t8;
    	let t9;
    	let div4;
    	let t10;
    	let slotsinput;
    	let updating_values_1;
    	let t11;
    	let div8;
    	let t12;
    	let div11;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	let camerareader_props = {
    		imageProcessor: /*imageProcessor*/ ctx[7]
    	};

    	camerareader = new CameraReader({
    			props: camerareader_props,
    			$$inline: true
    		});

    	/*camerareader_binding*/ ctx[9](camerareader);

    	function recordbutton_isRecording_binding(value) {
    		/*recordbutton_isRecording_binding*/ ctx[10](value);
    	}

    	let recordbutton_props = { label: "スキャン" };

    	if (/*isRecording*/ ctx[3] !== void 0) {
    		recordbutton_props.isRecording = /*isRecording*/ ctx[3];
    	}

    	recordbutton = new RecordButton({
    			props: recordbutton_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(recordbutton, "isRecording", recordbutton_isRecording_binding));

    	function rangeslider_values_binding(value) {
    		/*rangeslider_values_binding*/ ctx[11](value);
    	}

    	let rangeslider_props = {
    		min: 0.1,
    		max: 0.4,
    		step: 0.01,
    		float: true,
    		pips: true,
    		pipstep: 5,
    		all: "label",
    		hoverable: false
    	};

    	if (/*charmPosMatchThresholdSliderValues*/ ctx[0] !== void 0) {
    		rangeslider_props.values = /*charmPosMatchThresholdSliderValues*/ ctx[0];
    	}

    	rangeslider = new RangeSlider({ props: rangeslider_props, $$inline: true });
    	binding_callbacks.push(() => bind(rangeslider, "values", rangeslider_values_binding));

    	mdbbtn = new MDBBtn({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	mdbbtn.$on("click", /*click_handler*/ ctx[12]);

    	function charmpositioninput_page_binding(value) {
    		/*charmpositioninput_page_binding*/ ctx[13](value);
    	}

    	function charmpositioninput_row_binding(value) {
    		/*charmpositioninput_row_binding*/ ctx[14](value);
    	}

    	function charmpositioninput_col_binding(value) {
    		/*charmpositioninput_col_binding*/ ctx[15](value);
    	}

    	let charmpositioninput_props = { inputIdPrefix: "input-position-" };

    	if (/*currentCharm*/ ctx[1].page !== void 0) {
    		charmpositioninput_props.page = /*currentCharm*/ ctx[1].page;
    	}

    	if (/*currentCharm*/ ctx[1].row !== void 0) {
    		charmpositioninput_props.row = /*currentCharm*/ ctx[1].row;
    	}

    	if (/*currentCharm*/ ctx[1].col !== void 0) {
    		charmpositioninput_props.col = /*currentCharm*/ ctx[1].col;
    	}

    	charmpositioninput = new CharmPositionInput({
    			props: charmpositioninput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(charmpositioninput, "page", charmpositioninput_page_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "row", charmpositioninput_row_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "col", charmpositioninput_col_binding));

    	function rarityinput_value_binding(value) {
    		/*rarityinput_value_binding*/ ctx[16](value);
    	}

    	let rarityinput_props = { inputId: "input-rarity" };

    	if (/*currentCharm*/ ctx[1].rarity !== void 0) {
    		rarityinput_props.value = /*currentCharm*/ ctx[1].rarity;
    	}

    	rarityinput = new CharmRarityInput({ props: rarityinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(rarityinput, "value", rarityinput_value_binding));
    	let each_value_1 = [...Array(2).keys()];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	function slotsinput_values_binding(value) {
    		/*slotsinput_values_binding*/ ctx[19](value);
    	}

    	let slotsinput_props = {
    		inputIdPrefix: "input-slot-level-",
    		placeholder: "スロット"
    	};

    	if (/*currentCharm*/ ctx[1].slots !== void 0) {
    		slotsinput_props.values = /*currentCharm*/ ctx[1].slots;
    	}

    	slotsinput = new CharmSlotsInput({ props: slotsinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(slotsinput, "values", slotsinput_values_binding));
    	let each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block$3, create_if_block_1$2, create_if_block_2$2, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSpinnerShown*/ ctx[4]) return 0;
    		if (/*searchResults*/ ctx[5] == null) return 1;
    		if (/*searchResults*/ ctx[5].length === 0) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div12 = element("div");
    			div10 = element("div");
    			div9 = element("div");
    			div7 = element("div");
    			create_component(camerareader.$$.fragment);
    			t0 = space();
    			div6 = element("div");
    			div0 = element("div");
    			create_component(recordbutton.$$.fragment);
    			t1 = space();
    			create_component(rangeslider.$$.fragment);
    			t2 = space();
    			create_component(mdbbtn.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			div1 = element("div");
    			t4 = text("位置:\n              ");
    			create_component(charmpositioninput.$$.fragment);
    			t5 = space();
    			div2 = element("div");
    			t6 = text("レア度:\n              ");
    			create_component(rarityinput.$$.fragment);
    			t7 = space();
    			div3 = element("div");
    			t8 = text("スキル:\n              ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t9 = space();
    			div4 = element("div");
    			t10 = text("スロット:\n              ");
    			create_component(slotsinput.$$.fragment);
    			t11 = space();
    			div8 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			div11 = element("div");
    			if_block.c();
    			attr_dev(div0, "id", "scan-settings");
    			attr_dev(div0, "class", "svelte-5qt75h");
    			add_location(div0, file$8, 139, 10, 5659);
    			attr_dev(div1, "id", "charm-spec-position");
    			attr_dev(div1, "class", "svelte-5qt75h");
    			add_location(div1, file$8, 153, 12, 6240);
    			attr_dev(div2, "id", "charm-spec-rarity");
    			attr_dev(div2, "class", "svelte-5qt75h");
    			add_location(div2, file$8, 161, 12, 6611);
    			attr_dev(div3, "id", "charm-spec-skills");
    			attr_dev(div3, "class", "svelte-5qt75h");
    			add_location(div3, file$8, 167, 12, 6830);
    			attr_dev(div4, "id", "charm-spec-slots");
    			attr_dev(div4, "class", "svelte-5qt75h");
    			add_location(div4, file$8, 181, 12, 7413);
    			attr_dev(div5, "id", "charm-spec");
    			attr_dev(div5, "class", "svelte-5qt75h");
    			add_location(div5, file$8, 152, 10, 6206);
    			attr_dev(div6, "id", "scan-status");
    			attr_dev(div6, "class", "svelte-5qt75h");
    			add_location(div6, file$8, 138, 8, 5626);
    			attr_dev(div7, "id", "main");
    			attr_dev(div7, "class", "svelte-5qt75h");
    			add_location(div7, file$8, 135, 6, 5496);
    			attr_dev(div8, "class", "charm-box-overview svelte-5qt75h");
    			add_location(div8, file$8, 192, 6, 7725);
    			attr_dev(div9, "id", "status");
    			attr_dev(div9, "class", "svelte-5qt75h");
    			add_location(div9, file$8, 134, 4, 5472);
    			attr_dev(div10, "id", "scanner");
    			attr_dev(div10, "class", "svelte-5qt75h");
    			add_location(div10, file$8, 133, 2, 5449);
    			attr_dev(div11, "id", "result");
    			attr_dev(div11, "class", "svelte-5qt75h");
    			add_location(div11, file$8, 204, 2, 8160);
    			attr_dev(div12, "class", "tab-content svelte-5qt75h");
    			add_location(div12, file$8, 131, 0, 5385);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div7);
    			mount_component(camerareader, div7, null);
    			append_dev(div7, t0);
    			append_dev(div7, div6);
    			append_dev(div6, div0);
    			mount_component(recordbutton, div0, null);
    			append_dev(div0, t1);
    			mount_component(rangeslider, div0, null);
    			append_dev(div0, t2);
    			mount_component(mdbbtn, div0, null);
    			append_dev(div6, t3);
    			append_dev(div6, div5);
    			append_dev(div5, div1);
    			append_dev(div1, t4);
    			mount_component(charmpositioninput, div1, null);
    			append_dev(div5, t5);
    			append_dev(div5, div2);
    			append_dev(div2, t6);
    			mount_component(rarityinput, div2, null);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, t8);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div3, null);
    			}

    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, t10);
    			mount_component(slotsinput, div4, null);
    			append_dev(div9, t11);
    			append_dev(div9, div8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			append_dev(div12, t12);
    			append_dev(div12, div11);
    			if_blocks[current_block_type_index].m(div11, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const camerareader_changes = {};
    			camerareader.$set(camerareader_changes);
    			const recordbutton_changes = {};

    			if (!updating_isRecording && dirty[0] & /*isRecording*/ 8) {
    				updating_isRecording = true;
    				recordbutton_changes.isRecording = /*isRecording*/ ctx[3];
    				add_flush_callback(() => updating_isRecording = false);
    			}

    			recordbutton.$set(recordbutton_changes);
    			const rangeslider_changes = {};

    			if (!updating_values && dirty[0] & /*charmPosMatchThresholdSliderValues*/ 1) {
    				updating_values = true;
    				rangeslider_changes.values = /*charmPosMatchThresholdSliderValues*/ ctx[0];
    				add_flush_callback(() => updating_values = false);
    			}

    			rangeslider.$set(rangeslider_changes);
    			const mdbbtn_changes = {};

    			if (dirty[1] & /*$$scope*/ 16) {
    				mdbbtn_changes.$$scope = { dirty, ctx };
    			}

    			mdbbtn.$set(mdbbtn_changes);
    			const charmpositioninput_changes = {};

    			if (!updating_page && dirty[0] & /*currentCharm*/ 2) {
    				updating_page = true;
    				charmpositioninput_changes.page = /*currentCharm*/ ctx[1].page;
    				add_flush_callback(() => updating_page = false);
    			}

    			if (!updating_row && dirty[0] & /*currentCharm*/ 2) {
    				updating_row = true;
    				charmpositioninput_changes.row = /*currentCharm*/ ctx[1].row;
    				add_flush_callback(() => updating_row = false);
    			}

    			if (!updating_col && dirty[0] & /*currentCharm*/ 2) {
    				updating_col = true;
    				charmpositioninput_changes.col = /*currentCharm*/ ctx[1].col;
    				add_flush_callback(() => updating_col = false);
    			}

    			charmpositioninput.$set(charmpositioninput_changes);
    			const rarityinput_changes = {};

    			if (!updating_value && dirty[0] & /*currentCharm*/ 2) {
    				updating_value = true;
    				rarityinput_changes.value = /*currentCharm*/ ctx[1].rarity;
    				add_flush_callback(() => updating_value = false);
    			}

    			rarityinput.$set(rarityinput_changes);

    			if (dirty[0] & /*currentCharm*/ 2) {
    				each_value_1 = [...Array(2).keys()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$3(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const slotsinput_changes = {};

    			if (!updating_values_1 && dirty[0] & /*currentCharm*/ 2) {
    				updating_values_1 = true;
    				slotsinput_changes.values = /*currentCharm*/ ctx[1].slots;
    				add_flush_callback(() => updating_values_1 = false);
    			}

    			slotsinput.$set(slotsinput_changes);

    			if (dirty[0] & /*currentCharm, charmScanner*/ 66) {
    				each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div8, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div11, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(camerareader.$$.fragment, local);
    			transition_in(recordbutton.$$.fragment, local);
    			transition_in(rangeslider.$$.fragment, local);
    			transition_in(mdbbtn.$$.fragment, local);
    			transition_in(charmpositioninput.$$.fragment, local);
    			transition_in(rarityinput.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(slotsinput.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(camerareader.$$.fragment, local);
    			transition_out(recordbutton.$$.fragment, local);
    			transition_out(rangeslider.$$.fragment, local);
    			transition_out(mdbbtn.$$.fragment, local);
    			transition_out(charmpositioninput.$$.fragment, local);
    			transition_out(rarityinput.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(slotsinput.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div12);
    			/*camerareader_binding*/ ctx[9](null);
    			destroy_component(camerareader);
    			destroy_component(recordbutton);
    			destroy_component(rangeslider);
    			destroy_component(mdbbtn);
    			destroy_component(charmpositioninput);
    			destroy_component(rarityinput);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(slotsinput);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $charmManager;
    	let $isAppReady;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(22, $charmManager = $$value));
    	validate_store(isAppReady, "isAppReady");
    	component_subscribe($$self, isAppReady, $$value => $$invalidate(23, $isAppReady = $$value));
    	let { $$slots: slots$1 = {}, $$scope } = $$props;
    	validate_slots("CharmRinneSupporter", slots$1, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	

    	// const VIDEO_WIDTH      = 1280 // switch のキャプチャ解像度
    	// const VIDEO_HEIGHT     = 720
    	// const VIDEO_FRAME_RATE = 29.97
    	let charmScanner = new MHRiseCharmScanner({
    			scanMode: SCAN_MODE.MODE_RINNE,
    			scanSkipMode: SCAN_SKIP_MODE.SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE
    		});

    	let domCameraReader;
    	let isRecording = false;
    	let isRegisterEnabled = false;
    	let isPositionAdjustRequired = true;
    	let charmPosMatchThreshold;
    	let charmPosMatchThresholdSliderValues = [0.29];

    	// form to show and fix scanned data
    	let currentCharm = { skills: [], skillLevels: [], slots: [] };

    	const imageProcessor = frame => __awaiter(void 0, void 0, void 0, function* () {
    		if (!isRecording) {
    			return;
    		}

    		if (isPositionAdjustRequired) {
    			isPositionAdjustRequired = false;
    			charmScanner.adjustPosition(frame);
    		}

    		const result = charmScanner.scan(frame, dayjs_min().format(), charmPosMatchThreshold);

    		if (result == null) {
    			return;
    		}

    		const { charm, isCache } = result;

    		// 表示を更新
    		if (!isSameCharm(currentCharm, charm)) {
    			$$invalidate(1, currentCharm = charm);
    		}

    		if (!isCache && isRegisterEnabled) {
    			// nScanedCharms = charmScanner.countCharms()
    			yield $charmManager.registerCharm(charm, frame);
    		}
    	});

    	function init() {
    		return __awaiter(this, void 0, void 0, function* () {
    			while (!$isAppReady) {
    				yield new Promise(r => setTimeout(r, 1000));
    			}

    			yield domCameraReader.init();
    		});
    	}

    	init();

    	// result table
    	let domCharmTable;

    	let isSpinnerShown = false;
    	let searchResults = null;

    	function updateResult(baseSpec) {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (Object.keys(baseSpec.skills).length === 0) {
    				return;
    			}

    			if (isSpinnerShown) {
    				return;
    			}

    			$$invalidate(4, isSpinnerShown = true);
    			const { skills, skillLevels, slots } = baseSpec;

    			if (!skills.length && !slots.length) {
    				$$invalidate(5, searchResults = null);
    				$$invalidate(4, isSpinnerShown = false);
    				return;
    			}

    			const input = {
    				skills: skills.map(i => i !== null && i !== void 0 ? i : "無し"),
    				skillLevels: skillLevels.map(i => i !== null && i !== void 0 ? i : 0),
    				slots: slots.map(i => i !== null && i !== void 0 ? i : 0)
    			};

    			const inputJson = JSON.stringify(input);

    			// console.log(input)
    			while (typeof Module.getSubstitutes !== "function") {
    				yield sleep(100);
    			}

    			const result = Module.getSubstitutes(
    				JSON.stringify($charmManager.charms.map(i => {
    					// 余分なデータを落としてから渡す
    					const { rowid, skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3 } = i;

    					return {
    						rowid,
    						skill1,
    						skill1Level,
    						skill2,
    						skill2Level,
    						slot1,
    						slot2,
    						slot3
    					};
    				})),
    				inputJson
    			);

    			const matchIds = JSON.parse(result);
    			$$invalidate(5, searchResults = matchIds.map(id => $charmManager.charms.find(i => i.rowid === id)).filter(c => !isSameCharm(flatCharm2charm(c), input)));
    			$$invalidate(4, isSpinnerShown = false);
    		});
    	}

    	function reset() {
    		$$invalidate(1, currentCharm = { skills: [], skillLevels: [], slots: [] });
    		charmScanner.reset();
    	}

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmRinneSupporter> was created with unknown prop '${key}'`);
    	});

    	function camerareader_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domCameraReader = $$value;
    			$$invalidate(2, domCameraReader);
    		});
    	}

    	function recordbutton_isRecording_binding(value) {
    		isRecording = value;
    		$$invalidate(3, isRecording);
    	}

    	function rangeslider_values_binding(value) {
    		charmPosMatchThresholdSliderValues = value;
    		$$invalidate(0, charmPosMatchThresholdSliderValues);
    	}

    	const click_handler = () => {
    		reset();
    	};

    	function charmpositioninput_page_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.page, value)) {
    			currentCharm.page = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function charmpositioninput_row_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.row, value)) {
    			currentCharm.row = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function charmpositioninput_col_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.col, value)) {
    			currentCharm.col = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function rarityinput_value_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.rarity, value)) {
    			currentCharm.rarity = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function skillinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skills[i], value)) {
    			currentCharm.skills[i] = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function skilllevelinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skillLevels[i], value)) {
    			currentCharm.skillLevels[i] = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	function slotsinput_values_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.slots, value)) {
    			currentCharm.slots = value;
    			$$invalidate(1, currentCharm);
    		}
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		dayjs: dayjs_min,
    		writable,
    		MDBBtn,
    		RangeSlider,
    		CameraReader,
    		CharmPositionInput,
    		RarityInput: CharmRarityInput,
    		SkillInput: CharmSkillInput,
    		SkillLevelInput: CharmSkillLevelInput,
    		SlotsInput: CharmSlotsInput,
    		CharmMinimap,
    		RecordButton,
    		CharmTableWithPager,
    		MAX_PAGE,
    		ROWS_PER_PAGE_IN_RINNE,
    		COLS_PER_PAGE_IN_RINNE,
    		isSameCharm,
    		flatCharm2charm,
    		MHRiseCharmScanner,
    		SCAN_MODE,
    		SCAN_SKIP_MODE,
    		charmManager,
    		isAppReady,
    		sleep,
    		charmScanner,
    		domCameraReader,
    		isRecording,
    		isRegisterEnabled,
    		isPositionAdjustRequired,
    		charmPosMatchThreshold,
    		charmPosMatchThresholdSliderValues,
    		currentCharm,
    		imageProcessor,
    		init,
    		domCharmTable,
    		isSpinnerShown,
    		searchResults,
    		updateResult,
    		reset,
    		$charmManager,
    		$isAppReady
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("charmScanner" in $$props) $$invalidate(6, charmScanner = $$props.charmScanner);
    		if ("domCameraReader" in $$props) $$invalidate(2, domCameraReader = $$props.domCameraReader);
    		if ("isRecording" in $$props) $$invalidate(3, isRecording = $$props.isRecording);
    		if ("isRegisterEnabled" in $$props) isRegisterEnabled = $$props.isRegisterEnabled;
    		if ("isPositionAdjustRequired" in $$props) isPositionAdjustRequired = $$props.isPositionAdjustRequired;
    		if ("charmPosMatchThreshold" in $$props) charmPosMatchThreshold = $$props.charmPosMatchThreshold;
    		if ("charmPosMatchThresholdSliderValues" in $$props) $$invalidate(0, charmPosMatchThresholdSliderValues = $$props.charmPosMatchThresholdSliderValues);
    		if ("currentCharm" in $$props) $$invalidate(1, currentCharm = $$props.currentCharm);
    		if ("domCharmTable" in $$props) domCharmTable = $$props.domCharmTable;
    		if ("isSpinnerShown" in $$props) $$invalidate(4, isSpinnerShown = $$props.isSpinnerShown);
    		if ("searchResults" in $$props) $$invalidate(5, searchResults = $$props.searchResults);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*charmPosMatchThresholdSliderValues*/ 1) {
    			charmPosMatchThreshold = charmPosMatchThresholdSliderValues[0];
    		}

    		if ($$self.$$.dirty[0] & /*currentCharm*/ 2) {
    			// $: updateResult({
    			//   skills:      currentCharm.skills,
    			//   skillLevels: currentCharm.skillLevels,
    			//   slots:       currentCharm.slots,
    			// })
    			updateResult(currentCharm);
    		}
    	};

    	return [
    		charmPosMatchThresholdSliderValues,
    		currentCharm,
    		domCameraReader,
    		isRecording,
    		isSpinnerShown,
    		searchResults,
    		charmScanner,
    		imageProcessor,
    		reset,
    		camerareader_binding,
    		recordbutton_isRecording_binding,
    		rangeslider_values_binding,
    		click_handler,
    		charmpositioninput_page_binding,
    		charmpositioninput_row_binding,
    		charmpositioninput_col_binding,
    		rarityinput_value_binding,
    		skillinput_value_binding,
    		skilllevelinput_value_binding,
    		slotsinput_values_binding
    	];
    }

    class CharmRinneSupporter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmRinneSupporter",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src/pages/CharmSearcher.svelte generated by Svelte v3.38.2 */
    const file$7 = "src/pages/CharmSearcher.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[26] = list;
    	child_ctx[27] = i;
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[28] = list;
    	child_ctx[29] = i;
    	return child_ctx;
    }

    // (115:8) {#each [...Array(skillFilters.filter(i => i).length + 1).keys()] as i}
    function create_each_block_2$1(ctx) {
    	let div;
    	let autocomplete0;
    	let updating_selectedItem;
    	let t0;
    	let autocomplete1;
    	let updating_selectedItem_1;
    	let t1;
    	let current;

    	function autocomplete0_selectedItem_binding(value) {
    		/*autocomplete0_selectedItem_binding*/ ctx[13](value, /*i*/ ctx[23]);
    	}

    	let autocomplete0_props = {
    		items: allSkillDetails,
    		inputId: "input-skill-" + /*i*/ ctx[23],
    		labelFieldName: "name",
    		valueFieldName: "name",
    		keywordsFunction: func_1,
    		placeholder: "スキル" + (/*i*/ ctx[23] + 1),
    		showClear: true,
    		hideArrow: true,
    		className: "autocomplete-skill"
    	};

    	if (/*skillFilters*/ ctx[0][/*i*/ ctx[23]] !== void 0) {
    		autocomplete0_props.selectedItem = /*skillFilters*/ ctx[0][/*i*/ ctx[23]];
    	}

    	autocomplete0 = new SimpleAutocomplete({
    			props: autocomplete0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete0, "selectedItem", autocomplete0_selectedItem_binding));

    	function autocomplete1_selectedItem_binding(value) {
    		/*autocomplete1_selectedItem_binding*/ ctx[14](value, /*i*/ ctx[23]);
    	}

    	let autocomplete1_props = {
    		items: /*SKILL_LEVEL_LIST*/ ctx[11],
    		inputId: "input-skill-level-" + /*i*/ ctx[23],
    		placeholder: "Lv",
    		hideArrow: true,
    		className: "autocomplete-skill-level"
    	};

    	if (/*skillLevelFilters*/ ctx[1][/*i*/ ctx[23]] !== void 0) {
    		autocomplete1_props.selectedItem = /*skillLevelFilters*/ ctx[1][/*i*/ ctx[23]];
    	}

    	autocomplete1 = new SimpleAutocomplete({
    			props: autocomplete1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete1, "selectedItem", autocomplete1_selectedItem_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(autocomplete0.$$.fragment);
    			t0 = space();
    			create_component(autocomplete1.$$.fragment);
    			t1 = space();
    			add_location(div, file$7, 115, 10, 3813);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(autocomplete0, div, null);
    			append_dev(div, t0);
    			mount_component(autocomplete1, div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const autocomplete0_changes = {};
    			if (dirty & /*skillFilters*/ 1) autocomplete0_changes.inputId = "input-skill-" + /*i*/ ctx[23];
    			if (dirty & /*skillFilters*/ 1) autocomplete0_changes.placeholder = "スキル" + (/*i*/ ctx[23] + 1);

    			if (!updating_selectedItem && dirty & /*skillFilters, Array*/ 1) {
    				updating_selectedItem = true;
    				autocomplete0_changes.selectedItem = /*skillFilters*/ ctx[0][/*i*/ ctx[23]];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete0.$set(autocomplete0_changes);
    			const autocomplete1_changes = {};
    			if (dirty & /*skillFilters*/ 1) autocomplete1_changes.inputId = "input-skill-level-" + /*i*/ ctx[23];

    			if (!updating_selectedItem_1 && dirty & /*skillLevelFilters, Array, skillFilters*/ 3) {
    				updating_selectedItem_1 = true;
    				autocomplete1_changes.selectedItem = /*skillLevelFilters*/ ctx[1][/*i*/ ctx[23]];
    				add_flush_callback(() => updating_selectedItem_1 = false);
    			}

    			autocomplete1.$set(autocomplete1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete0.$$.fragment, local);
    			transition_in(autocomplete1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete0.$$.fragment, local);
    			transition_out(autocomplete1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(autocomplete0);
    			destroy_component(autocomplete1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(115:8) {#each [...Array(skillFilters.filter(i => i).length + 1).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    // (140:8) {#each [...Array(MAX_SLOTS).keys()] as i}
    function create_each_block_1$2(ctx) {
    	let autocomplete;
    	let updating_selectedItem;
    	let t;
    	let current;

    	function autocomplete_selectedItem_binding(value) {
    		/*autocomplete_selectedItem_binding*/ ctx[15](value, /*i*/ ctx[23]);
    	}

    	let autocomplete_props = {
    		items: [...Array(3).keys()].map(func_2),
    		placeholder: "スロット" + (/*i*/ ctx[23] + 1),
    		inputId: "input-slot-" + /*i*/ ctx[23],
    		showClear: true,
    		hideArrow: true,
    		className: "autocomplete-slot-level"
    	};

    	if (/*slots*/ ctx[2][/*i*/ ctx[23]] !== void 0) {
    		autocomplete_props.selectedItem = /*slots*/ ctx[2][/*i*/ ctx[23]];
    	}

    	autocomplete = new SimpleAutocomplete({
    			props: autocomplete_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));

    	const block = {
    		c: function create() {
    			create_component(autocomplete.$$.fragment);
    			t = text(" ");
    		},
    		m: function mount(target, anchor) {
    			mount_component(autocomplete, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const autocomplete_changes = {};

    			if (!updating_selectedItem && dirty & /*slots, Array, MAX_SLOTS*/ 4) {
    				updating_selectedItem = true;
    				autocomplete_changes.selectedItem = /*slots*/ ctx[2][/*i*/ ctx[23]];
    				add_flush_callback(() => updating_selectedItem = false);
    			}

    			autocomplete.$set(autocomplete_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autocomplete.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autocomplete.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(autocomplete, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(140:8) {#each [...Array(MAX_SLOTS).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    // (175:6) {:else}
    function create_else_block$2(ctx) {
    	let t0;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t5;
    	let charmtable;
    	let updating_charms;
    	let updating_sliceBegin;
    	let updating_sliceEnd;
    	let t6;
    	let div;
    	let ul;
    	let li0;
    	let span1;
    	let span0;
    	let li0_class_value;
    	let t8;
    	let t9;
    	let li1;
    	let span3;
    	let span2;
    	let li1_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	function charmtable_charms_binding(value) {
    		/*charmtable_charms_binding*/ ctx[17](value);
    	}

    	function charmtable_sliceBegin_binding(value) {
    		/*charmtable_sliceBegin_binding*/ ctx[18](value);
    	}

    	function charmtable_sliceEnd_binding(value) {
    		/*charmtable_sliceEnd_binding*/ ctx[19](value);
    	}

    	let charmtable_props = {
    		disableFilterHeader: true,
    		headerColor: "dodgerblue"
    	};

    	if (/*searchResultsToShow*/ ctx[8] !== void 0) {
    		charmtable_props.charms = /*searchResultsToShow*/ ctx[8];
    	}

    	if (/*sliceBegin*/ ctx[9] !== void 0) {
    		charmtable_props.sliceBegin = /*sliceBegin*/ ctx[9];
    	}

    	if (/*sliceEnd*/ ctx[10] !== void 0) {
    		charmtable_props.sliceEnd = /*sliceEnd*/ ctx[10];
    	}

    	charmtable = new CharmTable({ props: charmtable_props, $$inline: true });
    	binding_callbacks.push(() => bind(charmtable, "charms", charmtable_charms_binding));
    	binding_callbacks.push(() => bind(charmtable, "sliceBegin", charmtable_sliceBegin_binding));
    	binding_callbacks.push(() => bind(charmtable, "sliceEnd", charmtable_sliceEnd_binding));
    	let each_value = [...Array(/*nPages*/ ctx[6]).keys()];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			t0 = text("show\n        ");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "10";
    			option1 = element("option");
    			option1.textContent = "25";
    			option2 = element("option");
    			option2.textContent = "50";
    			option3 = element("option");
    			option3.textContent = "100";
    			t5 = text("\n        charms\n        ");
    			create_component(charmtable.$$.fragment);
    			t6 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			span1 = element("span");
    			span0 = element("span");
    			span0.textContent = "«";
    			t8 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			li1 = element("li");
    			span3 = element("span");
    			span2 = element("span");
    			span2.textContent = "»";
    			option0.__value = "10";
    			option0.value = option0.__value;
    			add_location(option0, file$7, 177, 10, 6150);
    			option1.__value = "25";
    			option1.value = option1.__value;
    			add_location(option1, file$7, 178, 10, 6180);
    			option2.__value = "50";
    			option2.value = option2.__value;
    			add_location(option2, file$7, 179, 10, 6210);
    			option3.__value = "100";
    			option3.value = option3.__value;
    			add_location(option3, file$7, 180, 10, 6240);
    			if (/*itemsPerPage*/ ctx[5] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
    			add_location(select, file$7, 176, 8, 6105);
    			attr_dev(span0, "aria-hidden", "true");
    			add_location(span0, file$7, 193, 16, 6793);
    			attr_dev(span1, "class", "page-link");
    			add_location(span1, file$7, 192, 14, 6721);
    			attr_dev(li0, "class", li0_class_value = "page-item " + (/*currentPage*/ ctx[4] === 0 ? "disabled" : ""));
    			attr_dev(li0, "aria-label", "Previous");
    			add_location(li0, file$7, 191, 12, 6624);
    			attr_dev(span2, "aria-hidden", "true");
    			add_location(span2, file$7, 203, 16, 7313);
    			attr_dev(span3, "class", "page-link");
    			add_location(span3, file$7, 202, 14, 7241);

    			attr_dev(li1, "class", li1_class_value = "page-item " + (/*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1
    			? "disabled"
    			: ""));

    			attr_dev(li1, "aria-label", "Next");
    			add_location(li1, file$7, 201, 12, 7137);
    			attr_dev(ul, "class", "pagination svelte-5c44pb");
    			add_location(ul, file$7, 190, 10, 6588);
    			attr_dev(div, "id", "charm-search-result-pager");
    			attr_dev(div, "class", "svelte-5c44pb");
    			add_location(div, file$7, 189, 8, 6541);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			select_option(select, /*itemsPerPage*/ ctx[5]);
    			insert_dev(target, t5, anchor);
    			mount_component(charmtable, target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, span1);
    			append_dev(span1, span0);
    			append_dev(ul, t8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t9);
    			append_dev(ul, li1);
    			append_dev(li1, span3);
    			append_dev(span3, span2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[16]),
    					listen_dev(span1, "click", /*click_handler*/ ctx[20], false, false, false),
    					listen_dev(span3, "click", /*click_handler_2*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*itemsPerPage*/ 32) {
    				select_option(select, /*itemsPerPage*/ ctx[5]);
    			}

    			const charmtable_changes = {};

    			if (!updating_charms && dirty & /*searchResultsToShow*/ 256) {
    				updating_charms = true;
    				charmtable_changes.charms = /*searchResultsToShow*/ ctx[8];
    				add_flush_callback(() => updating_charms = false);
    			}

    			if (!updating_sliceBegin && dirty & /*sliceBegin*/ 512) {
    				updating_sliceBegin = true;
    				charmtable_changes.sliceBegin = /*sliceBegin*/ ctx[9];
    				add_flush_callback(() => updating_sliceBegin = false);
    			}

    			if (!updating_sliceEnd && dirty & /*sliceEnd*/ 1024) {
    				updating_sliceEnd = true;
    				charmtable_changes.sliceEnd = /*sliceEnd*/ ctx[10];
    				add_flush_callback(() => updating_sliceEnd = false);
    			}

    			charmtable.$set(charmtable_changes);

    			if (!current || dirty & /*currentPage*/ 16 && li0_class_value !== (li0_class_value = "page-item " + (/*currentPage*/ ctx[4] === 0 ? "disabled" : ""))) {
    				attr_dev(li0, "class", li0_class_value);
    			}

    			if (dirty & /*Array, nPages, currentPage*/ 80) {
    				each_value = [...Array(/*nPages*/ ctx[6]).keys()];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t9);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*currentPage, nPages*/ 80 && li1_class_value !== (li1_class_value = "page-item " + (/*currentPage*/ ctx[4] === /*nPages*/ ctx[6] - 1
    			? "disabled"
    			: ""))) {
    				attr_dev(li1, "class", li1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmtable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmtable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(select);
    			if (detaching) detach_dev(t5);
    			destroy_component(charmtable, detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(175:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (173:43) 
    function create_if_block_2$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "not found";
    			set_style(div, "text-align", "center");
    			add_location(div, file$7, 173, 8, 6022);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(173:43) ",
    		ctx
    	});

    	return block;
    }

    // (171:38) 
    function create_if_block_1$1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(171:38) ",
    		ctx
    	});

    	return block;
    }

    // (169:6) {#if isSpinnerShown}
    function create_if_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spinner-border text-info");
    			attr_dev(div, "role", "status");
    			add_location(div, file$7, 169, 8, 5849);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(169:6) {#if isSpinnerShown}",
    		ctx
    	});

    	return block;
    }

    // (197:12) {#each [...Array(nPages).keys()] as i}
    function create_each_block$3(ctx) {
    	let li;
    	let span;
    	let t_value = /*i*/ ctx[23] + 1 + "";
    	let t;
    	let li_class_value;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[21](/*i*/ ctx[23]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "page-link");
    			add_location(span, file$7, 198, 16, 7013);
    			attr_dev(li, "class", li_class_value = "page-item " + (/*i*/ ctx[23] === /*currentPage*/ ctx[4] ? "active" : ""));
    			add_location(li, file$7, 197, 14, 6938);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*nPages*/ 64 && t_value !== (t_value = /*i*/ ctx[23] + 1 + "")) set_data_dev(t, t_value);

    			if (dirty & /*nPages, currentPage*/ 80 && li_class_value !== (li_class_value = "page-item " + (/*i*/ ctx[23] === /*currentPage*/ ctx[4] ? "active" : ""))) {
    				attr_dev(li, "class", li_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(197:12) {#each [...Array(nPages).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div5;
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let t2;
    	let br;
    	let t3;
    	let t4;
    	let hr;
    	let t5;
    	let div3;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_2 = [...Array(/*skillFilters*/ ctx[0].filter(func).length + 1).keys()];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value_1 = [...Array(MAX_SLOTS).keys()];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block$2, create_if_block_1$1, create_if_block_2$1, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isSpinnerShown*/ ctx[7]) return 0;
    		if (/*searchResults*/ ctx[3] == null) return 1;
    		if (/*searchResults*/ ctx[3].length === 0) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text("スキル:\n        ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			t2 = text("スロット:");
    			br = element("br");
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			hr = element("hr");
    			t5 = space();
    			div3 = element("div");
    			if_block.c();
    			attr_dev(div0, "id", "skills");
    			attr_dev(div0, "class", "svelte-5c44pb");
    			add_location(div0, file$7, 112, 6, 3693);
    			add_location(br, file$7, 138, 13, 4814);
    			attr_dev(div1, "id", "slots");
    			attr_dev(div1, "class", "svelte-5c44pb");
    			add_location(div1, file$7, 137, 6, 4784);
    			attr_dev(div2, "id", "charm-search-form");
    			attr_dev(div2, "class", "svelte-5c44pb");
    			add_location(div2, file$7, 111, 4, 3658);
    			attr_dev(hr, "class", "svelte-5c44pb");
    			add_location(hr, file$7, 165, 4, 5773);
    			attr_dev(div3, "id", "charm-search-result");
    			attr_dev(div3, "class", "svelte-5c44pb");
    			add_location(div3, file$7, 167, 4, 5783);
    			attr_dev(div4, "id", "charm-searcher");
    			attr_dev(div4, "class", "svelte-5c44pb");
    			add_location(div4, file$7, 109, 2, 3601);
    			attr_dev(div5, "class", "tab-content svelte-5c44pb");
    			add_location(div5, file$7, 108, 0, 3573);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div0, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, br);
    			append_dev(div1, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			append_dev(div4, t4);
    			append_dev(div4, hr);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			if_blocks[current_block_type_index].m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", handleKeydown, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*SKILL_LEVEL_LIST, Array, skillFilters, skillLevelFilters, allSkillDetails*/ 2051) {
    				each_value_2 = [...Array(/*skillFilters*/ ctx[0].filter(func).length + 1).keys()];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_2$1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*Array, MAX_SLOTS, slots*/ 4) {
    				each_value_1 = [...Array(MAX_SLOTS).keys()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div3, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const MAX_SKILL_LEVEL = 7;
    const MAX_SLOTS = 3;

    function handleKeydown(event) {
    	if (event.key === "Escape") {
    		document.body.click();
    		return;
    	}

    	// key combination
    	if (!(event.ctrlKey && event.metaKey || event.ctrlKey && event.altKey)) {
    		return;
    	}

    	let elementBasename = "";

    	if (event.key === "k") {
    		elementBasename = "input-skill-";
    	} else if (event.key === "l") {
    		elementBasename = "input-skill-level-";
    	} else if (event.key === "t") {
    		elementBasename = "input-slot-";
    	} else {
    		return;
    	}

    	const focusedId = document.activeElement.id;

    	if (focusedId.startsWith(elementBasename)) {
    		const currentSuffix = parseInt(focusedId.replace(elementBasename, ""));
    		const nextFocus = document.getElementById(`${elementBasename}${currentSuffix + 1}`) || document.getElementById(`${elementBasename}0`);
    		document.body.click();
    		nextFocus.focus();
    	} else {
    		const nextFocus = document.getElementById(`${elementBasename}0`);
    		document.body.click();
    		nextFocus.focus();
    	}
    }

    const func = i => i;
    const func_1 = s => `${s.name} ${s.hiragana} ${s.englishCharacters}`;
    const func_2 = i => i + 1;

    function instance$7($$self, $$props, $$invalidate) {
    	let nPages;
    	let searchResultsToShow;
    	let sliceBegin;
    	let sliceEnd;
    	let $charmManager;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(12, $charmManager = $$value));
    	let { $$slots: slots$1 = {}, $$scope } = $$props;
    	validate_slots("CharmSearcher", slots$1, []);
    	
    	const SKILL_LEVEL_LIST = [...Array(MAX_SKILL_LEVEL).keys()].map(i => i + 1); // 補完用
    	let skillFilters = [];
    	let skillLevelFilters = [];
    	let slots = [];
    	let isSpinnerShown = false;
    	let searchResults = null;

    	// table pagination
    	let currentPage = 0, itemsPerPage = 10;

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmSearcher> was created with unknown prop '${key}'`);
    	});

    	function autocomplete0_selectedItem_binding(value, i) {
    		if ($$self.$$.not_equal(skillFilters[i], value)) {
    			skillFilters[i] = value;
    			$$invalidate(0, skillFilters);
    		}
    	}

    	function autocomplete1_selectedItem_binding(value, i) {
    		if ($$self.$$.not_equal(skillLevelFilters[i], value)) {
    			skillLevelFilters[i] = value;
    			($$invalidate(1, skillLevelFilters), $$invalidate(0, skillFilters));
    		}
    	}

    	function autocomplete_selectedItem_binding(value, i) {
    		if ($$self.$$.not_equal(slots[i], value)) {
    			slots[i] = value;
    			((($$invalidate(2, slots), $$invalidate(0, skillFilters)), $$invalidate(1, skillLevelFilters)), $$invalidate(12, $charmManager));
    		}
    	}

    	function select_change_handler() {
    		itemsPerPage = select_value(this);
    		$$invalidate(5, itemsPerPage);
    	}

    	function charmtable_charms_binding(value) {
    		searchResultsToShow = value;
    		((((($$invalidate(8, searchResultsToShow), $$invalidate(3, searchResults)), $$invalidate(2, slots)), $$invalidate(0, skillFilters)), $$invalidate(1, skillLevelFilters)), $$invalidate(12, $charmManager));
    	}

    	function charmtable_sliceBegin_binding(value) {
    		sliceBegin = value;
    		(((((((($$invalidate(9, sliceBegin), $$invalidate(5, itemsPerPage)), $$invalidate(4, currentPage)), $$invalidate(3, searchResults)), $$invalidate(6, nPages)), $$invalidate(2, slots)), $$invalidate(0, skillFilters)), $$invalidate(1, skillLevelFilters)), $$invalidate(12, $charmManager));
    	}

    	function charmtable_sliceEnd_binding(value) {
    		sliceEnd = value;
    		(((((((($$invalidate(10, sliceEnd), $$invalidate(5, itemsPerPage)), $$invalidate(4, currentPage)), $$invalidate(3, searchResults)), $$invalidate(6, nPages)), $$invalidate(2, slots)), $$invalidate(0, skillFilters)), $$invalidate(1, skillLevelFilters)), $$invalidate(12, $charmManager));
    	}

    	const click_handler = () => $$invalidate(4, currentPage--, currentPage);
    	const click_handler_1 = i => $$invalidate(4, currentPage = i);
    	const click_handler_2 = () => $$invalidate(4, currentPage++, currentPage);

    	$$self.$capture_state = () => ({
    		AutoComplete: SimpleAutocomplete,
    		CharmTable,
    		charmManager,
    		allSkillDetails,
    		MAX_SKILL_LEVEL,
    		SKILL_LEVEL_LIST,
    		MAX_SLOTS,
    		skillFilters,
    		skillLevelFilters,
    		slots,
    		isSpinnerShown,
    		searchResults,
    		currentPage,
    		itemsPerPage,
    		handleKeydown,
    		nPages,
    		searchResultsToShow,
    		sliceBegin,
    		sliceEnd,
    		$charmManager
    	});

    	$$self.$inject_state = $$props => {
    		if ("skillFilters" in $$props) $$invalidate(0, skillFilters = $$props.skillFilters);
    		if ("skillLevelFilters" in $$props) $$invalidate(1, skillLevelFilters = $$props.skillLevelFilters);
    		if ("slots" in $$props) $$invalidate(2, slots = $$props.slots);
    		if ("isSpinnerShown" in $$props) $$invalidate(7, isSpinnerShown = $$props.isSpinnerShown);
    		if ("searchResults" in $$props) $$invalidate(3, searchResults = $$props.searchResults);
    		if ("currentPage" in $$props) $$invalidate(4, currentPage = $$props.currentPage);
    		if ("itemsPerPage" in $$props) $$invalidate(5, itemsPerPage = $$props.itemsPerPage);
    		if ("nPages" in $$props) $$invalidate(6, nPages = $$props.nPages);
    		if ("searchResultsToShow" in $$props) $$invalidate(8, searchResultsToShow = $$props.searchResultsToShow);
    		if ("sliceBegin" in $$props) $$invalidate(9, sliceBegin = $$props.sliceBegin);
    		if ("sliceEnd" in $$props) $$invalidate(10, sliceEnd = $$props.sliceEnd);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*skillFilters, skillLevelFilters*/ 3) {
    			// update form (skill)
    			{
    				for (let i = 0; i < skillFilters.length; i++) {
    					// for ... in だと i が string になるので
    					if (skillFilters[i] && skillLevelFilters[i] == null) {
    						$$invalidate(1, skillLevelFilters[i] = 1, skillLevelFilters);
    					}

    					if (skillFilters[i] == null) {
    						skillFilters.splice(i, 1);
    						skillLevelFilters.splice(i, 1);
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*slots, skillFilters, skillLevelFilters, $charmManager*/ 4103) {
    			// update result
    			{
    				$$invalidate(7, isSpinnerShown = true);
    				$$invalidate(2, slots = slots.filter(i => i));

    				const base = JSON.stringify({
    					skills: skillFilters.map(i => i.name),
    					skillLevels: skillLevelFilters,
    					slots
    				});

    				const search = () => {
    					if (!skillFilters.length && !skillLevelFilters.length && !slots.length) {
    						$$invalidate(3, searchResults = null);
    						return;
    					}

    					if (typeof Module.getSubstitutesAll !== "function") {
    						setTimeout(search, 100);
    						return;
    					}

    					const result = Module.getSubstitutes(
    						JSON.stringify($charmManager.charms.map(i => {
    							// 余分なデータを落としてから渡す
    							// return i
    							const { rowid, skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3 } = i;

    							return {
    								rowid,
    								skill1,
    								skill1Level,
    								skill2,
    								skill2Level,
    								slot1,
    								slot2,
    								slot3
    							};
    						})),
    						base
    					);

    					const matchIds = JSON.parse(result);
    					$$invalidate(3, searchResults = matchIds.map(id => $charmManager.charms.find(i => i.rowid === id)));
    				};

    				search();
    				$$invalidate(7, isSpinnerShown = false);
    			}
    		}

    		if ($$self.$$.dirty & /*searchResults, itemsPerPage*/ 40) {
    			$$invalidate(6, nPages = Math.ceil((searchResults || []).length / itemsPerPage));
    		}

    		if ($$self.$$.dirty & /*searchResults, nPages*/ 72) {
    			{
    				if (searchResults && nPages) {
    					$$invalidate(4, currentPage = 0);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*searchResults*/ 8) {
    			$$invalidate(8, searchResultsToShow = searchResults); //?.slice(itemsPerPage * currentPage, itemsPerPage * (currentPage+1))
    		}

    		if ($$self.$$.dirty & /*itemsPerPage, currentPage*/ 48) {
    			$$invalidate(9, sliceBegin = itemsPerPage * currentPage);
    		}

    		if ($$self.$$.dirty & /*itemsPerPage, currentPage*/ 48) {
    			$$invalidate(10, sliceEnd = itemsPerPage * (currentPage + 1));
    		}

    		if ($$self.$$.dirty & /*slots*/ 4) {
    			// update form (slot)
    			$$invalidate(2, slots = slots.sort((a, b) => b - a));
    		}
    	};

    	return [
    		skillFilters,
    		skillLevelFilters,
    		slots,
    		searchResults,
    		currentPage,
    		itemsPerPage,
    		nPages,
    		isSpinnerShown,
    		searchResultsToShow,
    		sliceBegin,
    		sliceEnd,
    		SKILL_LEVEL_LIST,
    		$charmManager,
    		autocomplete0_selectedItem_binding,
    		autocomplete1_selectedItem_binding,
    		autocomplete_selectedItem_binding,
    		select_change_handler,
    		charmtable_charms_binding,
    		charmtable_sliceBegin_binding,
    		charmtable_sliceEnd_binding,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class CharmSearcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmSearcher",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/pages/CharmList.svelte generated by Svelte v3.38.2 */
    const file$6 = "src/pages/CharmList.svelte";

    // (18:4) {:else}
    function create_else_block$1(ctx) {
    	let charmtable;
    	let updating_charms;
    	let current;

    	function charmtable_charms_binding(value) {
    		/*charmtable_charms_binding*/ ctx[1](value);
    	}

    	let charmtable_props = {};

    	if (/*charms*/ ctx[0] !== void 0) {
    		charmtable_props.charms = /*charms*/ ctx[0];
    	}

    	charmtable = new CharmTable({ props: charmtable_props, $$inline: true });
    	binding_callbacks.push(() => bind(charmtable, "charms", charmtable_charms_binding));

    	const block = {
    		c: function create() {
    			create_component(charmtable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmtable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmtable_changes = {};

    			if (!updating_charms && dirty & /*charms*/ 1) {
    				updating_charms = true;
    				charmtable_changes.charms = /*charms*/ ctx[0];
    				add_flush_callback(() => updating_charms = false);
    			}

    			charmtable.$set(charmtable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmtable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmtable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmtable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(18:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:4) {#if charms == null}
    function create_if_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spinner-border text-info svelte-2qpa7f");
    			attr_dev(div, "role", "status");
    			add_location(div, file$6, 14, 6, 480);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(14:4) {#if charms == null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*charms*/ ctx[0] == null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			attr_dev(div0, "id", "charm-list");
    			attr_dev(div0, "class", "svelte-2qpa7f");
    			add_location(div0, file$6, 12, 2, 427);
    			attr_dev(div1, "class", "tab-content svelte-2qpa7f");
    			add_location(div1, file$6, 11, 0, 399);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $charmManager;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(2, $charmManager = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmList", slots, []);
    	let charms;

    	setInterval(
    		() => {
    			if (charms !== ($charmManager === null || $charmManager === void 0
    			? void 0
    			: $charmManager.charms)) {
    				$$invalidate(0, charms = $charmManager === null || $charmManager === void 0
    				? void 0
    				: $charmManager.charms);
    			}
    		},
    		1000
    	);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmList> was created with unknown prop '${key}'`);
    	});

    	function charmtable_charms_binding(value) {
    		charms = value;
    		$$invalidate(0, charms);
    	}

    	$$self.$capture_state = () => ({
    		CharmTable,
    		charmManager,
    		charms,
    		$charmManager
    	});

    	$$self.$inject_state = $$props => {
    		if ("charms" in $$props) $$invalidate(0, charms = $$props.charms);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [charms, charmtable_charms_binding];
    }

    class CharmList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmList",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/pages/CharmRealtimeScanner.svelte generated by Svelte v3.38.2 */
    const file$5 = "src/pages/CharmRealtimeScanner.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	child_ctx[23] = list;
    	child_ctx[24] = i;
    	return child_ctx;
    }

    // (96:12) {#each [...Array(2).keys()] as i}
    function create_each_block_1$1(ctx) {
    	let div;
    	let skillinput;
    	let updating_value;
    	let t0;
    	let skilllevelinput;
    	let updating_value_1;
    	let t1;
    	let current;

    	function skillinput_value_binding(value) {
    		/*skillinput_value_binding*/ ctx[11](value, /*i*/ ctx[22]);
    	}

    	let skillinput_props = {
    		inputId: "input-skill-" + /*i*/ ctx[22],
    		placeholder: "スキル" + (/*i*/ ctx[22] + 1)
    	};

    	if (/*currentCharm*/ ctx[2].skills[/*i*/ ctx[22]] !== void 0) {
    		skillinput_props.value = /*currentCharm*/ ctx[2].skills[/*i*/ ctx[22]];
    	}

    	skillinput = new CharmSkillInput({ props: skillinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(skillinput, "value", skillinput_value_binding));

    	function skilllevelinput_value_binding(value) {
    		/*skilllevelinput_value_binding*/ ctx[12](value, /*i*/ ctx[22]);
    	}

    	let skilllevelinput_props = {
    		inputId: "input-skill-level-" + /*i*/ ctx[22]
    	};

    	if (/*currentCharm*/ ctx[2].skillLevels[/*i*/ ctx[22]] !== void 0) {
    		skilllevelinput_props.value = /*currentCharm*/ ctx[2].skillLevels[/*i*/ ctx[22]];
    	}

    	skilllevelinput = new CharmSkillLevelInput({
    			props: skilllevelinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(skilllevelinput, "value", skilllevelinput_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(skillinput.$$.fragment);
    			t0 = space();
    			create_component(skilllevelinput.$$.fragment);
    			t1 = space();
    			add_location(div, file$5, 96, 14, 3969);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(skillinput, div, null);
    			append_dev(div, t0);
    			mount_component(skilllevelinput, div, null);
    			append_dev(div, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const skillinput_changes = {};

    			if (!updating_value && dirty & /*currentCharm, Array*/ 4) {
    				updating_value = true;
    				skillinput_changes.value = /*currentCharm*/ ctx[2].skills[/*i*/ ctx[22]];
    				add_flush_callback(() => updating_value = false);
    			}

    			skillinput.$set(skillinput_changes);
    			const skilllevelinput_changes = {};

    			if (!updating_value_1 && dirty & /*currentCharm, Array*/ 4) {
    				updating_value_1 = true;
    				skilllevelinput_changes.value = /*currentCharm*/ ctx[2].skillLevels[/*i*/ ctx[22]];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			skilllevelinput.$set(skilllevelinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skillinput.$$.fragment, local);
    			transition_in(skilllevelinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skillinput.$$.fragment, local);
    			transition_out(skilllevelinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(skillinput);
    			destroy_component(skilllevelinput);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(96:12) {#each [...Array(2).keys()] as i}",
    		ctx
    	});

    	return block;
    }

    // (119:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}
    function create_each_block$2(ctx) {
    	let charmminimap;
    	let current;

    	charmminimap = new CharmMinimap({
    			props: {
    				page: /*page*/ ctx[19],
    				currentCharm: /*currentCharm*/ ctx[2],
    				charmScanner: /*charmScanner*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charmminimap.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charmminimap, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charmminimap_changes = {};
    			if (dirty & /*currentCharm*/ 4) charmminimap_changes.currentCharm = /*currentCharm*/ ctx[2];
    			charmminimap.$set(charmminimap_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charmminimap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charmminimap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charmminimap, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(119:8) {#each [...Array(MAX_PAGE + 1).keys()].slice(1) as page}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div10;
    	let div0;
    	let t0;
    	let div9;
    	let div8;
    	let div6;
    	let camerareader;
    	let t1;
    	let div5;
    	let recordbutton;
    	let updating_isRecording;
    	let t2;
    	let div1;
    	let t3;
    	let charmpositioninput;
    	let updating_page;
    	let updating_row;
    	let updating_col;
    	let t4;
    	let div2;
    	let t5;
    	let rarityinput;
    	let updating_value;
    	let t6;
    	let div3;
    	let t7;
    	let t8;
    	let div4;
    	let t9;
    	let slotsinput;
    	let updating_values;
    	let t10;
    	let div7;
    	let current;

    	let camerareader_props = {
    		imageProcessor: /*imageProcessor*/ ctx[4]
    	};

    	camerareader = new CameraReader({
    			props: camerareader_props,
    			$$inline: true
    		});

    	/*camerareader_binding*/ ctx[5](camerareader);

    	function recordbutton_isRecording_binding(value) {
    		/*recordbutton_isRecording_binding*/ ctx[6](value);
    	}

    	let recordbutton_props = { label: "スキャン" };

    	if (/*isRecording*/ ctx[1] !== void 0) {
    		recordbutton_props.isRecording = /*isRecording*/ ctx[1];
    	}

    	recordbutton = new RecordButton({
    			props: recordbutton_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(recordbutton, "isRecording", recordbutton_isRecording_binding));

    	function charmpositioninput_page_binding(value) {
    		/*charmpositioninput_page_binding*/ ctx[7](value);
    	}

    	function charmpositioninput_row_binding(value) {
    		/*charmpositioninput_row_binding*/ ctx[8](value);
    	}

    	function charmpositioninput_col_binding(value) {
    		/*charmpositioninput_col_binding*/ ctx[9](value);
    	}

    	let charmpositioninput_props = { inputIdPrefix: "input-position-" };

    	if (/*currentCharm*/ ctx[2].page !== void 0) {
    		charmpositioninput_props.page = /*currentCharm*/ ctx[2].page;
    	}

    	if (/*currentCharm*/ ctx[2].row !== void 0) {
    		charmpositioninput_props.row = /*currentCharm*/ ctx[2].row;
    	}

    	if (/*currentCharm*/ ctx[2].col !== void 0) {
    		charmpositioninput_props.col = /*currentCharm*/ ctx[2].col;
    	}

    	charmpositioninput = new CharmPositionInput({
    			props: charmpositioninput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(charmpositioninput, "page", charmpositioninput_page_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "row", charmpositioninput_row_binding));
    	binding_callbacks.push(() => bind(charmpositioninput, "col", charmpositioninput_col_binding));

    	function rarityinput_value_binding(value) {
    		/*rarityinput_value_binding*/ ctx[10](value);
    	}

    	let rarityinput_props = { inputId: "input-rarity" };

    	if (/*currentCharm*/ ctx[2].rarity !== void 0) {
    		rarityinput_props.value = /*currentCharm*/ ctx[2].rarity;
    	}

    	rarityinput = new CharmRarityInput({ props: rarityinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(rarityinput, "value", rarityinput_value_binding));
    	let each_value_1 = [...Array(2).keys()];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	function slotsinput_values_binding(value) {
    		/*slotsinput_values_binding*/ ctx[13](value);
    	}

    	let slotsinput_props = {
    		inputIdPrefix: "input-slot-level-",
    		placeholder: "スロット"
    	};

    	if (/*currentCharm*/ ctx[2].slots !== void 0) {
    		slotsinput_props.values = /*currentCharm*/ ctx[2].slots;
    	}

    	slotsinput = new CharmSlotsInput({ props: slotsinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(slotsinput, "values", slotsinput_values_binding));
    	let each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div10 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div6 = element("div");
    			create_component(camerareader.$$.fragment);
    			t1 = space();
    			div5 = element("div");
    			create_component(recordbutton.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			t3 = text("位置:\n            ");
    			create_component(charmpositioninput.$$.fragment);
    			t4 = space();
    			div2 = element("div");
    			t5 = text("レア度:\n            ");
    			create_component(rarityinput.$$.fragment);
    			t6 = space();
    			div3 = element("div");
    			t7 = text("スキル:\n            ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t8 = space();
    			div4 = element("div");
    			t9 = text("スロット:\n            ");
    			create_component(slotsinput.$$.fragment);
    			t10 = space();
    			div7 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "imgdump");
    			add_location(div0, file$5, 69, 2, 2960);
    			attr_dev(div1, "id", "charm-spec-position");
    			attr_dev(div1, "class", "svelte-1s2cir0");
    			add_location(div1, file$5, 79, 10, 3301);
    			attr_dev(div2, "id", "charm-spec-rarity");
    			attr_dev(div2, "class", "svelte-1s2cir0");
    			add_location(div2, file$5, 87, 10, 3656);
    			attr_dev(div3, "id", "charm-spec-skills");
    			attr_dev(div3, "class", "svelte-1s2cir0");
    			add_location(div3, file$5, 93, 10, 3863);
    			attr_dev(div4, "id", "charm-spec-slots");
    			attr_dev(div4, "class", "svelte-1s2cir0");
    			add_location(div4, file$5, 107, 10, 4418);
    			attr_dev(div5, "id", "charm-spec");
    			attr_dev(div5, "class", "svelte-1s2cir0");
    			add_location(div5, file$5, 75, 8, 3164);
    			attr_dev(div6, "id", "main");
    			attr_dev(div6, "class", "svelte-1s2cir0");
    			add_location(div6, file$5, 72, 6, 3034);
    			attr_dev(div7, "class", "charm-box-overview svelte-1s2cir0");
    			add_location(div7, file$5, 117, 6, 4701);
    			attr_dev(div8, "id", "status");
    			attr_dev(div8, "class", "svelte-1s2cir0");
    			add_location(div8, file$5, 71, 4, 3010);
    			attr_dev(div9, "id", "scanner");
    			attr_dev(div9, "class", "svelte-1s2cir0");
    			add_location(div9, file$5, 70, 2, 2987);
    			attr_dev(div10, "class", "tab-content svelte-1s2cir0");
    			add_location(div10, file$5, 68, 0, 2932);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div10, anchor);
    			append_dev(div10, div0);
    			append_dev(div10, t0);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div6);
    			mount_component(camerareader, div6, null);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			mount_component(recordbutton, div5, null);
    			append_dev(div5, t2);
    			append_dev(div5, div1);
    			append_dev(div1, t3);
    			mount_component(charmpositioninput, div1, null);
    			append_dev(div5, t4);
    			append_dev(div5, div2);
    			append_dev(div2, t5);
    			mount_component(rarityinput, div2, null);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div3, t7);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div3, null);
    			}

    			append_dev(div5, t8);
    			append_dev(div5, div4);
    			append_dev(div4, t9);
    			mount_component(slotsinput, div4, null);
    			append_dev(div8, t10);
    			append_dev(div8, div7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div7, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const camerareader_changes = {};
    			camerareader.$set(camerareader_changes);
    			const recordbutton_changes = {};

    			if (!updating_isRecording && dirty & /*isRecording*/ 2) {
    				updating_isRecording = true;
    				recordbutton_changes.isRecording = /*isRecording*/ ctx[1];
    				add_flush_callback(() => updating_isRecording = false);
    			}

    			recordbutton.$set(recordbutton_changes);
    			const charmpositioninput_changes = {};

    			if (!updating_page && dirty & /*currentCharm*/ 4) {
    				updating_page = true;
    				charmpositioninput_changes.page = /*currentCharm*/ ctx[2].page;
    				add_flush_callback(() => updating_page = false);
    			}

    			if (!updating_row && dirty & /*currentCharm*/ 4) {
    				updating_row = true;
    				charmpositioninput_changes.row = /*currentCharm*/ ctx[2].row;
    				add_flush_callback(() => updating_row = false);
    			}

    			if (!updating_col && dirty & /*currentCharm*/ 4) {
    				updating_col = true;
    				charmpositioninput_changes.col = /*currentCharm*/ ctx[2].col;
    				add_flush_callback(() => updating_col = false);
    			}

    			charmpositioninput.$set(charmpositioninput_changes);
    			const rarityinput_changes = {};

    			if (!updating_value && dirty & /*currentCharm*/ 4) {
    				updating_value = true;
    				rarityinput_changes.value = /*currentCharm*/ ctx[2].rarity;
    				add_flush_callback(() => updating_value = false);
    			}

    			rarityinput.$set(rarityinput_changes);

    			if (dirty & /*Array, currentCharm*/ 4) {
    				each_value_1 = [...Array(2).keys()];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			const slotsinput_changes = {};

    			if (!updating_values && dirty & /*currentCharm*/ 4) {
    				updating_values = true;
    				slotsinput_changes.values = /*currentCharm*/ ctx[2].slots;
    				add_flush_callback(() => updating_values = false);
    			}

    			slotsinput.$set(slotsinput_changes);

    			if (dirty & /*Array, MAX_PAGE, currentCharm, charmScanner*/ 12) {
    				each_value = [...Array(MAX_PAGE + 1).keys()].slice(1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div7, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(camerareader.$$.fragment, local);
    			transition_in(recordbutton.$$.fragment, local);
    			transition_in(charmpositioninput.$$.fragment, local);
    			transition_in(rarityinput.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(slotsinput.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(camerareader.$$.fragment, local);
    			transition_out(recordbutton.$$.fragment, local);
    			transition_out(charmpositioninput.$$.fragment, local);
    			transition_out(rarityinput.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(slotsinput.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div10);
    			/*camerareader_binding*/ ctx[5](null);
    			destroy_component(camerareader);
    			destroy_component(recordbutton);
    			destroy_component(charmpositioninput);
    			destroy_component(rarityinput);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(slotsinput);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $charmManager;
    	let $isAppReady;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(15, $charmManager = $$value));
    	validate_store(isAppReady, "isAppReady");
    	component_subscribe($$self, isAppReady, $$value => $$invalidate(16, $isAppReady = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmRealtimeScanner", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	
    	

    	// const VIDEO_WIDTH      = 1280 // switch のキャプチャ解像度
    	// const VIDEO_HEIGHT     = 720
    	// const VIDEO_FRAME_RATE = 29.97
    	let charmScanner = new MHRiseCharmScanner({
    			scanMode: SCAN_MODE.MODE_EQUIP_LIST,
    			scanSkipMode: SCAN_SKIP_MODE.SKIP_SAME_CHARM_AS_IMMEDIATELY_BEFORE
    		});

    	let domCameraReader;
    	let isRecording = false;
    	let isRegisterEnabled = true;
    	let isPositionAdjustRequired = true;

    	// form to show and fix scanned data
    	let currentCharm = { skills: [], skillLevels: [], slots: [] };

    	const imageProcessor = frame => __awaiter(void 0, void 0, void 0, function* () {
    		if (!isRecording) {
    			return;
    		}

    		if (isPositionAdjustRequired) {
    			isPositionAdjustRequired = false;
    			charmScanner.adjustPosition(frame);
    		}

    		const result = charmScanner.scan(frame, dayjs_min().format());

    		if (result == null) {
    			return;
    		}

    		const { charm, isCache } = result;

    		// 表示を更新
    		$$invalidate(2, currentCharm = charm);

    		if (!isCache && isRegisterEnabled) {
    			// nScanedCharms = charmScanner.countCharms()
    			yield $charmManager.registerCharm(charm, frame);
    		}
    	});

    	(() => __awaiter(void 0, void 0, void 0, function* () {
    		while (!$isAppReady) {
    			yield new Promise(r => setTimeout(r, 1000));
    		}

    		yield domCameraReader.init();
    	}))();

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharmRealtimeScanner> was created with unknown prop '${key}'`);
    	});

    	function camerareader_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domCameraReader = $$value;
    			$$invalidate(0, domCameraReader);
    		});
    	}

    	function recordbutton_isRecording_binding(value) {
    		isRecording = value;
    		$$invalidate(1, isRecording);
    	}

    	function charmpositioninput_page_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.page, value)) {
    			currentCharm.page = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function charmpositioninput_row_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.row, value)) {
    			currentCharm.row = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function charmpositioninput_col_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.col, value)) {
    			currentCharm.col = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function rarityinput_value_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.rarity, value)) {
    			currentCharm.rarity = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function skillinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skills[i], value)) {
    			currentCharm.skills[i] = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function skilllevelinput_value_binding(value, i) {
    		if ($$self.$$.not_equal(currentCharm.skillLevels[i], value)) {
    			currentCharm.skillLevels[i] = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	function slotsinput_values_binding(value) {
    		if ($$self.$$.not_equal(currentCharm.slots, value)) {
    			currentCharm.slots = value;
    			$$invalidate(2, currentCharm);
    		}
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		dayjs: dayjs_min,
    		writable,
    		MDBBtn,
    		CameraReader,
    		CharmPositionInput,
    		RarityInput: CharmRarityInput,
    		SkillInput: CharmSkillInput,
    		SkillLevelInput: CharmSkillLevelInput,
    		SlotsInput: CharmSlotsInput,
    		CharmMinimap,
    		RecordButton,
    		MAX_PAGE,
    		MHRiseCharmScanner,
    		SCAN_MODE,
    		SCAN_SKIP_MODE,
    		charmManager,
    		isAppReady,
    		charmScanner,
    		domCameraReader,
    		isRecording,
    		isRegisterEnabled,
    		isPositionAdjustRequired,
    		currentCharm,
    		imageProcessor,
    		$charmManager,
    		$isAppReady
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("charmScanner" in $$props) $$invalidate(3, charmScanner = $$props.charmScanner);
    		if ("domCameraReader" in $$props) $$invalidate(0, domCameraReader = $$props.domCameraReader);
    		if ("isRecording" in $$props) $$invalidate(1, isRecording = $$props.isRecording);
    		if ("isRegisterEnabled" in $$props) isRegisterEnabled = $$props.isRegisterEnabled;
    		if ("isPositionAdjustRequired" in $$props) isPositionAdjustRequired = $$props.isPositionAdjustRequired;
    		if ("currentCharm" in $$props) $$invalidate(2, currentCharm = $$props.currentCharm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		domCameraReader,
    		isRecording,
    		currentCharm,
    		charmScanner,
    		imageProcessor,
    		camerareader_binding,
    		recordbutton_isRecording_binding,
    		charmpositioninput_page_binding,
    		charmpositioninput_row_binding,
    		charmpositioninput_col_binding,
    		rarityinput_value_binding,
    		skillinput_value_binding,
    		skilllevelinput_value_binding,
    		slotsinput_values_binding
    	];
    }

    class CharmRealtimeScanner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmRealtimeScanner",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/components/parts/VideoReader.svelte generated by Svelte v3.38.2 */
    const file$4 = "src/components/parts/VideoReader.svelte";

    function create_fragment$4(ctx) {
    	let div1;
    	let video;
    	let track;
    	let video_id_value;
    	let video_src_value;
    	let video_alt_value;
    	let video_style_value;
    	let t0;
    	let div0;
    	let progress_1;
    	let t1;
    	let span;
    	let t2_value = Math.floor(/*progress*/ ctx[4] * 100) + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			video = element("video");
    			track = element("track");
    			t0 = space();
    			div0 = element("div");
    			progress_1 = element("progress");
    			t1 = space();
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = text("%");
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$4, 72, 4, 2774);
    			attr_dev(video, "id", video_id_value = "video" + /*index*/ ctx[0]);
    			attr_dev(video, "class", "video-preview svelte-syjktf");
    			if (video.src !== (video_src_value = /*videoData*/ ctx[1])) attr_dev(video, "src", video_src_value);
    			attr_dev(video, "width", videoWidth);
    			attr_dev(video, "height", videoHeight);
    			attr_dev(video, "alt", video_alt_value = "preview" + /*index*/ ctx[0]);
    			attr_dev(video, "style", video_style_value = /*isVideoVisible*/ ctx[2] ? "" : "display: none");
    			add_location(video, file$4, 64, 2, 2507);
    			progress_1.value = /*progress*/ ctx[4];
    			attr_dev(progress_1, "class", "svelte-syjktf");
    			add_location(progress_1, file$4, 76, 4, 2822);
    			attr_dev(span, "class", "progress-text svelte-syjktf");
    			add_location(span, file$4, 77, 4, 2865);
    			add_location(div0, file$4, 75, 2, 2812);
    			attr_dev(div1, "class", "video-reader svelte-syjktf");
    			add_location(div1, file$4, 63, 0, 2478);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, video);
    			append_dev(video, track);
    			/*video_binding*/ ctx[9](video);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, progress_1);
    			append_dev(div0, t1);
    			append_dev(div0, span);
    			append_dev(span, t2);
    			append_dev(span, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*index*/ 1 && video_id_value !== (video_id_value = "video" + /*index*/ ctx[0])) {
    				attr_dev(video, "id", video_id_value);
    			}

    			if (dirty & /*videoData*/ 2 && video.src !== (video_src_value = /*videoData*/ ctx[1])) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (dirty & /*index*/ 1 && video_alt_value !== (video_alt_value = "preview" + /*index*/ ctx[0])) {
    				attr_dev(video, "alt", video_alt_value);
    			}

    			if (dirty & /*isVideoVisible*/ 4 && video_style_value !== (video_style_value = /*isVideoVisible*/ ctx[2] ? "" : "display: none")) {
    				attr_dev(video, "style", video_style_value);
    			}

    			if (dirty & /*progress*/ 16) {
    				prop_dev(progress_1, "value", /*progress*/ ctx[4]);
    			}

    			if (dirty & /*progress*/ 16 && t2_value !== (t2_value = Math.floor(/*progress*/ ctx[4] * 100) + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*video_binding*/ ctx[9](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const FRAME_RATE = 29.97;
    const videoWidth = 1280;
    const videoHeight = 720;

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VideoReader", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	let { nSplits } = $$props;
    	let { index } = $$props;
    	let { videoName } = $$props;
    	let { videoData } = $$props;
    	let { isVideoVisible = false } = $$props;
    	let { onCapture } = $$props;
    	let { onFinish } = $$props;
    	let beginTime, endTime;
    	let domVideo;
    	let capture;
    	let frame = new cv__default['default'].Mat(videoHeight, videoWidth, cv__default['default'].CV_8UC4);
    	let progress = 0;

    	(() => __awaiter(void 0, void 0, void 0, function* () {
    		yield new Promise(r => requestAnimationFrame(r));
    		yield new Promise(r => $$invalidate(3, domVideo.oncanplay = r, domVideo));
    		capture = new cv__default['default'].VideoCapture(domVideo);
    		beginTime = index * domVideo.duration / nSplits;
    		endTime = (index + 1) * domVideo.duration / nSplits;
    		domVideo.addEventListener("seeked", processCurrentFrame);

    		// console.log( domVideo.currentTime, domVideo.duration, index, nSplits, beginTime, endTime )
    		if (domVideo.currentTime != beginTime) {
    			$$invalidate(3, domVideo.currentTime = beginTime, domVideo);
    		} else {
    			processCurrentFrame();
    		}
    	}))();

    	const processCurrentFrame = () => __awaiter(void 0, void 0, void 0, function* () {
    		// console.log( {currentTime: domVideo.currentTime, endTime} )
    		if (endTime - domVideo.currentTime < 1 / FRAME_RATE) {
    			$$invalidate(4, progress = 1);
    			onFinish();
    			return;
    		}

    		capture.read(frame);
    		onCapture(frame, videoName);
    		seekFrames(1, FRAME_RATE);
    		$$invalidate(4, progress = (domVideo.currentTime - beginTime) / (endTime - beginTime));
    	});

    	const seekFrames = (nFrames, fps) => {
    		const currentFrame = domVideo.currentTime * fps;
    		const newPosition = 0.00001 + (currentFrame + nFrames) / fps;

    		// plus 0.00001 is workaround for safari
    		$$invalidate(3, domVideo.currentTime = Math.min(endTime, newPosition), domVideo);
    	};

    	const writable_props = [
    		"nSplits",
    		"index",
    		"videoName",
    		"videoData",
    		"isVideoVisible",
    		"onCapture",
    		"onFinish"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VideoReader> was created with unknown prop '${key}'`);
    	});

    	function video_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domVideo = $$value;
    			$$invalidate(3, domVideo);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("nSplits" in $$props) $$invalidate(5, nSplits = $$props.nSplits);
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("videoName" in $$props) $$invalidate(6, videoName = $$props.videoName);
    		if ("videoData" in $$props) $$invalidate(1, videoData = $$props.videoData);
    		if ("isVideoVisible" in $$props) $$invalidate(2, isVideoVisible = $$props.isVideoVisible);
    		if ("onCapture" in $$props) $$invalidate(7, onCapture = $$props.onCapture);
    		if ("onFinish" in $$props) $$invalidate(8, onFinish = $$props.onFinish);
    	};

    	$$self.$capture_state = () => ({
    		__awaiter,
    		cv: cv__default['default'],
    		FRAME_RATE,
    		videoWidth,
    		videoHeight,
    		nSplits,
    		index,
    		videoName,
    		videoData,
    		isVideoVisible,
    		onCapture,
    		onFinish,
    		beginTime,
    		endTime,
    		domVideo,
    		capture,
    		frame,
    		progress,
    		processCurrentFrame,
    		seekFrames
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("nSplits" in $$props) $$invalidate(5, nSplits = $$props.nSplits);
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("videoName" in $$props) $$invalidate(6, videoName = $$props.videoName);
    		if ("videoData" in $$props) $$invalidate(1, videoData = $$props.videoData);
    		if ("isVideoVisible" in $$props) $$invalidate(2, isVideoVisible = $$props.isVideoVisible);
    		if ("onCapture" in $$props) $$invalidate(7, onCapture = $$props.onCapture);
    		if ("onFinish" in $$props) $$invalidate(8, onFinish = $$props.onFinish);
    		if ("beginTime" in $$props) beginTime = $$props.beginTime;
    		if ("endTime" in $$props) endTime = $$props.endTime;
    		if ("domVideo" in $$props) $$invalidate(3, domVideo = $$props.domVideo);
    		if ("capture" in $$props) capture = $$props.capture;
    		if ("frame" in $$props) frame = $$props.frame;
    		if ("progress" in $$props) $$invalidate(4, progress = $$props.progress);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		index,
    		videoData,
    		isVideoVisible,
    		domVideo,
    		progress,
    		nSplits,
    		videoName,
    		onCapture,
    		onFinish,
    		video_binding
    	];
    }

    class VideoReader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			nSplits: 5,
    			index: 0,
    			videoName: 6,
    			videoData: 1,
    			isVideoVisible: 2,
    			onCapture: 7,
    			onFinish: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoReader",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*nSplits*/ ctx[5] === undefined && !("nSplits" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'nSplits'");
    		}

    		if (/*index*/ ctx[0] === undefined && !("index" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'index'");
    		}

    		if (/*videoName*/ ctx[6] === undefined && !("videoName" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'videoName'");
    		}

    		if (/*videoData*/ ctx[1] === undefined && !("videoData" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'videoData'");
    		}

    		if (/*onCapture*/ ctx[7] === undefined && !("onCapture" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'onCapture'");
    		}

    		if (/*onFinish*/ ctx[8] === undefined && !("onFinish" in props)) {
    			console.warn("<VideoReader> was created without expected prop 'onFinish'");
    		}
    	}

    	get nSplits() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nSplits(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get videoName() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set videoName(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get videoData() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set videoData(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVideoVisible() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVideoVisible(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onCapture() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onCapture(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onFinish() {
    		throw new Error("<VideoReader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onFinish(value) {
    		throw new Error("<VideoReader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/CharmScanner.svelte generated by Svelte v3.38.2 */

    const { console: console_1 } = globals;
    const file$3 = "src/pages/CharmScanner.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    // (113:6) {#each $videoReaderProps as props}
    function create_each_block$1(ctx) {
    	let videoreader;
    	let current;
    	const videoreader_spread_levels = [/*props*/ ctx[22]];
    	let videoreader_props = {};

    	for (let i = 0; i < videoreader_spread_levels.length; i += 1) {
    		videoreader_props = assign(videoreader_props, videoreader_spread_levels[i]);
    	}

    	videoreader = new VideoReader({ props: videoreader_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(videoreader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoreader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoreader_changes = (dirty & /*$videoReaderProps*/ 128)
    			? get_spread_update(videoreader_spread_levels, [get_spread_object(/*props*/ ctx[22])])
    			: {};

    			videoreader.$set(videoreader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoreader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoreader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoreader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(113:6) {#each $videoReaderProps as props}",
    		ctx
    	});

    	return block;
    }

    // (119:33) 
    function create_if_block_2(ctx) {
    	let t0;
    	let t1_value = 1 + Number(/*currentFileIndex*/ ctx[3]) + "";
    	let t1;
    	let t2;
    	let t3_value = /*files*/ ctx[1].length + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			t0 = text("Processing ");
    			t1 = text(t1_value);
    			t2 = text("/");
    			t3 = text(t3_value);
    			t4 = text(" file. Please wait...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentFileIndex*/ 8 && t1_value !== (t1_value = 1 + Number(/*currentFileIndex*/ ctx[3]) + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*files*/ 2 && t3_value !== (t3_value = /*files*/ ctx[1].length + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(119:33) ",
    		ctx
    	});

    	return block;
    }

    // (117:6) {#if isScanFinished}
    function create_if_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Completed!");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(117:6) {#if isScanFinished}",
    		ctx
    	});

    	return block;
    }

    // (144:6) {:else}
    function create_else_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Loading Files...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(144:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:6) {#if isAppReady}
    function create_if_block(ctx) {
    	let input;
    	let t0;
    	let img;
    	let img_src_value;
    	let t1;
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			img = element("img");
    			t1 = space();
    			div = element("div");
    			div.textContent = "Click to Select Movie";
    			set_style(input, "display", "none");
    			attr_dev(input, "type", "file");
    			attr_dev(input, "accept", ".mp4");
    			input.multiple = true;
    			attr_dev(input, "class", "svelte-18sy7xy");
    			add_location(input, file$3, 131, 8, 4729);
    			if (img.src !== (img_src_value = "https://static.thenounproject.com/png/625182-200.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-18sy7xy");
    			add_location(img, file$3, 138, 8, 4954);
    			attr_dev(div, "class", "svelte-18sy7xy");
    			add_location(div, file$3, 142, 8, 5111);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			/*input_binding*/ ctx[10](input);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, img, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*onFileSelected*/ ctx[8], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[9]),
    					listen_dev(img, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(div, "click", /*click_handler_1*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[10](null);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(131:6) {#if isAppReady}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let t0;
    	let t1;
    	let div2;
    	let div1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let textarea;
    	let t6;
    	let div3;
    	let current;
    	let each_value = /*$videoReaderProps*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	function select_block_type(ctx, dirty) {
    		if (/*isScanFinished*/ ctx[4]) return create_if_block_1;
    		if (/*files*/ ctx[1].length > 0) return create_if_block_2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type && current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (isAppReady) return create_if_block;
    		return create_else_block;
    	}

    	let current_block_type_1 = select_block_type_1();
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t2 = text("Found ");
    			t3 = text(/*nScanedCharms*/ ctx[5]);
    			t4 = text(" charms.");
    			t5 = space();
    			textarea = element("textarea");
    			t6 = space();
    			div3 = element("div");
    			if_block1.c();
    			attr_dev(div0, "id", "status");
    			attr_dev(div0, "class", "svelte-18sy7xy");
    			add_location(div0, file$3, 111, 4, 4221);
    			attr_dev(div1, "class", "svelte-18sy7xy");
    			add_location(div1, file$3, 125, 6, 4549);
    			attr_dev(textarea, "placeholder", "納刀術,2,ひるみ軽減,1,1,0,0");
    			textarea.value = /*exportData*/ ctx[6];
    			attr_dev(textarea, "class", "svelte-18sy7xy");
    			add_location(textarea, file$3, 126, 6, 4596);
    			attr_dev(div2, "id", "result");
    			attr_dev(div2, "class", "svelte-18sy7xy");
    			add_location(div2, file$3, 124, 4, 4525);
    			attr_dev(div3, "id", "upload");
    			attr_dev(div3, "class", "svelte-18sy7xy");
    			add_location(div3, file$3, 129, 4, 4680);
    			attr_dev(div4, "id", "scanner");
    			attr_dev(div4, "class", "svelte-18sy7xy");
    			add_location(div4, file$3, 110, 2, 4198);
    			attr_dev(div5, "class", "tab-content svelte-18sy7xy");
    			add_location(div5, file$3, 109, 0, 4170);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div0, t0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    			append_dev(div2, textarea);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			if_block1.m(div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$videoReaderProps*/ 128) {
    				each_value = /*$videoReaderProps*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, t0);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if (if_block0) if_block0.d(1);
    				if_block0 = current_block_type && current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			}

    			if (!current || dirty & /*nScanedCharms*/ 32) set_data_dev(t3, /*nScanedCharms*/ ctx[5]);

    			if (!current || dirty & /*exportData*/ 64) {
    				prop_dev(textarea, "value", /*exportData*/ ctx[6]);
    			}

    			if_block1.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);

    			if (if_block0) {
    				if_block0.d();
    			}

    			if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $videoReaderProps,
    		$$unsubscribe_videoReaderProps = noop,
    		$$subscribe_videoReaderProps = () => ($$unsubscribe_videoReaderProps(), $$unsubscribe_videoReaderProps = subscribe(videoReaderProps, $$value => $$invalidate(7, $videoReaderProps = $$value)), videoReaderProps);

    	let $charmManager;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(15, $charmManager = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_videoReaderProps());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CharmScanner", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	// const VIDEO_WIDTH      = 1280 // switch のキャプチャ解像度
    	// const VIDEO_HEIGHT     = 720
    	// const VIDEO_FRAME_RATE = 29.97
    	const N_VIDEO_SPLITS = (navigator.hardwareConcurrency || 8) / 2;

    	let charmScanner = new MHRiseCharmScanner({
    			scanMode: SCAN_MODE.MODE_EQUIP_LIST,
    			scanSkipMode: SCAN_SKIP_MODE.SKIP_SCANNED_CHARM
    		});

    	let domFileInput; // ファイルアップロード用 input 要素
    	let files = []; // 選択されたローカルファイル

    	// video reader
    	let videoReaderProps = writable([]);

    	validate_store(videoReaderProps, "videoReaderProps");
    	$$subscribe_videoReaderProps();
    	let countFinishVideoRead;
    	let isVideoReadFinished = false;

    	// progress
    	let currentFileIndex = -1;

    	let isScanFinished = false;

    	// result
    	let nScanedCharms = 0;

    	let exportData = "";

    	function initVideoReaders() {
    		$$subscribe_videoReaderProps($$invalidate(2, videoReaderProps = writable([])));
    		countFinishVideoRead = 0;
    		isVideoReadFinished = false;
    	}

    	function onFileSelected(e) {
    		return __awaiter(this, void 0, void 0, function* () {
    			if (e.target.files == null) {
    				return;
    			}

    			const filelist = e.target.files;
    			const files = [...filelist];
    			$$invalidate(4, isScanFinished = false);

    			// console.log(files)
    			for (let i = 0; i < files.length; i++) {
    				$$invalidate(3, currentFileIndex = i);
    				const file = files[i];
    				console.log(file.name, Date());
    				initVideoReaders();
    				const reader = new FileReader();
    				reader.readAsDataURL(file);

    				yield new Promise(resolve => {
    						reader.onload = resolve;
    					});

    				for (let i = 0; i < N_VIDEO_SPLITS; i++) {
    					const index = $videoReaderProps.length;

    					set_store_value(
    						videoReaderProps,
    						$videoReaderProps[index] = {
    							index,
    							videoName: file.name,
    							videoData: reader.result,
    							// charmScanner: charmScanner,
    							nSplits: N_VIDEO_SPLITS,
    							onCapture,
    							onFinish: onFinishVideoRead
    						},
    						$videoReaderProps
    					);
    				}

    				// console.log($videoReaderProps)
    				// wait for movie
    				yield new Promise(resolve => requestAnimationFrame(resolve));

    				// wait scanning
    				const updateResult = () => {
    					$$invalidate(5, nScanedCharms = charmScanner.countCharms());
    					$$invalidate(6, exportData = charmScanner.exportAsText());
    				};

    				while (!isVideoReadFinished) {
    					updateResult();
    					yield new Promise(r => setTimeout(r, 1000));
    				}

    				updateResult();
    				const charms = charmScanner.getCharms();
    				yield $charmManager.registerCharms(charms);
    			}

    			const charms = charmScanner.getCharms();
    			console.log(JSON.stringify(charms));
    			$$invalidate(4, isScanFinished = true);
    		});
    	}

    	function onCapture(frame, videoName) {
    		const result = charmScanner.scan(frame, videoName);

    		if (result == null) {
    			return;
    		}

    		const { charm, isCache } = result;

    		if (!isCache) {
    			// スクショ保存だけしておく. (護石データの DB 保存は動画単位で)
    			$charmManager.saveScreenshot(frame, charm.imageName);
    		}
    	}

    	function onFinishVideoRead() {
    		if (++countFinishVideoRead !== N_VIDEO_SPLITS) {
    			return;
    		}

    		isVideoReadFinished = true;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<CharmScanner> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		files = this.files;
    		$$invalidate(1, files);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			domFileInput = $$value;
    			$$invalidate(0, domFileInput);
    		});
    	}

    	const click_handler = () => domFileInput.click();
    	const click_handler_1 = () => domFileInput.click();

    	$$self.$capture_state = () => ({
    		__awaiter,
    		writable,
    		VideoReader,
    		MHRiseCharmScanner,
    		SCAN_MODE,
    		SCAN_SKIP_MODE,
    		charmManager,
    		isAppReady,
    		N_VIDEO_SPLITS,
    		charmScanner,
    		domFileInput,
    		files,
    		videoReaderProps,
    		countFinishVideoRead,
    		isVideoReadFinished,
    		currentFileIndex,
    		isScanFinished,
    		nScanedCharms,
    		exportData,
    		initVideoReaders,
    		onFileSelected,
    		onCapture,
    		onFinishVideoRead,
    		$videoReaderProps,
    		$charmManager
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("charmScanner" in $$props) charmScanner = $$props.charmScanner;
    		if ("domFileInput" in $$props) $$invalidate(0, domFileInput = $$props.domFileInput);
    		if ("files" in $$props) $$invalidate(1, files = $$props.files);
    		if ("videoReaderProps" in $$props) $$subscribe_videoReaderProps($$invalidate(2, videoReaderProps = $$props.videoReaderProps));
    		if ("countFinishVideoRead" in $$props) countFinishVideoRead = $$props.countFinishVideoRead;
    		if ("isVideoReadFinished" in $$props) isVideoReadFinished = $$props.isVideoReadFinished;
    		if ("currentFileIndex" in $$props) $$invalidate(3, currentFileIndex = $$props.currentFileIndex);
    		if ("isScanFinished" in $$props) $$invalidate(4, isScanFinished = $$props.isScanFinished);
    		if ("nScanedCharms" in $$props) $$invalidate(5, nScanedCharms = $$props.nScanedCharms);
    		if ("exportData" in $$props) $$invalidate(6, exportData = $$props.exportData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		domFileInput,
    		files,
    		videoReaderProps,
    		currentFileIndex,
    		isScanFinished,
    		nScanedCharms,
    		exportData,
    		$videoReaderProps,
    		onFileSelected,
    		input_change_handler,
    		input_binding,
    		click_handler,
    		click_handler_1
    	];
    }

    class CharmScanner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharmScanner",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/nav/NavOptions.svelte generated by Svelte v3.38.2 */

    const navOptions = [
    	{
    		tabTitle: "護石スキャン",
    		component: CharmScanner,
    		iconData: [
    			"M1.5 1a.5.5 0 0 0-.5.5v3a.5.5 0 0 1-1 0v-3A1.5 1.5 0 0 1 1.5 0h3a.5.5 0 0 1 0 1h-3zM11 .5a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 1 16 1.5v3a.5.5 0 0 1-1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 1-.5-.5zM.5 11a.5.5 0 0 1 .5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 1 0 1h-3A1.5 1.5 0 0 1 0 14.5v-3a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v3a1.5 1.5 0 0 1-1.5 1.5h-3a.5.5 0 0 1 0-1h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 1 .5-.5zM3 4.5a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-7zm3 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7z"
    		]
    	},
    	{
    		tabTitle: "護石リアルタイム\nスキャン(β)",
    		component: CharmRealtimeScanner,
    		iconData: [
    			"M1.5 1a.5.5 0 0 0-.5.5v3a.5.5 0 0 1-1 0v-3A1.5 1.5 0 0 1 1.5 0h3a.5.5 0 0 1 0 1h-3zM11 .5a.5.5 0 0 1 .5-.5h3A1.5 1.5 0 0 1 16 1.5v3a.5.5 0 0 1-1 0v-3a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 1-.5-.5zM.5 11a.5.5 0 0 1 .5.5v3a.5.5 0 0 0 .5.5h3a.5.5 0 0 1 0 1h-3A1.5 1.5 0 0 1 0 14.5v-3a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v3a1.5 1.5 0 0 1-1.5 1.5h-3a.5.5 0 0 1 0-1h3a.5.5 0 0 0 .5-.5v-3a.5.5 0 0 1 .5-.5zM3 4.5a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7zm2 0a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-7zm3 0a.5.5 0 0 1 1 0v7a.5.5 0 0 1-1 0v-7z"
    		]
    	},
    	{
    		tabTitle: "護石管理",
    		component: CharmList,
    		iconData: [
    			"M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2zm15 2h-4v3h4V4zm0 4h-4v3h4V8zm0 4h-4v3h3a1 1 0 0 0 1-1v-2zm-5 3v-3H6v3h4zm-5 0v-3H1v2a1 1 0 0 0 1 1h3zm-4-4h4V8H1v3zm0-4h4V4H1v3zm5-3v3h4V4H6zm4 4H6v3h4V8z"
    		]
    	},
    	{
    		tabTitle: "護石スペック検索",
    		component: CharmSearcher,
    		iconData: [
    			"M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"
    		]
    	},
    	{
    		tabTitle: "輪廻サポート(β)",
    		component: CharmRinneSupporter,
    		iconData: [
    			"M9.302 1.256a1.5 1.5 0 0 0-2.604 0l-1.704 2.98a.5.5 0 0 0 .869.497l1.703-2.981a.5.5 0 0 1 .868 0l2.54 4.444-1.256-.337a.5.5 0 1 0-.26.966l2.415.647a.5.5 0 0 0 .613-.353l.647-2.415a.5.5 0 1 0-.966-.259l-.333 1.242-2.532-4.431zM2.973 7.773l-1.255.337a.5.5 0 1 1-.26-.966l2.416-.647a.5.5 0 0 1 .612.353l.647 2.415a.5.5 0 0 1-.966.259l-.333-1.242-2.545 4.454a.5.5 0 0 0 .434.748H5a.5.5 0 0 1 0 1H1.723A1.5 1.5 0 0 1 .421 12.24l2.552-4.467zm10.89 1.463a.5.5 0 1 0-.868.496l1.716 3.004a.5.5 0 0 1-.434.748h-5.57l.647-.646a.5.5 0 1 0-.708-.707l-1.5 1.5a.498.498 0 0 0 0 .707l1.5 1.5a.5.5 0 1 0 .708-.707l-.647-.647h5.57a1.5 1.5 0 0 0 1.302-2.244l-1.716-3.004z"
    		]
    	},
    	{
    		tabTitle: "売却サポート(β)",
    		component: CharmDisposalSupporter,
    		iconData: [
    			"M5.5 9.511c.076.954.83 1.697 2.182 1.785V12h.6v-.709c1.4-.098 2.218-.846 2.218-1.932 0-.987-.626-1.496-1.745-1.76l-.473-.112V5.57c.6.068.982.396 1.074.85h1.052c-.076-.919-.864-1.638-2.126-1.716V4h-.6v.719c-1.195.117-2.01.836-2.01 1.853 0 .9.606 1.472 1.613 1.707l.397.098v2.034c-.615-.093-1.022-.43-1.114-.9H5.5zm2.177-2.166c-.59-.137-.91-.416-.91-.836 0-.47.345-.822.915-.925v1.76h-.005zm.692 1.193c.717.166 1.048.435 1.048.91 0 .542-.412.914-1.135.982V8.518l.087.02z",
    			"M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z",
    			"M8 13.5a5.5 5.5 0 1 1 0-11 5.5 5.5 0 0 1 0 11zm0 .5A6 6 0 1 0 8 2a6 6 0 0 0 0 12z"
    		]
    	},
    	{
    		tabTitle: "護石エクスポート",
    		component: CharmIxporter,
    		iconData: [
    			"M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5zm14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5z"
    		]
    	},
    	{
    		tabTitle: "ヘルプ",
    		component: Description,
    		iconData: [
    			"M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z",
    			"m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"
    		]
    	}
    ];

    /* src/components/nav/Nav.svelte generated by Svelte v3.38.2 */
    const file$2 = "src/components/nav/Nav.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[6] = list;
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (29:12) {#each (option.iconData || []) as iconData}
    function create_each_block_2(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", /*iconData*/ ctx[9]);
    			add_location(path, file$2, 29, 14, 1070);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(29:12) {#each (option.iconData || []) as iconData}",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#each navOptions as option, i}
    function create_each_block_1(ctx) {
    	let li;
    	let button;
    	let svg;
    	let t;
    	let span;
    	let raw_value = /*option*/ ctx[5].tabTitle.replace("\n", "<br>") + "";
    	let button_class_value;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*option*/ ctx[5].iconData || [];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			svg = svg_element("svg");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			span = element("span");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "16");
    			attr_dev(svg, "height", "19");
    			attr_dev(svg, "fill", "currentColor");
    			add_location(svg, file$2, 27, 10, 916);
    			set_style(span, "display", /*isNavigationOpen*/ ctx[0] ? "inline" : "none");
    			attr_dev(span, "class", "svelte-1u0ku30");
    			add_location(span, file$2, 32, 10, 1138);
    			attr_dev(button, "id", String(/*i*/ ctx[7]));

    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*currentNavOptionId*/ ctx[1] == /*i*/ ctx[7]
    			? "active navigation-link"
    			: "navigation-link") + " svelte-1u0ku30"));

    			attr_dev(button, "role", "tab");
    			add_location(button, file$2, 22, 8, 700);
    			attr_dev(li, "class", "navigation-item svelte-1u0ku30");
    			add_location(li, file$2, 21, 6, 663);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, svg);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			append_dev(button, t);
    			append_dev(button, span);
    			span.innerHTML = raw_value;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*switchComponent*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*navOptions*/ 0) {
    				each_value_2 = /*option*/ ctx[5].iconData || [];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(svg, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (dirty & /*isNavigationOpen*/ 1) {
    				set_style(span, "display", /*isNavigationOpen*/ ctx[0] ? "inline" : "none");
    			}

    			if (dirty & /*currentNavOptionId*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*currentNavOptionId*/ ctx[1] == /*i*/ ctx[7]
    			? "active navigation-link"
    			: "navigation-link") + " svelte-1u0ku30"))) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(21:4) {#each navOptions as option, i}",
    		ctx
    	});

    	return block;
    }

    // (53:4) {#each navOptions as option, i}
    function create_each_block(ctx) {
    	let div;
    	let switch_instance;
    	let updating_onActivate;
    	let t;
    	let div_class_value;
    	let current;

    	function switch_instance_onActivate_binding(value) {
    		/*switch_instance_onActivate_binding*/ ctx[4](value, /*i*/ ctx[7]);
    	}

    	var switch_value = /*option*/ ctx[5].component;

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		if (/*onActivate*/ ctx[2][/*i*/ ctx[7]] !== void 0) {
    			switch_instance_props.onActivate = /*onActivate*/ ctx[2][/*i*/ ctx[7]];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, "onActivate", switch_instance_onActivate_binding));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();

    			attr_dev(div, "class", div_class_value = "h-100 " + (/*currentNavOptionId*/ ctx[1] == /*i*/ ctx[7]
    			? "d-block"
    			: "d-none"));

    			add_location(div, file$2, 53, 6, 1845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};

    			if (!updating_onActivate && dirty & /*onActivate*/ 4) {
    				updating_onActivate = true;
    				switch_instance_changes.onActivate = /*onActivate*/ ctx[2][/*i*/ ctx[7]];
    				add_flush_callback(() => updating_onActivate = false);
    			}

    			if (switch_value !== (switch_value = /*option*/ ctx[5].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, "onActivate", switch_instance_onActivate_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (!current || dirty & /*currentNavOptionId*/ 2 && div_class_value !== (div_class_value = "h-100 " + (/*currentNavOptionId*/ ctx[1] == /*i*/ ctx[7]
    			? "d-block"
    			: "d-none"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(53:4) {#each navOptions as option, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div2;
    	let ul;
    	let t0;
    	let div0;
    	let a;
    	let t2;
    	let script;
    	let script_src_value;
    	let t3;
    	let div1;
    	let current;
    	let each_value_1 = navOptions;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	let each_value = navOptions;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t0 = space();
    			div0 = element("div");
    			a = element("a");
    			a.textContent = "Tweet";
    			t2 = space();
    			script = element("script");
    			t3 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(a, "href", "https://twitter.com/share?ref_src=twsrc%5Etfw");
    			attr_dev(a, "class", "twitter-share-button");
    			attr_dev(a, "data-text", "");
    			attr_dev(a, "data-url", "https://mhrise-charm-scanner.yuzu-k.com");
    			attr_dev(a, "data-hashtags", "MHRise,護石,ツール");
    			attr_dev(a, "data-show-count", "false");
    			add_location(a, file$2, 39, 6, 1382);
    			script.async = true;
    			if (script.src !== (script_src_value = "https://platform.twitter.com/widgets.js")) attr_dev(script, "src", script_src_value);
    			attr_dev(script, "charset", "utf-8");
    			add_location(script, file$2, 47, 6, 1662);
    			set_style(div0, "position", "fixed");
    			set_style(div0, "bottom", "0");
    			set_style(div0, "left", "5px");
    			add_location(div0, file$2, 38, 4, 1323);
    			attr_dev(ul, "class", "navigation svelte-1u0ku30");
    			set_style(ul, "width", /*isNavigationOpen*/ ctx[0] ? "14rem" : "3.2rem");
    			add_location(ul, file$2, 19, 2, 542);
    			attr_dev(div1, "class", "navigation-content svelte-1u0ku30");
    			add_location(div1, file$2, 51, 2, 1770);
    			attr_dev(div2, "id", "container");
    			attr_dev(div2, "class", "svelte-1u0ku30");
    			add_location(div2, file$2, 18, 0, 519);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, ul);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul, null);
    			}

    			append_dev(ul, t0);
    			append_dev(ul, div0);
    			append_dev(div0, a);
    			append_dev(div0, t2);
    			append_dev(div0, script);
    			append_dev(div2, t3);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*String, currentNavOptionId, switchComponent, isNavigationOpen, navOptions*/ 11) {
    				each_value_1 = navOptions;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(ul, t0);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (!current || dirty & /*isNavigationOpen*/ 1) {
    				set_style(ul, "width", /*isNavigationOpen*/ ctx[0] ? "14rem" : "3.2rem");
    			}

    			if (dirty & /*currentNavOptionId, navOptions, onActivate*/ 6) {
    				each_value = navOptions;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Nav", slots, []);
    	let { isNavigationOpen } = $$props;
    	let currentNavOptionId = 7;
    	let onActivate = {};

    	function switchComponent(e) {
    		var _a;

    		const selectedComponentId = (_a = e.target.closest("button")) === null || _a === void 0
    		? void 0
    		: _a.id;

    		if (selectedComponentId == null) {
    			return;
    		}

    		$$invalidate(1, currentNavOptionId = parseInt(selectedComponentId));

    		if (onActivate[currentNavOptionId]) {
    			onActivate[currentNavOptionId]();
    		}
    	}

    	const writable_props = ["isNavigationOpen"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Nav> was created with unknown prop '${key}'`);
    	});

    	function switch_instance_onActivate_binding(value, i) {
    		if ($$self.$$.not_equal(onActivate[i], value)) {
    			onActivate[i] = value;
    			$$invalidate(2, onActivate);
    		}
    	}

    	$$self.$$set = $$props => {
    		if ("isNavigationOpen" in $$props) $$invalidate(0, isNavigationOpen = $$props.isNavigationOpen);
    	};

    	$$self.$capture_state = () => ({
    		navOptions,
    		isNavigationOpen,
    		currentNavOptionId,
    		onActivate,
    		switchComponent
    	});

    	$$self.$inject_state = $$props => {
    		if ("isNavigationOpen" in $$props) $$invalidate(0, isNavigationOpen = $$props.isNavigationOpen);
    		if ("currentNavOptionId" in $$props) $$invalidate(1, currentNavOptionId = $$props.currentNavOptionId);
    		if ("onActivate" in $$props) $$invalidate(2, onActivate = $$props.onActivate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isNavigationOpen,
    		currentNavOptionId,
    		onActivate,
    		switchComponent,
    		switch_instance_onActivate_binding
    	];
    }

    class Nav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { isNavigationOpen: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isNavigationOpen*/ ctx[0] === undefined && !("isNavigationOpen" in props)) {
    			console.warn("<Nav> was created without expected prop 'isNavigationOpen'");
    		}
    	}

    	get isNavigationOpen() {
    		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isNavigationOpen(value) {
    		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/parts/Hamburger.svelte generated by Svelte v3.38.2 */

    const file$1 = "src/components/parts/Hamburger.svelte";

    function create_fragment$1(ctx) {
    	let div;
    	let label;
    	let input;
    	let t;
    	let svg;
    	let circle;
    	let path0;
    	let path1;
    	let path2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			input = element("input");
    			t = space();
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-vpaeku");
    			add_location(input, file$1, 6, 4, 102);
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "30");
    			attr_dev(circle, "class", "svelte-vpaeku");
    			add_location(circle, file$1, 8, 6, 221);
    			attr_dev(path0, "class", "line--1 svelte-vpaeku");
    			attr_dev(path0, "d", "M0 55l14-10c4.7-3.3 9-5 13-5h72");
    			add_location(path0, file$1, 9, 6, 261);
    			attr_dev(path1, "class", "line--2 svelte-vpaeku");
    			attr_dev(path1, "d", "M0 50h99");
    			add_location(path1, file$1, 10, 6, 328);
    			attr_dev(path2, "class", "line--3 svelte-vpaeku");
    			attr_dev(path2, "d", "M0 45l14 10c4.7 3.3 9 5 13 5h72");
    			add_location(path2, file$1, 11, 6, 372);
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$1, 7, 4, 152);
    			attr_dev(label, "class", "svelte-vpaeku");
    			add_location(label, file$1, 5, 2, 90);
    			attr_dev(div, "class", "menu toggle-back svelte-vpaeku");
    			add_location(div, file$1, 4, 0, 57);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(label, input);
    			input.checked = /*isOpen*/ ctx[0];
    			append_dev(label, t);
    			append_dev(label, svg);
    			append_dev(svg, circle);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[1]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isOpen*/ 1) {
    				input.checked = /*isOpen*/ ctx[0];
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Hamburger", slots, []);
    	let { isOpen = false } = $$props;
    	const writable_props = ["isOpen"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Hamburger> was created with unknown prop '${key}'`);
    	});

    	function input_change_handler() {
    		isOpen = this.checked;
    		$$invalidate(0, isOpen);
    	}

    	$$self.$$set = $$props => {
    		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	$$self.$capture_state = () => ({ isOpen });

    	$$self.$inject_state = $$props => {
    		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, input_change_handler];
    }

    class Hamburger extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { isOpen: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hamburger",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get isOpen() {
    		throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
     ** LICENSE for the sqlite3 WebAssembly/JavaScript APIs.
     **
     ** This bundle (typically released as sqlite3.js or sqlite3.mjs)
     ** is an amalgamation of JavaScript source code from two projects:
     **
     ** 1) https://emscripten.org: the Emscripten "glue code" is covered by
     **    the terms of the MIT license and University of Illinois/NCSA
     **    Open Source License, as described at:
     **
     **    https://emscripten.org/docs/introducing_emscripten/emscripten_license.html
     **
     ** 2) https://sqlite.org: all code and documentation labeled as being
     **    from this source are released under the same terms as the sqlite3
     **    C library:
     **
     ** 2022-10-16
     **
     ** The author disclaims copyright to this source code.  In place of a
     ** legal notice, here is a blessing:
     **
     ** *   May you do good and not evil.
     ** *   May you find forgiveness for yourself and forgive others.
     ** *   May you share freely, never taking more than you give.
     */
    /*
     ** This code was built from sqlite3 version...
     **
     ** SQLITE_VERSION "3.45.2"
     ** SQLITE_VERSION_NUMBER 3045002
     ** SQLITE_SOURCE_ID "2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77"
     **
     ** Using the Emscripten SDK version 3.1.30.
     */

    var sqlite3InitModule = (() => {
      var _scriptDir = (document.currentScript && document.currentScript.src || new URL('bundle.js', document.baseURI).href);

      return function (config) {
        var sqlite3InitModule = config || {};

        var Module =
          typeof sqlite3InitModule != 'undefined' ? sqlite3InitModule : {};

        var readyPromiseResolve, readyPromiseReject;
        Module['ready'] = new Promise(function (resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });

        const sqlite3InitModuleState =
          globalThis.sqlite3InitModuleState ||
          Object.assign(Object.create(null), {
            debugModule: () => {},
          });
        delete globalThis.sqlite3InitModuleState;
        sqlite3InitModuleState.debugModule(
          'globalThis.location =',
          globalThis.location,
        );

        const xNameOfInstantiateWasm = 'emscripten-bug-17951';
        Module[xNameOfInstantiateWasm] = function callee(imports, onSuccess) {
          imports.env.foo = function () {};
          const uri = Module.locateFile(
            callee.uri,
            'undefined' === typeof scriptDirectory ? '' : scriptDirectory,
          );
          sqlite3InitModuleState.debugModule('instantiateWasm() uri =', uri);
          const wfetch = () => fetch(uri, { credentials: 'same-origin' });
          const loadWasm = WebAssembly.instantiateStreaming
            ? async () => {
                return WebAssembly.instantiateStreaming(wfetch(), imports).then(
                  (arg) => onSuccess(arg.instance, arg.module),
                );
              }
            : async () => {
                return wfetch()
                  .then((response) => response.arrayBuffer())
                  .then((bytes) => WebAssembly.instantiate(bytes, imports))
                  .then((arg) => onSuccess(arg.instance, arg.module));
              };
          loadWasm();
          return {};
        };

        Module[xNameOfInstantiateWasm].uri = 'sqlite3.wasm';

        var moduleOverrides = Object.assign({}, Module);
        var thisProgram = './this.program';

        var ENVIRONMENT_IS_WEB = typeof window == 'object';
        var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';

        typeof process == 'object' &&
          typeof process.versions == 'object' &&
          typeof process.versions.node == 'string';

        var scriptDirectory = '';
        function locateFile(path) {
          if (Module['locateFile']) {
            return Module['locateFile'](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }

        var read_, readAsync, readBinary;

        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != 'undefined' && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }

          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }

          if (scriptDirectory.indexOf('blob:') !== 0) {
            scriptDirectory = scriptDirectory.substr(
              0,
              scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1,
            );
          } else {
            scriptDirectory = '';
          }

          {
            read_ = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              xhr.send(null);
              return xhr.responseText;
            };

            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                xhr.responseType = 'arraybuffer';
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }

            readAsync = (url, onload, onerror) => {
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, true);
              xhr.responseType = 'arraybuffer';
              xhr.onload = () => {
                if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        }

        var out = Module['print'] || console.log.bind(console);
        var err = Module['printErr'] || console.warn.bind(console);

        Object.assign(Module, moduleOverrides);

        moduleOverrides = null;

        if (Module['arguments']) ;

        if (Module['thisProgram']) thisProgram = Module['thisProgram'];

        if (Module['quit']) ;

        var wasmBinary;
        if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
        Module['noExitRuntime'] || true;

        if (typeof WebAssembly != 'object') {
          abort('no native wasm support detected');
        }

        var wasmMemory;

        var ABORT = false;

        function assert(condition, text) {
          if (!condition) {
            abort(text);
          }
        }

        var UTF8Decoder =
          typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

        function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;

          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = '';

          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 0x80)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 0xe0) == 0xc0) {
              str += String.fromCharCode(((u0 & 31) << 6) | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 0xf0) == 0xe0) {
              u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
            } else {
              u0 =
                ((u0 & 7) << 18) |
                (u1 << 12) |
                (u2 << 6) |
                (heapOrArray[idx++] & 63);
            }

            if (u0 < 0x10000) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 0x10000;
              str += String.fromCharCode(
                0xd800 | (ch >> 10),
                0xdc00 | (ch & 0x3ff),
              );
            }
          }
          return str;
        }

        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
        }

        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0)) return 0;

          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 0xd800 && u <= 0xdfff) {
              var u1 = str.charCodeAt(++i);
              u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);
            }
            if (u <= 0x7f) {
              if (outIdx >= endIdx) break;
              heap[outIdx++] = u;
            } else if (u <= 0x7ff) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++] = 0xc0 | (u >> 6);
              heap[outIdx++] = 0x80 | (u & 63);
            } else if (u <= 0xffff) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++] = 0xe0 | (u >> 12);
              heap[outIdx++] = 0x80 | ((u >> 6) & 63);
              heap[outIdx++] = 0x80 | (u & 63);
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++] = 0xf0 | (u >> 18);
              heap[outIdx++] = 0x80 | ((u >> 12) & 63);
              heap[outIdx++] = 0x80 | ((u >> 6) & 63);
              heap[outIdx++] = 0x80 | (u & 63);
            }
          }

          heap[outIdx] = 0;
          return outIdx - startIdx;
        }

        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }

        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var c = str.charCodeAt(i);
            if (c <= 0x7f) {
              len++;
            } else if (c <= 0x7ff) {
              len += 2;
            } else if (c >= 0xd800 && c <= 0xdfff) {
              len += 4;
              ++i;
            } else {
              len += 3;
            }
          }
          return len;
        }

        var HEAP8,
          HEAPU8,
          HEAP16,
          HEAP32,
          HEAPU32;

        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module['HEAP8'] = HEAP8 = new Int8Array(b);
          Module['HEAP16'] = HEAP16 = new Int16Array(b);
          Module['HEAP32'] = HEAP32 = new Int32Array(b);
          Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
          Module['HEAPU16'] = new Uint16Array(b);
          Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
          Module['HEAPF32'] = new Float32Array(b);
          Module['HEAPF64'] = new Float64Array(b);
          Module['HEAP64'] = new BigInt64Array(b);
          Module['HEAPU64'] = new BigUint64Array(b);
        }

        var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

        if (Module['wasmMemory']) {
          wasmMemory = Module['wasmMemory'];
        } else {
          wasmMemory = new WebAssembly.Memory({
            initial: INITIAL_MEMORY / 65536,

            maximum: 2147483648 / 65536,
          });
        }

        updateMemoryViews();

        INITIAL_MEMORY = wasmMemory.buffer.byteLength;

        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATPOSTRUN__ = [];

        function preRun() {
          if (Module['preRun']) {
            if (typeof Module['preRun'] == 'function')
              Module['preRun'] = [Module['preRun']];
            while (Module['preRun'].length) {
              addOnPreRun(Module['preRun'].shift());
            }
          }

          callRuntimeCallbacks(__ATPRERUN__);
        }

        function initRuntime() {

          if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
          FS.ignorePermissions = false;
          callRuntimeCallbacks(__ATINIT__);
        }

        function postRun() {
          if (Module['postRun']) {
            if (typeof Module['postRun'] == 'function')
              Module['postRun'] = [Module['postRun']];
            while (Module['postRun'].length) {
              addOnPostRun(Module['postRun'].shift());
            }
          }

          callRuntimeCallbacks(__ATPOSTRUN__);
        }

        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }

        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }

        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }

        var runDependencies = 0;
        var dependenciesFulfilled = null;

        function getUniqueRunDependency(id) {
          return id;
        }

        function addRunDependency(id) {
          runDependencies++;

          if (Module['monitorRunDependencies']) {
            Module['monitorRunDependencies'](runDependencies);
          }
        }

        function removeRunDependency(id) {
          runDependencies--;

          if (Module['monitorRunDependencies']) {
            Module['monitorRunDependencies'](runDependencies);
          }

          if (runDependencies == 0) {
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }

        function abort(what) {
          if (Module['onAbort']) {
            Module['onAbort'](what);
          }

          what = 'Aborted(' + what + ')';

          err(what);

          ABORT = true;

          what += '. Build with -sASSERTIONS for more info.';

          var e = new WebAssembly.RuntimeError(what);

          readyPromiseReject(e);

          throw e;
        }

        var dataURIPrefix = 'data:application/octet-stream;base64,';

        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }

        var wasmBinaryFile;
        if (Module['locateFile']) {
          wasmBinaryFile = 'sqlite3.wasm';
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
        } else {
          wasmBinaryFile = new URL('sqlite3.wasm', (document.currentScript && document.currentScript.src || new URL('bundle.js', document.baseURI).href)).href;
        }

        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            }
            throw 'both async and sync fetching of the wasm failed';
          } catch (err) {
            abort(err);
          }
        }

        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch == 'function') {
              return fetch(wasmBinaryFile, { credentials: 'same-origin' })
                .then(function (response) {
                  if (!response['ok']) {
                    throw (
                      "failed to load wasm binary file at '" + wasmBinaryFile + "'"
                    );
                  }
                  return response['arrayBuffer']();
                })
                .catch(function () {
                  return getBinary(wasmBinaryFile);
                });
            }
          }

          return Promise.resolve().then(function () {
            return getBinary(wasmBinaryFile);
          });
        }

        function createWasm() {
          var info = {
            env: asmLibraryArg,
            wasi_snapshot_preview1: asmLibraryArg,
          };

          function receiveInstance(instance, module) {
            var exports = instance.exports;

            Module['asm'] = exports;

            Module['asm']['__indirect_function_table'];

            addOnInit(Module['asm']['__wasm_call_ctors']);

            removeRunDependency();
          }

          addRunDependency();

          function receiveInstantiationResult(result) {
            receiveInstance(result['instance']);
          }

          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise()
              .then(function (binary) {
                return WebAssembly.instantiate(binary, info);
              })
              .then(function (instance) {
                return instance;
              })
              .then(receiver, function (reason) {
                err('failed to asynchronously prepare wasm: ' + reason);

                abort(reason);
              });
          }

          function instantiateAsync() {
            if (
              !wasmBinary &&
              typeof WebAssembly.instantiateStreaming == 'function' &&
              !isDataURI(wasmBinaryFile) &&
              typeof fetch == 'function'
            ) {
              return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(
                function (response) {
                  var result = WebAssembly.instantiateStreaming(response, info);

                  return result.then(receiveInstantiationResult, function (reason) {
                    err('wasm streaming compile failed: ' + reason);
                    err('falling back to ArrayBuffer instantiation');
                    return instantiateArrayBuffer(receiveInstantiationResult);
                  });
                },
              );
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }

          if (Module['instantiateWasm']) {
            try {
              var exports = Module['instantiateWasm'](info, receiveInstance);
              return exports;
            } catch (e) {
              err('Module.instantiateWasm callback failed with error: ' + e);

              readyPromiseReject(e);
            }
          }

          instantiateAsync().catch(readyPromiseReject);
          return {};
        }

        var tempDouble;
        var tempI64;

        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            callbacks.shift()(Module);
          }
        }

        var PATH = {
          isAbs: (path) => path.charAt(0) === '/',
          splitPath: (filename) => {
            var splitPathRe =
              /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          },
          normalizeArray: (parts, allowAboveRoot) => {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === '.') {
                parts.splice(i, 1);
              } else if (last === '..') {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }

            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift('..');
              }
            }
            return parts;
          },
          normalize: (path) => {
            var isAbsolute = PATH.isAbs(path),
              trailingSlash = path.substr(-1) === '/';

            path = PATH.normalizeArray(
              path.split('/').filter((p) => !!p),
              !isAbsolute,
            ).join('/');
            if (!path && !isAbsolute) {
              path = '.';
            }
            if (path && trailingSlash) {
              path += '/';
            }
            return (isAbsolute ? '/' : '') + path;
          },
          dirname: (path) => {
            var result = PATH.splitPath(path),
              root = result[0],
              dir = result[1];
            if (!root && !dir) {
              return '.';
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          },
          basename: (path) => {
            if (path === '/') return '/';
            path = PATH.normalize(path);
            path = path.replace(/\/$/, '');
            var lastSlash = path.lastIndexOf('/');
            if (lastSlash === -1) return path;
            return path.substr(lastSlash + 1);
          },
          join: function () {
            var paths = Array.prototype.slice.call(arguments);
            return PATH.normalize(paths.join('/'));
          },
          join2: (l, r) => {
            return PATH.normalize(l + '/' + r);
          },
        };

        function getRandomDevice() {
          if (
            typeof crypto == 'object' &&
            typeof crypto['getRandomValues'] == 'function'
          ) {
            var randomBuffer = new Uint8Array(1);
            return () => {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else return () => abort('randomDevice');
        }

        var PATH_FS = {
          resolve: function () {
            var resolvedPath = '',
              resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();

              if (typeof path != 'string') {
                throw new TypeError('Arguments to path.resolve must be strings');
              } else if (!path) {
                return '';
              }
              resolvedPath = path + '/' + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path);
            }

            resolvedPath = PATH.normalizeArray(
              resolvedPath.split('/').filter((p) => !!p),
              !resolvedAbsolute,
            ).join('/');
            return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
          },
          relative: (from, to) => {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== '') break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== '') break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split('/'));
            var toParts = trim(to.split('/'));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push('..');
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join('/');
          },
        };

        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(
            stringy,
            u8array,
            0,
            u8array.length,
          );
          if (dontAddNull) u8array.length = numBytesWritten;
          return u8array;
        }
        var TTY = {
          ttys: [],
          init: function () {},
          shutdown: function () {},
          register: function (dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops: ops };
            FS.registerDevice(dev, TTY.stream_ops);
          },
          stream_ops: {
            open: function (stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            },
            close: function (stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            fsync: function (stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            read: function (stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = stream.tty.ops.get_char(stream.tty);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === undefined && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === undefined) break;
                bytesRead++;
                buffer[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            },
            write: function (stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i = 0; i < length; i++) {
                  stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                }
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            },
          },
          default_tty_ops: {
            get_char: function (tty) {
              if (!tty.input.length) {
                var result = null;
                if (
                  typeof window != 'undefined' &&
                  typeof window.prompt == 'function'
                ) {
                  result = window.prompt('Input: ');
                  if (result !== null) {
                    result += '\n';
                  }
                } else if (typeof readline == 'function') {
                  result = readline();
                  if (result !== null) {
                    result += '\n';
                  }
                }
                if (!result) {
                  return null;
                }
                tty.input = intArrayFromString(result, true);
              }
              return tty.input.shift();
            },
            put_char: function (tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            },
            fsync: function (tty) {
              if (tty.output && tty.output.length > 0) {
                out(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            },
          },
          default_tty1_ops: {
            put_char: function (tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              } else {
                if (val != 0) tty.output.push(val);
              }
            },
            fsync: function (tty) {
              if (tty.output && tty.output.length > 0) {
                err(UTF8ArrayToString(tty.output, 0));
                tty.output = [];
              }
            },
          },
        };

        function zeroMemory(address, size) {
          HEAPU8.fill(0, address, address + size);
          return address;
        }

        function alignMemory(size, alignment) {
          return Math.ceil(size / alignment) * alignment;
        }
        function mmapAlloc(size) {
          size = alignMemory(size, 65536);
          var ptr = _emscripten_builtin_memalign(65536, size);
          if (!ptr) return 0;
          return zeroMemory(ptr, size);
        }
        var MEMFS = {
          ops_table: null,
          mount: function (mount) {
            return MEMFS.createNode(null, '/', 16384 | 511, 0);
          },
          createNode: function (parent, name, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = {
                dir: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    lookup: MEMFS.node_ops.lookup,
                    mknod: MEMFS.node_ops.mknod,
                    rename: MEMFS.node_ops.rename,
                    unlink: MEMFS.node_ops.unlink,
                    rmdir: MEMFS.node_ops.rmdir,
                    readdir: MEMFS.node_ops.readdir,
                    symlink: MEMFS.node_ops.symlink,
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek,
                  },
                },
                file: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                  },
                  stream: {
                    llseek: MEMFS.stream_ops.llseek,
                    read: MEMFS.stream_ops.read,
                    write: MEMFS.stream_ops.write,
                    allocate: MEMFS.stream_ops.allocate,
                    mmap: MEMFS.stream_ops.mmap,
                    msync: MEMFS.stream_ops.msync,
                  },
                },
                link: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                    readlink: MEMFS.node_ops.readlink,
                  },
                  stream: {},
                },
                chrdev: {
                  node: {
                    getattr: MEMFS.node_ops.getattr,
                    setattr: MEMFS.node_ops.setattr,
                  },
                  stream: FS.chrdev_stream_ops,
                },
              };
            }
            var node = FS.createNode(parent, name, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;

              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();

            if (parent) {
              parent.contents[name] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          },
          getFileDataAsTypedArray: function (node) {
            if (!node.contents) return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          },
          expandFileStorage: function (node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;

            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(
              newCapacity,
              (prevCapacity *
                (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>>
                0,
            );
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          },
          resizeFileStorage: function (node, newSize) {
            if (node.usedBytes == newSize) return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(
                  oldContents.subarray(0, Math.min(newSize, node.usedBytes)),
                );
              }
              node.usedBytes = newSize;
            }
          },
          node_ops: {
            getattr: function (node) {
              var attr = {};

              attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr.ino = node.id;
              attr.mode = node.mode;
              attr.nlink = 1;
              attr.uid = 0;
              attr.gid = 0;
              attr.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length;
              } else {
                attr.size = 0;
              }
              attr.atime = new Date(node.timestamp);
              attr.mtime = new Date(node.timestamp);
              attr.ctime = new Date(node.timestamp);

              attr.blksize = 4096;
              attr.blocks = Math.ceil(attr.size / attr.blksize);
              return attr;
            },
            setattr: function (node, attr) {
              if (attr.mode !== undefined) {
                node.mode = attr.mode;
              }
              if (attr.timestamp !== undefined) {
                node.timestamp = attr.timestamp;
              }
              if (attr.size !== undefined) {
                MEMFS.resizeFileStorage(node, attr.size);
              }
            },
            lookup: function (parent, name) {
              throw FS.genericErrors[44];
            },
            mknod: function (parent, name, mode, dev) {
              return MEMFS.createNode(parent, name, mode, dev);
            },
            rename: function (old_node, new_dir, new_name) {
              if (FS.isDir(old_node.mode)) {
                var new_node;
                try {
                  new_node = FS.lookupNode(new_dir, new_name);
                } catch (e) {}
                if (new_node) {
                  for (var i in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
              }

              delete old_node.parent.contents[old_node.name];
              old_node.parent.timestamp = Date.now();
              old_node.name = new_name;
              new_dir.contents[new_name] = old_node;
              new_dir.timestamp = old_node.parent.timestamp;
              old_node.parent = new_dir;
            },
            unlink: function (parent, name) {
              delete parent.contents[name];
              parent.timestamp = Date.now();
            },
            rmdir: function (parent, name) {
              var node = FS.lookupNode(parent, name);
              for (var i in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name];
              parent.timestamp = Date.now();
            },
            readdir: function (node) {
              var entries = ['.', '..'];
              for (var key in node.contents) {
                if (!node.contents.hasOwnProperty(key)) {
                  continue;
                }
                entries.push(key);
              }
              return entries;
            },
            symlink: function (parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            },
            readlink: function (node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            },
          },
          stream_ops: {
            read: function (stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes) return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i = 0; i < size; i++)
                  buffer[offset + i] = contents[position + i];
              }
              return size;
            },
            write: function (stream, buffer, offset, length, position, canOwn) {
              if (buffer.buffer === HEAP8.buffer) {
                canOwn = false;
              }

              if (!length) return 0;
              var node = stream.node;
              node.timestamp = Date.now();

              if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  node.contents = buffer.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(
                    buffer.subarray(offset, offset + length),
                    position,
                  );
                  return length;
                }
              }

              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer.subarray) {
                node.contents.set(
                  buffer.subarray(offset, offset + length),
                  position,
                );
              } else {
                for (var i = 0; i < length; i++) {
                  node.contents[position + i] = buffer[offset + i];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            },
            llseek: function (stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            },
            allocate: function (stream, offset, length) {
              MEMFS.expandFileStorage(stream.node, offset + length);
              stream.node.usedBytes = Math.max(
                stream.node.usedBytes,
                offset + length,
              );
            },
            mmap: function (stream, length, position, prot, flags) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr;
              var allocated;
              var contents = stream.node.contents;

              if (!(flags & 2) && contents.buffer === HEAP8.buffer) {
                allocated = false;
                ptr = contents.byteOffset;
              } else {
                if (position > 0 || position + length < contents.length) {
                  if (contents.subarray) {
                    contents = contents.subarray(position, position + length);
                  } else {
                    contents = Array.prototype.slice.call(
                      contents,
                      position,
                      position + length,
                    );
                  }
                }
                allocated = true;
                ptr = mmapAlloc(length);
                if (!ptr) {
                  throw new FS.ErrnoError(48);
                }
                HEAP8.set(contents, ptr);
              }
              return { ptr: ptr, allocated: allocated };
            },
            msync: function (stream, buffer, offset, length, mmapFlags) {
              MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);

              return 0;
            },
          },
        };

        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
          readAsync(
            url,
            (arrayBuffer) => {
              assert(
                arrayBuffer,
                'Loading data file "' + url + '" failed (no arrayBuffer).',
              );
              onload(new Uint8Array(arrayBuffer));
              if (dep) removeRunDependency();
            },
            (event) => {
              if (onerror) {
                onerror();
              } else {
                throw 'Loading data file "' + url + '" failed.';
              }
            },
          );
          if (dep) addRunDependency();
        }

        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: '/',
          initialized: false,
          ignorePermissions: true,
          ErrnoError: null,
          genericErrors: {},
          filesystems: null,
          syncFSRequests: 0,
          lookupPath: (path, opts = {}) => {
            path = PATH_FS.resolve(path);

            if (!path) return { path: '', node: null };

            var defaults = {
              follow_mount: true,
              recurse_count: 0,
            };
            opts = Object.assign(defaults, opts);

            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }

            var parts = path.split('/').filter((p) => !!p);

            var current = FS.root;
            var current_path = '/';

            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }

              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);

              if (FS.isMountpoint(current)) {
                if (!islast || (islast && opts.follow_mount)) {
                  current = current.mounted.root;
                }
              }

              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);

                  var lookup = FS.lookupPath(current_path, {
                    recurse_count: opts.recurse_count + 1,
                  });
                  current = lookup.node;

                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }

            return { path: current_path, node: current };
          },
          getPath: (node) => {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path) return mount;
                return mount[mount.length - 1] !== '/'
                  ? mount + '/' + path
                  : mount + path;
              }
              path = path ? node.name + '/' + path : node.name;
              node = node.parent;
            }
          },
          hashName: (parentid, name) => {
            var hash = 0;

            for (var i = 0; i < name.length; i++) {
              hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
            }
            return ((parentid + hash) >>> 0) % FS.nameTable.length;
          },
          hashAddNode: (node) => {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          },
          hashRemoveNode: (node) => {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          },
          lookupNode: (parent, name) => {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name) {
                return node;
              }
            }

            return FS.lookup(parent, name);
          },
          createNode: (parent, name, mode, rdev) => {
            var node = new FS.FSNode(parent, name, mode, rdev);

            FS.hashAddNode(node);

            return node;
          },
          destroyNode: (node) => {
            FS.hashRemoveNode(node);
          },
          isRoot: (node) => {
            return node === node.parent;
          },
          isMountpoint: (node) => {
            return !!node.mounted;
          },
          isFile: (mode) => {
            return (mode & 61440) === 32768;
          },
          isDir: (mode) => {
            return (mode & 61440) === 16384;
          },
          isLink: (mode) => {
            return (mode & 61440) === 40960;
          },
          isChrdev: (mode) => {
            return (mode & 61440) === 8192;
          },
          isBlkdev: (mode) => {
            return (mode & 61440) === 24576;
          },
          isFIFO: (mode) => {
            return (mode & 61440) === 4096;
          },
          isSocket: (mode) => {
            return (mode & 49152) === 49152;
          },
          flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 },
          modeStringToFlags: (str) => {
            var flags = FS.flagModes[str];
            if (typeof flags == 'undefined') {
              throw new Error('Unknown file open mode: ' + str);
            }
            return flags;
          },
          flagsToPermissionString: (flag) => {
            var perms = ['r', 'w', 'rw'][flag & 3];
            if (flag & 512) {
              perms += 'w';
            }
            return perms;
          },
          nodePermissions: (node, perms) => {
            if (FS.ignorePermissions) {
              return 0;
            }

            if (perms.includes('r') && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes('w') && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes('x') && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          },
          mayLookup: (dir) => {
            var errCode = FS.nodePermissions(dir, 'x');
            if (errCode) return errCode;
            if (!dir.node_ops.lookup) return 2;
            return 0;
          },
          mayCreate: (dir, name) => {
            try {
              var node = FS.lookupNode(dir, name);
              return 20;
            } catch (e) {}
            return FS.nodePermissions(dir, 'wx');
          },
          mayDelete: (dir, name, isdir) => {
            var node;
            try {
              node = FS.lookupNode(dir, name);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, 'wx');
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          },
          mayOpen: (node, flags) => {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          },
          MAX_OPEN_FDS: 4096,
          nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          },
          getStream: (fd) => FS.streams[fd],
          createStream: (stream, fd_start, fd_end) => {
            if (!FS.FSStream) {
              FS.FSStream = function () {
                this.shared = {};
              };
              FS.FSStream.prototype = {};
              Object.defineProperties(FS.FSStream.prototype, {
                object: {
                  get: function () {
                    return this.node;
                  },

                  set: function (val) {
                    this.node = val;
                  },
                },
                isRead: {
                  get: function () {
                    return (this.flags & 2097155) !== 1;
                  },
                },
                isWrite: {
                  get: function () {
                    return (this.flags & 2097155) !== 0;
                  },
                },
                isAppend: {
                  get: function () {
                    return this.flags & 1024;
                  },
                },
                flags: {
                  get: function () {
                    return this.shared.flags;
                  },

                  set: function (val) {
                    this.shared.flags = val;
                  },
                },
                position: {
                  get: function () {
                    return this.shared.position;
                  },

                  set: function (val) {
                    this.shared.position = val;
                  },
                },
              });
            }

            stream = Object.assign(new FS.FSStream(), stream);
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          },
          closeStream: (fd) => {
            FS.streams[fd] = null;
          },
          chrdev_stream_ops: {
            open: (stream) => {
              var device = FS.getDevice(stream.node.rdev);

              stream.stream_ops = device.stream_ops;

              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
              }
            },
            llseek: () => {
              throw new FS.ErrnoError(70);
            },
          },
          major: (dev) => dev >> 8,
          minor: (dev) => dev & 0xff,
          makedev: (ma, mi) => (ma << 8) | mi,
          registerDevice: (dev, ops) => {
            FS.devices[dev] = { stream_ops: ops };
          },
          getDevice: (dev) => FS.devices[dev],
          getMounts: (mount) => {
            var mounts = [];
            var check = [mount];

            while (check.length) {
              var m = check.pop();

              mounts.push(m);

              check.push.apply(check, m.mounts);
            }

            return mounts;
          },
          syncfs: (populate, callback) => {
            if (typeof populate == 'function') {
              callback = populate;
              populate = false;
            }

            FS.syncFSRequests++;

            if (FS.syncFSRequests > 1) {
              err(
                'warning: ' +
                  FS.syncFSRequests +
                  ' FS.syncfs operations in flight at once, probably just doing extra work',
              );
            }

            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;

            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }

            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }

            mounts.forEach((mount) => {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          },
          mount: (type, opts, mountpoint) => {
            var root = mountpoint === '/';
            var pseudo = !mountpoint;
            var node;

            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

              mountpoint = lookup.path;
              node = lookup.node;

              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }

              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }

            var mount = {
              type: type,
              opts: opts,
              mountpoint: mountpoint,
              mounts: [],
            };

            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;

            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;

              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }

            return mountRoot;
          },
          unmount: (mountpoint) => {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }

            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);

            Object.keys(FS.nameTable).forEach((hash) => {
              var current = FS.nameTable[hash];

              while (current) {
                var next = current.name_next;

                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }

                current = next;
              }
            });

            node.mounted = null;

            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          },
          lookup: (parent, name) => {
            return parent.node_ops.lookup(parent, name);
          },
          mknod: (path, mode, dev) => {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            if (!name || name === '.' || name === '..') {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name, mode, dev);
          },
          create: (path, mode) => {
            mode = mode !== undefined ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          },
          mkdir: (path, mode) => {
            mode = mode !== undefined ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          },
          mkdirTree: (path, mode) => {
            var dirs = path.split('/');
            var d = '';
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i]) continue;
              d += '/' + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20) throw e;
              }
            }
          },
          mkdev: (path, mode, dev) => {
            if (typeof dev == 'undefined') {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          },
          symlink: (oldpath, newpath) => {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          },
          rename: (old_path, new_path) => {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);

            var lookup, old_dir, new_dir;

            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;

            if (!old_dir || !new_dir) throw new FS.ErrnoError(44);

            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }

            var old_node = FS.lookupNode(old_dir, old_name);

            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== '.') {
              throw new FS.ErrnoError(28);
            }

            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== '.') {
              throw new FS.ErrnoError(55);
            }

            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {}

            if (old_node === new_node) {
              return;
            }

            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }

            errCode = new_node
              ? FS.mayDelete(new_dir, new_name, isdir)
              : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (
              FS.isMountpoint(old_node) ||
              (new_node && FS.isMountpoint(new_node))
            ) {
              throw new FS.ErrnoError(10);
            }

            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, 'w');
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }

            FS.hashRemoveNode(old_node);

            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
          },
          rmdir: (path) => {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name);
            FS.destroyNode(node);
          },
          readdir: (path) => {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          },
          unlink: (path) => {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name = PATH.basename(path);
            var node = FS.lookupNode(parent, name);
            var errCode = FS.mayDelete(parent, name, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name);
            FS.destroyNode(node);
          },
          readlink: (path) => {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(
              FS.getPath(link.parent),
              link.node_ops.readlink(link),
            );
          },
          stat: (path, dontFollow) => {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          },
          lstat: (path) => {
            return FS.stat(path, true);
          },
          chmod: (path, mode, dontFollow) => {
            var node;
            if (typeof path == 'string') {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              mode: (mode & 4095) | (node.mode & ~4095),
              timestamp: Date.now(),
            });
          },
          lchmod: (path, mode) => {
            FS.chmod(path, mode, true);
          },
          fchmod: (fd, mode) => {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          },
          chown: (path, uid, gid, dontFollow) => {
            var node;
            if (typeof path == 'string') {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, {
              timestamp: Date.now(),
            });
          },
          lchown: (path, uid, gid) => {
            FS.chown(path, uid, gid, true);
          },
          fchown: (fd, uid, gid) => {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          },
          truncate: (path, len) => {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path == 'string') {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, 'w');
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, {
              size: len,
              timestamp: Date.now(),
            });
          },
          ftruncate: (fd, len) => {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          },
          utime: (path, atime, mtime) => {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, {
              timestamp: Math.max(atime, mtime),
            });
          },
          open: (path, flags, mode) => {
            if (path === '') {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode == 'undefined' ? 438 : mode;
            if (flags & 64) {
              mode = (mode & 4095) | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path == 'object') {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, {
                  follow: !(flags & 131072),
                });
                node = lookup.node;
              } catch (e) {}
            }

            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }

            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }

            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }

            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }

            if (flags & 512 && !created) {
              FS.truncate(node, 0);
            }

            flags &= ~(128 | 512 | 131072);

            var stream = FS.createStream({
              node: node,
              path: FS.getPath(node),
              flags: flags,
              seekable: true,
              position: 0,
              stream_ops: node.stream_ops,

              ungotten: [],
              error: false,
            });

            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module['logReadFiles'] && !(flags & 1)) {
              if (!FS.readFiles) FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
              }
            }
            return stream;
          },
          close: (stream) => {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents) stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          },
          isClosed: (stream) => {
            return stream.fd === null;
          },
          llseek: (stream, offset, whence) => {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          },
          read: (stream, buffer, offset, length, position) => {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != 'undefined';
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(
              stream,
              buffer,
              offset,
              length,
              position,
            );
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          },
          write: (stream, buffer, offset, length, position, canOwn) => {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != 'undefined';
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(
              stream,
              buffer,
              offset,
              length,
              position,
              canOwn,
            );
            if (!seeking) stream.position += bytesWritten;
            return bytesWritten;
          },
          allocate: (stream, offset, length) => {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          },
          mmap: (stream, length, position, prot, flags) => {
            if (
              (prot & 2) !== 0 &&
              (flags & 2) === 0 &&
              (stream.flags & 2097155) !== 2
            ) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags);
          },
          msync: (stream, buffer, offset, length, mmapFlags) => {
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(
              stream,
              buffer,
              offset,
              length,
              mmapFlags,
            );
          },
          munmap: (stream) => 0,
          ioctl: (stream, cmd, arg) => {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          },
          readFile: (path, opts = {}) => {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || 'binary';
            if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === 'utf8') {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === 'binary') {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          },
          writeFile: (path, data, opts = {}) => {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data == 'string') {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
            } else {
              throw new Error('Unsupported data type');
            }
            FS.close(stream);
          },
          cwd: () => FS.currentPath,
          chdir: (path) => {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, 'x');
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          },
          createDefaultDirectories: () => {
            FS.mkdir('/tmp');
            FS.mkdir('/home');
            FS.mkdir('/home/web_user');
          },
          createDefaultDevices: () => {
            FS.mkdir('/dev');

            FS.registerDevice(FS.makedev(1, 3), {
              read: () => 0,
              write: (stream, buffer, offset, length, pos) => length,
            });
            FS.mkdev('/dev/null', FS.makedev(1, 3));

            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev('/dev/tty', FS.makedev(5, 0));
            FS.mkdev('/dev/tty1', FS.makedev(6, 0));

            var random_device = getRandomDevice();
            FS.createDevice('/dev', 'random', random_device);
            FS.createDevice('/dev', 'urandom', random_device);

            FS.mkdir('/dev/shm');
            FS.mkdir('/dev/shm/tmp');
          },
          createSpecialDirectories: () => {
            FS.mkdir('/proc');
            var proc_self = FS.mkdir('/proc/self');
            FS.mkdir('/proc/self/fd');
            FS.mount(
              {
                mount: () => {
                  var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);
                  node.node_ops = {
                    lookup: (parent, name) => {
                      var fd = +name;
                      var stream = FS.getStream(fd);
                      if (!stream) throw new FS.ErrnoError(8);
                      var ret = {
                        parent: null,
                        mount: { mountpoint: 'fake' },
                        node_ops: { readlink: () => stream.path },
                      };
                      ret.parent = ret;
                      return ret;
                    },
                  };
                  return node;
                },
              },
              {},
              '/proc/self/fd',
            );
          },
          createStandardStreams: () => {
            if (Module['stdin']) {
              FS.createDevice('/dev', 'stdin', Module['stdin']);
            } else {
              FS.symlink('/dev/tty', '/dev/stdin');
            }
            if (Module['stdout']) {
              FS.createDevice('/dev', 'stdout', null, Module['stdout']);
            } else {
              FS.symlink('/dev/tty', '/dev/stdout');
            }
            if (Module['stderr']) {
              FS.createDevice('/dev', 'stderr', null, Module['stderr']);
            } else {
              FS.symlink('/dev/tty1', '/dev/stderr');
            }

            FS.open('/dev/stdin', 0);
            FS.open('/dev/stdout', 1);
            FS.open('/dev/stderr', 1);
          },
          ensureErrnoError: () => {
            if (FS.ErrnoError) return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function (errno) {
                this.errno = errno;
              };
              this.setErrno(errno);
              this.message = 'FS error';
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;

            [44].forEach((code) => {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = '<generic error, no stack>';
            });
          },
          staticInit: () => {
            FS.ensureErrnoError();

            FS.nameTable = new Array(4096);

            FS.mount(MEMFS, {}, '/');

            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();

            FS.filesystems = {
              MEMFS: MEMFS,
            };
          },
          init: (input, output, error) => {
            FS.init.initialized = true;

            FS.ensureErrnoError();

            Module['stdin'] = input || Module['stdin'];
            Module['stdout'] = output || Module['stdout'];
            Module['stderr'] = error || Module['stderr'];

            FS.createStandardStreams();
          },
          quit: () => {
            FS.init.initialized = false;

            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          },
          getMode: (canRead, canWrite) => {
            var mode = 0;
            if (canRead) mode |= 292 | 73;
            if (canWrite) mode |= 146;
            return mode;
          },
          findObject: (path, dontResolveLastLink) => {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          },
          analyzePath: (path, dontResolveLastLink) => {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {}
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null,
            };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === '/';
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          },
          createPath: (parent, path, canRead, canWrite) => {
            parent = typeof parent == 'string' ? parent : FS.getPath(parent);
            var parts = path.split('/').reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part) continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {}
              parent = current;
            }
            return current;
          },
          createFile: (parent, name, properties, canRead, canWrite) => {
            var path = PATH.join2(
              typeof parent == 'string' ? parent : FS.getPath(parent),
              name,
            );
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          },
          createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
            var path = name;
            if (parent) {
              parent = typeof parent == 'string' ? parent : FS.getPath(parent);
              path = name ? PATH.join2(parent, name) : parent;
            }
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data == 'string') {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }

              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          },
          createDevice: (parent, name, input, output) => {
            var path = PATH.join2(
              typeof parent == 'string' ? parent : FS.getPath(parent),
              name,
            );
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major) FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);

            FS.registerDevice(dev, {
              open: (stream) => {
                stream.seekable = false;
              },
              close: (stream) => {
                if (output && output.buffer && output.buffer.length) {
                  output(10);
                }
              },
              read: (stream, buffer, offset, length, pos) => {
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result;
                  try {
                    result = input();
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === undefined && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === undefined) break;
                  bytesRead++;
                  buffer[offset + i] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write: (stream, buffer, offset, length, pos) => {
                for (var i = 0; i < length; i++) {
                  try {
                    output(buffer[offset + i]);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i;
              },
            });
            return FS.mkdev(path, mode, dev);
          },
          forceLoadFile: (obj) => {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest != 'undefined') {
              throw new Error(
                'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.',
              );
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error('Cannot load without read() or XMLHttpRequest.');
            }
          },
          createLazyFile: (parent, name, url, canRead, canWrite) => {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return undefined;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = (idx / this.chunkSize) | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter =
              function LazyUint8Array_setDataGetter(getter) {
                this.getter = getter;
              };
            LazyUint8Array.prototype.cacheLength =
              function LazyUint8Array_cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open('HEAD', url, false);
                xhr.send(null);
                if (
                  !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
                )
                  throw new Error(
                    "Couldn't load " + url + '. Status: ' + xhr.status,
                  );
                var datalength = Number(xhr.getResponseHeader('Content-length'));
                var header;
                var hasByteServing =
                  (header = xhr.getResponseHeader('Accept-Ranges')) &&
                  header === 'bytes';
                var usesGzip =
                  (header = xhr.getResponseHeader('Content-Encoding')) &&
                  header === 'gzip';

                var chunkSize = 1024 * 1024;

                if (!hasByteServing) chunkSize = datalength;

                var doXHR = (from, to) => {
                  if (from > to)
                    throw new Error(
                      'invalid range (' +
                        from +
                        ', ' +
                        to +
                        ') or no bytes requested!',
                    );
                  if (to > datalength - 1)
                    throw new Error(
                      'only ' + datalength + ' bytes available! programmer error!',
                    );

                  var xhr = new XMLHttpRequest();
                  xhr.open('GET', url, false);
                  if (datalength !== chunkSize)
                    xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);

                  xhr.responseType = 'arraybuffer';
                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType('text/plain; charset=x-user-defined');
                  }

                  xhr.send(null);
                  if (
                    !((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304)
                  )
                    throw new Error(
                      "Couldn't load " + url + '. Status: ' + xhr.status,
                    );
                  if (xhr.response !== undefined) {
                    return new Uint8Array(xhr.response || []);
                  }
                  return intArrayFromString(xhr.responseText || '', true);
                };
                var lazyArray = this;
                lazyArray.setDataGetter((chunkNum) => {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                    lazyArray.chunks[chunkNum] = doXHR(start, end);
                  }
                  if (typeof lazyArray.chunks[chunkNum] == 'undefined')
                    throw new Error('doXHR failed!');
                  return lazyArray.chunks[chunkNum];
                });

                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out(
                    'LazyFiles on gzip forces download of the whole file when length is accessed',
                  );
                }

                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              };
            if (typeof XMLHttpRequest != 'undefined') {
              if (!ENVIRONMENT_IS_WORKER)
                throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, {
                length: {
                  get: function () {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._length;
                  },
                },
                chunkSize: {
                  get: function () {
                    if (!this.lengthKnown) {
                      this.cacheLength();
                    }
                    return this._chunkSize;
                  },
                },
              });

              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url: url };
            }

            var node = FS.createFile(parent, name, properties, canRead, canWrite);

            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }

            Object.defineProperties(node, {
              usedBytes: {
                get: function () {
                  return this.contents.length;
                },
              },
            });

            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key) => {
              var fn = node.stream_ops[key];
              stream_ops[key] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length) return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents.get(position + i);
                }
              }
              return size;
            }

            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };

            stream_ops.mmap = (stream, length, position, prot, flags) => {
              FS.forceLoadFile(node);
              var ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr, length, position);
              return { ptr: ptr, allocated: true };
            };
            node.stream_ops = stream_ops;
            return node;
          },
          createPreloadedFile: (
            parent,
            name,
            url,
            canRead,
            canWrite,
            onload,
            onerror,
            dontCreateFile,
            canOwn,
            preFinish,
          ) => {
            var fullname = name
              ? PATH_FS.resolve(PATH.join2(parent, name))
              : parent;
            function processData(byteArray) {
              function finish(byteArray) {
                if (preFinish) preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(
                    parent,
                    name,
                    byteArray,
                    canRead,
                    canWrite,
                    canOwn,
                  );
                }
                if (onload) onload();
                removeRunDependency();
              }
              if (
                Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
                  if (onerror) onerror();
                  removeRunDependency();
                })
              ) {
                return;
              }
              finish(byteArray);
            }
            addRunDependency();
            if (typeof url == 'string') {
              asyncLoad(url, (byteArray) => processData(byteArray), onerror);
            } else {
              processData(url);
            }
          },
          indexedDB: () => {
            return (
              window.indexedDB ||
              window.mozIndexedDB ||
              window.webkitIndexedDB ||
              window.msIndexedDB
            );
          },
          DB_NAME: () => {
            return 'EM_FS_' + window.location.pathname;
          },
          DB_VERSION: 20,
          DB_STORE_NAME: 'FILE_DATA',
          saveFilesToDB: (paths, onload, onerror) => {
            onload = onload || (() => {});
            onerror = onerror || (() => {});
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = () => {
              out('creating db');
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = () => {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0,
                fail = 0,
                total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              paths.forEach((path) => {
                var putRequest = files.put(
                  FS.analyzePath(path).object.contents,
                  path,
                );
                putRequest.onsuccess = () => {
                  ok++;
                  if (ok + fail == total) finish();
                };
                putRequest.onerror = () => {
                  fail++;
                  if (ok + fail == total) finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          },
          loadFilesFromDB: (paths, onload, onerror) => {
            onload = onload || (() => {});
            onerror = onerror || (() => {});
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = () => {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0,
                fail = 0,
                total = paths.length;
              function finish() {
                if (fail == 0) onload();
                else onerror();
              }
              paths.forEach((path) => {
                var getRequest = files.get(path);
                getRequest.onsuccess = () => {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(
                    PATH.dirname(path),
                    PATH.basename(path),
                    getRequest.result,
                    true,
                    true,
                    true,
                  );
                  ok++;
                  if (ok + fail == total) finish();
                };
                getRequest.onerror = () => {
                  fail++;
                  if (ok + fail == total) finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          },
        };
        var SYSCALLS = {
          DEFAULT_POLLMASK: 5,
          calculateAt: function (dirfd, path, allowEmpty) {
            if (PATH.isAbs(path)) {
              return path;
            }

            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path);
          },
          doStat: function (func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (
                e &&
                e.node &&
                PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))
              ) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[(buf + 8) >> 2] = stat.ino;
            HEAP32[(buf + 12) >> 2] = stat.mode;
            HEAPU32[(buf + 16) >> 2] = stat.nlink;
            HEAP32[(buf + 20) >> 2] = stat.uid;
            HEAP32[(buf + 24) >> 2] = stat.gid;
            HEAP32[(buf + 28) >> 2] = stat.rdev;
            (tempI64 = [
              stat.size >>> 0,
              ((tempDouble = stat.size),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[(buf + 40) >> 2] = tempI64[0]),
              (HEAP32[(buf + 44) >> 2] = tempI64[1]);
            HEAP32[(buf + 48) >> 2] = 4096;
            HEAP32[(buf + 52) >> 2] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            (tempI64 = [
              Math.floor(atime / 1000) >>> 0,
              ((tempDouble = Math.floor(atime / 1000)),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[(buf + 56) >> 2] = tempI64[0]),
              (HEAP32[(buf + 60) >> 2] = tempI64[1]);
            HEAPU32[(buf + 64) >> 2] = (atime % 1000) * 1000;
            (tempI64 = [
              Math.floor(mtime / 1000) >>> 0,
              ((tempDouble = Math.floor(mtime / 1000)),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[(buf + 72) >> 2] = tempI64[0]),
              (HEAP32[(buf + 76) >> 2] = tempI64[1]);
            HEAPU32[(buf + 80) >> 2] = (mtime % 1000) * 1000;
            (tempI64 = [
              Math.floor(ctime / 1000) >>> 0,
              ((tempDouble = Math.floor(ctime / 1000)),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[(buf + 88) >> 2] = tempI64[0]),
              (HEAP32[(buf + 92) >> 2] = tempI64[1]);
            HEAPU32[(buf + 96) >> 2] = (ctime % 1000) * 1000;
            (tempI64 = [
              stat.ino >>> 0,
              ((tempDouble = stat.ino),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[(buf + 104) >> 2] = tempI64[0]),
              (HEAP32[(buf + 108) >> 2] = tempI64[1]);
            return 0;
          },
          doMsync: function (addr, stream, len, flags, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer, offset, len, flags);
          },
          varargs: undefined,
          get: function () {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
            return ret;
          },
          getStr: function (ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          },
          getStreamFromFD: function (fd) {
            var stream = FS.getStream(fd);
            if (!stream) throw new FS.ErrnoError(8);
            return stream;
          },
        };
        function ___syscall_chmod(path, mode) {
          try {
            path = SYSCALLS.getStr(path);
            FS.chmod(path, mode);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_faccessat(dirfd, path, amode, flags) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (amode & ~7) {
              return -28;
            }
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = '';
            if (amode & 4) perms += 'r';
            if (amode & 2) perms += 'w';
            if (amode & 1) perms += 'x';
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_fchmod(fd, mode) {
          try {
            FS.fchmod(fd, mode);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_fchown32(fd, owner, group) {
          try {
            FS.fchown(fd, owner, group);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function setErrNo(value) {
          HEAP32[___errno_location() >> 2] = value;
          return value;
        }

        function ___syscall_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.createStream(stream, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 5: {
                var arg = SYSCALLS.get();
                var offset = 0;

                HEAP16[(arg + offset) >> 1] = 2;
                return 0;
              }
              case 6:
              case 7:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_fstat64(fd, buf) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            return SYSCALLS.doStat(FS.stat, stream.path, buf);
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        var MAX_INT53 = 9007199254740992;

        var MIN_INT53 = -9007199254740992;
        function bigintToI53Checked(num) {
          return num < MIN_INT53 || num > MAX_INT53 ? NaN : Number(num);
        }

        function ___syscall_ftruncate64(fd, length) {
          try {
            length = bigintToI53Checked(length);
            if (isNaN(length)) return -61;
            FS.ftruncate(fd, length);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_getcwd(buf, size) {
          try {
            if (size === 0) return -28;
            var cwd = FS.cwd();
            var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
            if (size < cwdLengthInBytes) return -68;
            stringToUTF8(cwd, buf, size);
            return cwdLengthInBytes;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty) return -59;
                var argp = SYSCALLS.get();
                HEAP32[argp >> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty) return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty) return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty) return -59;
                return 0;
              }
              default:
                return -28;
            }
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_lstat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.lstat, path, buf);
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_mkdirat(dirfd, path, mode) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);

            path = PATH.normalize(path);
            if (path[path.length - 1] === '/')
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_newfstatat(dirfd, path, buf, flags) {
          try {
            path = SYSCALLS.getStr(path);
            var nofollow = flags & 256;
            var allowEmpty = flags & 4096;
            flags = flags & ~6400;
            path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
            return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_openat(dirfd, path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            var mode = varargs ? SYSCALLS.get() : 0;
            return FS.open(path, flags, mode).fd;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (bufsize <= 0) return -28;
            var ret = FS.readlink(path);

            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len];
            stringToUTF8(ret, buf, bufsize + 1);

            HEAP8[buf + len] = endChar;
            return len;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_rmdir(path) {
          try {
            path = SYSCALLS.getStr(path);
            FS.rmdir(path);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_stat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.doStat(FS.stat, path, buf);
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function ___syscall_unlinkat(dirfd, path, flags) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            if (flags === 0) {
              FS.unlink(path);
            } else if (flags === 512) {
              FS.rmdir(path);
            } else {
              abort('Invalid flags passed to unlinkat');
            }
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function readI53FromI64(ptr) {
          return HEAPU32[ptr >> 2] + HEAP32[(ptr + 4) >> 2] * 4294967296;
        }

        function ___syscall_utimensat(dirfd, path, times, flags) {
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path, true);
            if (!times) {
              var atime = Date.now();
              var mtime = atime;
            } else {
              var seconds = readI53FromI64(times);
              var nanoseconds = HEAP32[(times + 8) >> 2];
              atime = seconds * 1000 + nanoseconds / (1000 * 1000);
              times += 16;
              seconds = readI53FromI64(times);
              nanoseconds = HEAP32[(times + 8) >> 2];
              mtime = seconds * 1000 + nanoseconds / (1000 * 1000);
            }
            FS.utime(path, atime, mtime);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        var nowIsMonotonic = true;
        function __emscripten_get_now_is_monotonic() {
          return nowIsMonotonic;
        }

        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }

        var __MONTH_DAYS_LEAP_CUMULATIVE = [
          0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335,
        ];

        var __MONTH_DAYS_REGULAR_CUMULATIVE = [
          0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
        ];
        function __yday_from_date(date) {
          var isLeapYear = __isLeapYear(date.getFullYear());
          var monthDaysCumulative = isLeapYear
            ? __MONTH_DAYS_LEAP_CUMULATIVE
            : __MONTH_DAYS_REGULAR_CUMULATIVE;
          var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;

          return yday;
        }
        function __localtime_js(time, tmPtr) {
          var date = new Date(readI53FromI64(time) * 1000);
          HEAP32[tmPtr >> 2] = date.getSeconds();
          HEAP32[(tmPtr + 4) >> 2] = date.getMinutes();
          HEAP32[(tmPtr + 8) >> 2] = date.getHours();
          HEAP32[(tmPtr + 12) >> 2] = date.getDate();
          HEAP32[(tmPtr + 16) >> 2] = date.getMonth();
          HEAP32[(tmPtr + 20) >> 2] = date.getFullYear() - 1900;
          HEAP32[(tmPtr + 24) >> 2] = date.getDay();

          var yday = __yday_from_date(date) | 0;
          HEAP32[(tmPtr + 28) >> 2] = yday;
          HEAP32[(tmPtr + 36) >> 2] = -(date.getTimezoneOffset() * 60);

          var start = new Date(date.getFullYear(), 0, 1);
          var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
          var winterOffset = start.getTimezoneOffset();
          var dst =
            (summerOffset != winterOffset &&
              date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
          HEAP32[(tmPtr + 32) >> 2] = dst;
        }

        function __mmap_js(len, prot, flags, fd, off, allocated, addr) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var res = FS.mmap(stream, len, off, prot, flags);
            var ptr = res.ptr;
            HEAP32[allocated >> 2] = res.allocated;
            HEAPU32[addr >> 2] = ptr;
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function __munmap_js(addr, len, prot, flags, fd, offset) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (prot & 2) {
              SYSCALLS.doMsync(addr, stream, len, flags, offset);
            }
            FS.munmap(stream);
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return -e.errno;
          }
        }

        function allocateUTF8(str) {
          var size = lengthBytesUTF8(str) + 1;
          var ret = _malloc(size);
          if (ret) stringToUTF8Array(str, HEAP8, ret, size);
          return ret;
        }
        function __tzset_js(timezone, daylight, tzname) {
          var currentYear = new Date().getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();

          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);

          HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;

          HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);

          function extractZone(date) {
            var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
            return match ? match[1] : 'GMT';
          }
          var winterName = extractZone(winter);
          var summerName = extractZone(summer);
          var winterNamePtr = allocateUTF8(winterName);
          var summerNamePtr = allocateUTF8(summerName);
          if (summerOffset < winterOffset) {
            HEAPU32[tzname >> 2] = winterNamePtr;
            HEAPU32[(tzname + 4) >> 2] = summerNamePtr;
          } else {
            HEAPU32[tzname >> 2] = summerNamePtr;
            HEAPU32[(tzname + 4) >> 2] = winterNamePtr;
          }
        }

        function _emscripten_date_now() {
          return Date.now();
        }

        var _emscripten_get_now;
        _emscripten_get_now = () => performance.now();
        function getHeapMax() {
          return 2147483648;
        }

        function emscripten_realloc_buffer(size) {
          var b = wasmMemory.buffer;
          try {
            wasmMemory.grow((size - b.byteLength + 65535) >>> 16);
            updateMemoryViews();
            return 1;
          } catch (e) {}
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;

          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }

          let alignUp = (x, multiple) =>
            x + ((multiple - (x % multiple)) % multiple);

          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);

            overGrownHeapSize = Math.min(
              overGrownHeapSize,
              requestedSize + 100663296,
            );

            var newSize = Math.min(
              maxHeapSize,
              alignUp(Math.max(requestedSize, overGrownHeapSize), 65536),
            );

            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }

        var ENV = {};

        function getExecutableName() {
          return thisProgram || './this.program';
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang =
              (
                (typeof navigator == 'object' &&
                  navigator.languages &&
                  navigator.languages[0]) ||
                'C'
              ).replace('-', '_') + '.UTF-8';
            var env = {
              USER: 'web_user',
              LOGNAME: 'web_user',
              PATH: '/',
              PWD: '/',
              HOME: '/home/web_user',
              LANG: lang,
              _: getExecutableName(),
            };

            for (var x in ENV) {
              if (ENV[x] === undefined) delete env[x];
              else env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + '=' + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }

        function writeAsciiToMemory(str, buffer, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer++ >> 0] = str.charCodeAt(i);
          }

          if (!dontAddNull) HEAP8[buffer >> 0] = 0;
        }

        function _environ_get(__environ, environ_buf) {
          var bufSize = 0;
          getEnvStrings().forEach(function (string, i) {
            var ptr = environ_buf + bufSize;
            HEAPU32[(__environ + i * 4) >> 2] = ptr;
            writeAsciiToMemory(string, ptr);
            bufSize += string.length + 1;
          });
          return 0;
        }

        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          var strings = getEnvStrings();
          HEAPU32[penviron_count >> 2] = strings.length;
          var bufSize = 0;
          strings.forEach(function (string) {
            bufSize += string.length + 1;
          });
          HEAPU32[penviron_buf_size >> 2] = bufSize;
          return 0;
        }

        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        function _fd_fdstat_get(fd, pbuf) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);

            var type = stream.tty
              ? 2
              : FS.isDir(stream.mode)
                ? 3
                : FS.isLink(stream.mode)
                  ? 7
                  : 4;
            HEAP8[pbuf >> 0] = type;

            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        function doReadv(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[(iov + 4) >> 2];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (curr < len) break;
            if (typeof offset !== 'undefined') {
              offset += curr;
            }
          }
          return ret;
        }

        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        function _fd_seek(fd, offset, whence, newOffset) {
          try {
            offset = bigintToI53Checked(offset);
            if (isNaN(offset)) return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            (tempI64 = [
              stream.position >>> 0,
              ((tempDouble = stream.position),
              +Math.abs(tempDouble) >= 1.0
                ? tempDouble > 0.0
                  ? (Math.min(
                      +Math.floor(tempDouble / 4294967296.0),
                      4294967295.0,
                    ) |
                      0) >>>
                    0
                  : ~~+Math.ceil(
                      (tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0,
                    ) >>> 0
                : 0),
            ]),
              (HEAP32[newOffset >> 2] = tempI64[0]),
              (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        function _fd_sync(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            if (stream.stream_ops && stream.stream_ops.fsync) {
              return stream.stream_ops.fsync(stream);
            }
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        function doWritev(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[(iov + 4) >> 2];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0) return -1;
            ret += curr;
            if (typeof offset !== 'undefined') {
              offset += curr;
            }
          }
          return ret;
        }

        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
            return e.errno;
          }
        }

        var FSNode = function (parent, name, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, {
          read: {
            get: function () {
              return (this.mode & readMode) === readMode;
            },
            set: function (val) {
              val ? (this.mode |= readMode) : (this.mode &= ~readMode);
            },
          },
          write: {
            get: function () {
              return (this.mode & writeMode) === writeMode;
            },
            set: function (val) {
              val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
            },
          },
          isFolder: {
            get: function () {
              return FS.isDir(this.mode);
            },
          },
          isDevice: {
            get: function () {
              return FS.isChrdev(this.mode);
            },
          },
        });
        FS.FSNode = FSNode;
        FS.staticInit();

        var asmLibraryArg = {
          __syscall_chmod: ___syscall_chmod,
          __syscall_faccessat: ___syscall_faccessat,
          __syscall_fchmod: ___syscall_fchmod,
          __syscall_fchown32: ___syscall_fchown32,
          __syscall_fcntl64: ___syscall_fcntl64,
          __syscall_fstat64: ___syscall_fstat64,
          __syscall_ftruncate64: ___syscall_ftruncate64,
          __syscall_getcwd: ___syscall_getcwd,
          __syscall_ioctl: ___syscall_ioctl,
          __syscall_lstat64: ___syscall_lstat64,
          __syscall_mkdirat: ___syscall_mkdirat,
          __syscall_newfstatat: ___syscall_newfstatat,
          __syscall_openat: ___syscall_openat,
          __syscall_readlinkat: ___syscall_readlinkat,
          __syscall_rmdir: ___syscall_rmdir,
          __syscall_stat64: ___syscall_stat64,
          __syscall_unlinkat: ___syscall_unlinkat,
          __syscall_utimensat: ___syscall_utimensat,
          _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
          _localtime_js: __localtime_js,
          _mmap_js: __mmap_js,
          _munmap_js: __munmap_js,
          _tzset_js: __tzset_js,
          emscripten_date_now: _emscripten_date_now,
          emscripten_get_now: _emscripten_get_now,
          emscripten_resize_heap: _emscripten_resize_heap,
          environ_get: _environ_get,
          environ_sizes_get: _environ_sizes_get,
          fd_close: _fd_close,
          fd_fdstat_get: _fd_fdstat_get,
          fd_read: _fd_read,
          fd_seek: _fd_seek,
          fd_sync: _fd_sync,
          fd_write: _fd_write,
          memory: wasmMemory,
        };
        createWasm();

        (Module['___wasm_call_ctors'] = function () {
          return (Module['___wasm_call_ctors'] =
            Module['asm']['__wasm_call_ctors']).apply(null, arguments);
        });

        (Module['_sqlite3_status64'] = function () {
          return (Module['_sqlite3_status64'] =
            Module['asm']['sqlite3_status64']).apply(null, arguments);
        });

        (Module['_sqlite3_status'] = function () {
          return (Module['_sqlite3_status'] =
            Module['asm']['sqlite3_status']).apply(null, arguments);
        });

        (Module['_sqlite3_db_status'] = function () {
          return (Module['_sqlite3_db_status'] =
            Module['asm']['sqlite3_db_status']).apply(null, arguments);
        });

        (Module['_sqlite3_msize'] = function () {
          return (Module['_sqlite3_msize'] =
            Module['asm']['sqlite3_msize']).apply(null, arguments);
        });

        (Module['_sqlite3_vfs_find'] = function () {
          return (Module['_sqlite3_vfs_find'] =
            Module['asm']['sqlite3_vfs_find']).apply(null, arguments);
        });

        (Module['_sqlite3_initialize'] = function () {
          return (Module['_sqlite3_initialize'] =
            Module['asm']['sqlite3_initialize']).apply(null, arguments);
        });

        (Module['_sqlite3_malloc'] = function () {
          return (Module['_sqlite3_malloc'] =
            Module['asm']['sqlite3_malloc']).apply(null, arguments);
        });

        (Module['_sqlite3_free'] = function () {
          return (Module['_sqlite3_free'] =
            Module['asm']['sqlite3_free']).apply(null, arguments);
        });

        (Module['_sqlite3_vfs_register'] = function () {
          return (Module['_sqlite3_vfs_register'] =
            Module['asm']['sqlite3_vfs_register']).apply(null, arguments);
        });

        (Module['_sqlite3_vfs_unregister'] =
          function () {
            return (Module['_sqlite3_vfs_unregister'] =
              Module['asm']['sqlite3_vfs_unregister']).apply(null, arguments);
          });

        (Module['_sqlite3_malloc64'] = function () {
          return (Module['_sqlite3_malloc64'] =
            Module['asm']['sqlite3_malloc64']).apply(null, arguments);
        });

        (Module['_sqlite3_realloc'] = function () {
          return (Module['_sqlite3_realloc'] =
            Module['asm']['sqlite3_realloc']).apply(null, arguments);
        });

        (Module['_sqlite3_realloc64'] = function () {
          return (Module['_sqlite3_realloc64'] =
            Module['asm']['sqlite3_realloc64']).apply(null, arguments);
        });

        (Module['_sqlite3_value_text'] = function () {
          return (Module['_sqlite3_value_text'] =
            Module['asm']['sqlite3_value_text']).apply(null, arguments);
        });

        (Module['_sqlite3_randomness'] = function () {
          return (Module['_sqlite3_randomness'] =
            Module['asm']['sqlite3_randomness']).apply(null, arguments);
        });

        (Module['_sqlite3_stricmp'] = function () {
          return (Module['_sqlite3_stricmp'] =
            Module['asm']['sqlite3_stricmp']).apply(null, arguments);
        });

        (Module['_sqlite3_strnicmp'] = function () {
          return (Module['_sqlite3_strnicmp'] =
            Module['asm']['sqlite3_strnicmp']).apply(null, arguments);
        });

        (Module['_sqlite3_uri_parameter'] =
          function () {
            return (Module['_sqlite3_uri_parameter'] =
              Module['asm']['sqlite3_uri_parameter']).apply(null, arguments);
          });

        var ___errno_location = (Module['___errno_location'] = function () {
          return (___errno_location = Module['___errno_location'] =
            Module['asm']['__errno_location']).apply(null, arguments);
        });

        (Module['_sqlite3_uri_boolean'] = function () {
          return (Module['_sqlite3_uri_boolean'] =
            Module['asm']['sqlite3_uri_boolean']).apply(null, arguments);
        });

        (Module['_sqlite3_serialize'] = function () {
          return (Module['_sqlite3_serialize'] =
            Module['asm']['sqlite3_serialize']).apply(null, arguments);
        });

        (Module['_sqlite3_prepare_v2'] = function () {
          return (Module['_sqlite3_prepare_v2'] =
            Module['asm']['sqlite3_prepare_v2']).apply(null, arguments);
        });

        (Module['_sqlite3_step'] = function () {
          return (Module['_sqlite3_step'] =
            Module['asm']['sqlite3_step']).apply(null, arguments);
        });

        (Module['_sqlite3_column_int64'] = function () {
          return (Module['_sqlite3_column_int64'] =
            Module['asm']['sqlite3_column_int64']).apply(null, arguments);
        });

        (Module['_sqlite3_reset'] = function () {
          return (Module['_sqlite3_reset'] =
            Module['asm']['sqlite3_reset']).apply(null, arguments);
        });

        (Module['_sqlite3_exec'] = function () {
          return (Module['_sqlite3_exec'] =
            Module['asm']['sqlite3_exec']).apply(null, arguments);
        });

        (Module['_sqlite3_column_int'] = function () {
          return (Module['_sqlite3_column_int'] =
            Module['asm']['sqlite3_column_int']).apply(null, arguments);
        });

        (Module['_sqlite3_finalize'] = function () {
          return (Module['_sqlite3_finalize'] =
            Module['asm']['sqlite3_finalize']).apply(null, arguments);
        });

        (Module['_sqlite3_file_control'] = function () {
          return (Module['_sqlite3_file_control'] =
            Module['asm']['sqlite3_file_control']).apply(null, arguments);
        });

        (Module['_sqlite3_column_name'] = function () {
          return (Module['_sqlite3_column_name'] =
            Module['asm']['sqlite3_column_name']).apply(null, arguments);
        });

        (Module['_sqlite3_column_text'] = function () {
          return (Module['_sqlite3_column_text'] =
            Module['asm']['sqlite3_column_text']).apply(null, arguments);
        });

        (Module['_sqlite3_column_type'] = function () {
          return (Module['_sqlite3_column_type'] =
            Module['asm']['sqlite3_column_type']).apply(null, arguments);
        });

        (Module['_sqlite3_errmsg'] = function () {
          return (Module['_sqlite3_errmsg'] =
            Module['asm']['sqlite3_errmsg']).apply(null, arguments);
        });

        (Module['_sqlite3_deserialize'] = function () {
          return (Module['_sqlite3_deserialize'] =
            Module['asm']['sqlite3_deserialize']).apply(null, arguments);
        });

        (Module['_sqlite3_clear_bindings'] =
          function () {
            return (Module['_sqlite3_clear_bindings'] =
              Module['asm']['sqlite3_clear_bindings']).apply(null, arguments);
          });

        (Module['_sqlite3_value_blob'] = function () {
          return (Module['_sqlite3_value_blob'] =
            Module['asm']['sqlite3_value_blob']).apply(null, arguments);
        });

        (Module['_sqlite3_value_bytes'] = function () {
          return (Module['_sqlite3_value_bytes'] =
            Module['asm']['sqlite3_value_bytes']).apply(null, arguments);
        });

        (Module['_sqlite3_value_double'] = function () {
          return (Module['_sqlite3_value_double'] =
            Module['asm']['sqlite3_value_double']).apply(null, arguments);
        });

        (Module['_sqlite3_value_int'] = function () {
          return (Module['_sqlite3_value_int'] =
            Module['asm']['sqlite3_value_int']).apply(null, arguments);
        });

        (Module['_sqlite3_value_int64'] = function () {
          return (Module['_sqlite3_value_int64'] =
            Module['asm']['sqlite3_value_int64']).apply(null, arguments);
        });

        (Module['_sqlite3_value_subtype'] =
          function () {
            return (Module['_sqlite3_value_subtype'] =
              Module['asm']['sqlite3_value_subtype']).apply(null, arguments);
          });

        (Module['_sqlite3_value_pointer'] =
          function () {
            return (Module['_sqlite3_value_pointer'] =
              Module['asm']['sqlite3_value_pointer']).apply(null, arguments);
          });

        (Module['_sqlite3_value_type'] = function () {
          return (Module['_sqlite3_value_type'] =
            Module['asm']['sqlite3_value_type']).apply(null, arguments);
        });

        (Module['_sqlite3_value_nochange'] =
          function () {
            return (Module['_sqlite3_value_nochange'] =
              Module['asm']['sqlite3_value_nochange']).apply(null, arguments);
          });

        (Module['_sqlite3_value_frombind'] =
          function () {
            return (Module['_sqlite3_value_frombind'] =
              Module['asm']['sqlite3_value_frombind']).apply(null, arguments);
          });

        (Module['_sqlite3_value_dup'] = function () {
          return (Module['_sqlite3_value_dup'] =
            Module['asm']['sqlite3_value_dup']).apply(null, arguments);
        });

        (Module['_sqlite3_value_free'] = function () {
          return (Module['_sqlite3_value_free'] =
            Module['asm']['sqlite3_value_free']).apply(null, arguments);
        });

        (Module['_sqlite3_result_blob'] = function () {
          return (Module['_sqlite3_result_blob'] =
            Module['asm']['sqlite3_result_blob']).apply(null, arguments);
        });

        (Module['_sqlite3_result_error_toobig'] =
          function () {
            return (Module[
              '_sqlite3_result_error_toobig'
            ] =
              Module['asm']['sqlite3_result_error_toobig']).apply(null, arguments);
          });

        (Module['_sqlite3_result_error_nomem'] =
          function () {
            return (Module[
              '_sqlite3_result_error_nomem'
            ] =
              Module['asm']['sqlite3_result_error_nomem']).apply(null, arguments);
          });

        (Module['_sqlite3_result_double'] =
          function () {
            return (Module['_sqlite3_result_double'] =
              Module['asm']['sqlite3_result_double']).apply(null, arguments);
          });

        (Module['_sqlite3_result_error'] = function () {
          return (Module['_sqlite3_result_error'] =
            Module['asm']['sqlite3_result_error']).apply(null, arguments);
        });

        (Module['_sqlite3_result_int'] = function () {
          return (Module['_sqlite3_result_int'] =
            Module['asm']['sqlite3_result_int']).apply(null, arguments);
        });

        (Module['_sqlite3_result_int64'] = function () {
          return (Module['_sqlite3_result_int64'] =
            Module['asm']['sqlite3_result_int64']).apply(null, arguments);
        });

        (Module['_sqlite3_result_null'] = function () {
          return (Module['_sqlite3_result_null'] =
            Module['asm']['sqlite3_result_null']).apply(null, arguments);
        });

        (Module['_sqlite3_result_pointer'] =
          function () {
            return (Module['_sqlite3_result_pointer'] =
              Module['asm']['sqlite3_result_pointer']).apply(null, arguments);
          });

        (Module['_sqlite3_result_subtype'] =
          function () {
            return (Module['_sqlite3_result_subtype'] =
              Module['asm']['sqlite3_result_subtype']).apply(null, arguments);
          });

        (Module['_sqlite3_result_text'] = function () {
          return (Module['_sqlite3_result_text'] =
            Module['asm']['sqlite3_result_text']).apply(null, arguments);
        });

        (Module['_sqlite3_result_zeroblob'] =
          function () {
            return (Module['_sqlite3_result_zeroblob'] =
              Module['asm']['sqlite3_result_zeroblob']).apply(null, arguments);
          });

        (Module['_sqlite3_result_zeroblob64'] =
          function () {
            return (Module[
              '_sqlite3_result_zeroblob64'
            ] =
              Module['asm']['sqlite3_result_zeroblob64']).apply(null, arguments);
          });

        (Module['_sqlite3_result_error_code'] =
          function () {
            return (Module[
              '_sqlite3_result_error_code'
            ] =
              Module['asm']['sqlite3_result_error_code']).apply(null, arguments);
          });

        (Module['_sqlite3_user_data'] = function () {
          return (Module['_sqlite3_user_data'] =
            Module['asm']['sqlite3_user_data']).apply(null, arguments);
        });

        (Module['_sqlite3_context_db_handle'] =
          function () {
            return (Module[
              '_sqlite3_context_db_handle'
            ] =
              Module['asm']['sqlite3_context_db_handle']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_nochange'] =
          function () {
            return (Module['_sqlite3_vtab_nochange'] =
              Module['asm']['sqlite3_vtab_nochange']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_in_first'] =
          function () {
            return (Module['_sqlite3_vtab_in_first'] =
              Module['asm']['sqlite3_vtab_in_first']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_in_next'] = function () {
          return (Module['_sqlite3_vtab_in_next'] =
            Module['asm']['sqlite3_vtab_in_next']).apply(null, arguments);
        });

        (Module['_sqlite3_aggregate_context'] =
          function () {
            return (Module[
              '_sqlite3_aggregate_context'
            ] =
              Module['asm']['sqlite3_aggregate_context']).apply(null, arguments);
          });

        (Module['_sqlite3_get_auxdata'] = function () {
          return (Module['_sqlite3_get_auxdata'] =
            Module['asm']['sqlite3_get_auxdata']).apply(null, arguments);
        });

        (Module['_sqlite3_set_auxdata'] = function () {
          return (Module['_sqlite3_set_auxdata'] =
            Module['asm']['sqlite3_set_auxdata']).apply(null, arguments);
        });

        (Module['_sqlite3_column_count'] = function () {
          return (Module['_sqlite3_column_count'] =
            Module['asm']['sqlite3_column_count']).apply(null, arguments);
        });

        (Module['_sqlite3_data_count'] = function () {
          return (Module['_sqlite3_data_count'] =
            Module['asm']['sqlite3_data_count']).apply(null, arguments);
        });

        (Module['_sqlite3_column_blob'] = function () {
          return (Module['_sqlite3_column_blob'] =
            Module['asm']['sqlite3_column_blob']).apply(null, arguments);
        });

        (Module['_sqlite3_column_bytes'] = function () {
          return (Module['_sqlite3_column_bytes'] =
            Module['asm']['sqlite3_column_bytes']).apply(null, arguments);
        });

        (Module['_sqlite3_column_double'] =
          function () {
            return (Module['_sqlite3_column_double'] =
              Module['asm']['sqlite3_column_double']).apply(null, arguments);
          });

        (Module['_sqlite3_column_value'] = function () {
          return (Module['_sqlite3_column_value'] =
            Module['asm']['sqlite3_column_value']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_blob'] = function () {
          return (Module['_sqlite3_bind_blob'] =
            Module['asm']['sqlite3_bind_blob']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_double'] = function () {
          return (Module['_sqlite3_bind_double'] =
            Module['asm']['sqlite3_bind_double']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_int'] = function () {
          return (Module['_sqlite3_bind_int'] =
            Module['asm']['sqlite3_bind_int']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_int64'] = function () {
          return (Module['_sqlite3_bind_int64'] =
            Module['asm']['sqlite3_bind_int64']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_null'] = function () {
          return (Module['_sqlite3_bind_null'] =
            Module['asm']['sqlite3_bind_null']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_pointer'] = function () {
          return (Module['_sqlite3_bind_pointer'] =
            Module['asm']['sqlite3_bind_pointer']).apply(null, arguments);
        });

        (Module['_sqlite3_bind_text'] = function () {
          return (Module['_sqlite3_bind_text'] =
            Module['asm']['sqlite3_bind_text']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_bind_parameter_count'
        ] = function () {
          return (Module[
            '_sqlite3_bind_parameter_count'
          ] =
            Module['asm']['sqlite3_bind_parameter_count']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_bind_parameter_index'
        ] = function () {
          return (Module[
            '_sqlite3_bind_parameter_index'
          ] =
            Module['asm']['sqlite3_bind_parameter_index']).apply(null, arguments);
        });

        (Module['_sqlite3_db_handle'] = function () {
          return (Module['_sqlite3_db_handle'] =
            Module['asm']['sqlite3_db_handle']).apply(null, arguments);
        });

        (Module['_sqlite3_stmt_readonly'] =
          function () {
            return (Module['_sqlite3_stmt_readonly'] =
              Module['asm']['sqlite3_stmt_readonly']).apply(null, arguments);
          });

        (Module['_sqlite3_stmt_isexplain'] =
          function () {
            return (Module['_sqlite3_stmt_isexplain'] =
              Module['asm']['sqlite3_stmt_isexplain']).apply(null, arguments);
          });

        (Module['_sqlite3_stmt_status'] = function () {
          return (Module['_sqlite3_stmt_status'] =
            Module['asm']['sqlite3_stmt_status']).apply(null, arguments);
        });

        (Module['_sqlite3_sql'] = function () {
          return (Module['_sqlite3_sql'] =
            Module['asm']['sqlite3_sql']).apply(null, arguments);
        });

        (Module['_sqlite3_expanded_sql'] = function () {
          return (Module['_sqlite3_expanded_sql'] =
            Module['asm']['sqlite3_expanded_sql']).apply(null, arguments);
        });

        (Module['_sqlite3_preupdate_old'] =
          function () {
            return (Module['_sqlite3_preupdate_old'] =
              Module['asm']['sqlite3_preupdate_old']).apply(null, arguments);
          });

        (Module['_sqlite3_preupdate_count'] =
          function () {
            return (Module['_sqlite3_preupdate_count'] =
              Module['asm']['sqlite3_preupdate_count']).apply(null, arguments);
          });

        (Module['_sqlite3_preupdate_depth'] =
          function () {
            return (Module['_sqlite3_preupdate_depth'] =
              Module['asm']['sqlite3_preupdate_depth']).apply(null, arguments);
          });

        (Module['_sqlite3_preupdate_blobwrite'] =
          function () {
            return (Module[
              '_sqlite3_preupdate_blobwrite'
            ] =
              Module['asm']['sqlite3_preupdate_blobwrite']).apply(null, arguments);
          });

        (Module['_sqlite3_preupdate_new'] =
          function () {
            return (Module['_sqlite3_preupdate_new'] =
              Module['asm']['sqlite3_preupdate_new']).apply(null, arguments);
          });

        (Module['_sqlite3_value_numeric_type'] =
          function () {
            return (Module[
              '_sqlite3_value_numeric_type'
            ] =
              Module['asm']['sqlite3_value_numeric_type']).apply(null, arguments);
          });

        (Module['_sqlite3_set_authorizer'] =
          function () {
            return (Module['_sqlite3_set_authorizer'] =
              Module['asm']['sqlite3_set_authorizer']).apply(null, arguments);
          });

        (Module['_sqlite3_strglob'] = function () {
          return (Module['_sqlite3_strglob'] =
            Module['asm']['sqlite3_strglob']).apply(null, arguments);
        });

        (Module['_sqlite3_strlike'] = function () {
          return (Module['_sqlite3_strlike'] =
            Module['asm']['sqlite3_strlike']).apply(null, arguments);
        });

        (Module['_sqlite3_auto_extension'] =
          function () {
            return (Module['_sqlite3_auto_extension'] =
              Module['asm']['sqlite3_auto_extension']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_cancel_auto_extension'
        ] = function () {
          return (Module[
            '_sqlite3_cancel_auto_extension'
          ] =
            Module['asm']['sqlite3_cancel_auto_extension']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_reset_auto_extension'
        ] = function () {
          return (Module[
            '_sqlite3_reset_auto_extension'
          ] =
            Module['asm']['sqlite3_reset_auto_extension']).apply(null, arguments);
        });

        (Module['_sqlite3_prepare_v3'] = function () {
          return (Module['_sqlite3_prepare_v3'] =
            Module['asm']['sqlite3_prepare_v3']).apply(null, arguments);
        });

        (Module['_sqlite3_create_module'] =
          function () {
            return (Module['_sqlite3_create_module'] =
              Module['asm']['sqlite3_create_module']).apply(null, arguments);
          });

        (Module['_sqlite3_create_module_v2'] =
          function () {
            return (Module[
              '_sqlite3_create_module_v2'
            ] =
              Module['asm']['sqlite3_create_module_v2']).apply(null, arguments);
          });

        (Module['_sqlite3_drop_modules'] = function () {
          return (Module['_sqlite3_drop_modules'] =
            Module['asm']['sqlite3_drop_modules']).apply(null, arguments);
        });

        (Module['_sqlite3_declare_vtab'] = function () {
          return (Module['_sqlite3_declare_vtab'] =
            Module['asm']['sqlite3_declare_vtab']).apply(null, arguments);
        });

        (Module['_sqlite3_vtab_on_conflict'] =
          function () {
            return (Module[
              '_sqlite3_vtab_on_conflict'
            ] =
              Module['asm']['sqlite3_vtab_on_conflict']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_collation'] =
          function () {
            return (Module['_sqlite3_vtab_collation'] =
              Module['asm']['sqlite3_vtab_collation']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_in'] = function () {
          return (Module['_sqlite3_vtab_in'] =
            Module['asm']['sqlite3_vtab_in']).apply(null, arguments);
        });

        (Module['_sqlite3_vtab_rhs_value'] =
          function () {
            return (Module['_sqlite3_vtab_rhs_value'] =
              Module['asm']['sqlite3_vtab_rhs_value']).apply(null, arguments);
          });

        (Module['_sqlite3_vtab_distinct'] =
          function () {
            return (Module['_sqlite3_vtab_distinct'] =
              Module['asm']['sqlite3_vtab_distinct']).apply(null, arguments);
          });

        (Module['_sqlite3_keyword_name'] = function () {
          return (Module['_sqlite3_keyword_name'] =
            Module['asm']['sqlite3_keyword_name']).apply(null, arguments);
        });

        (Module['_sqlite3_keyword_count'] =
          function () {
            return (Module['_sqlite3_keyword_count'] =
              Module['asm']['sqlite3_keyword_count']).apply(null, arguments);
          });

        (Module['_sqlite3_keyword_check'] =
          function () {
            return (Module['_sqlite3_keyword_check'] =
              Module['asm']['sqlite3_keyword_check']).apply(null, arguments);
          });

        (Module['_sqlite3_complete'] = function () {
          return (Module['_sqlite3_complete'] =
            Module['asm']['sqlite3_complete']).apply(null, arguments);
        });

        (Module['_sqlite3_libversion'] = function () {
          return (Module['_sqlite3_libversion'] =
            Module['asm']['sqlite3_libversion']).apply(null, arguments);
        });

        (Module['_sqlite3_libversion_number'] =
          function () {
            return (Module[
              '_sqlite3_libversion_number'
            ] =
              Module['asm']['sqlite3_libversion_number']).apply(null, arguments);
          });

        (Module['_sqlite3_shutdown'] = function () {
          return (Module['_sqlite3_shutdown'] =
            Module['asm']['sqlite3_shutdown']).apply(null, arguments);
        });

        (Module['_sqlite3_last_insert_rowid'] =
          function () {
            return (Module[
              '_sqlite3_last_insert_rowid'
            ] =
              Module['asm']['sqlite3_last_insert_rowid']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_set_last_insert_rowid'
        ] = function () {
          return (Module[
            '_sqlite3_set_last_insert_rowid'
          ] =
            Module['asm']['sqlite3_set_last_insert_rowid']).apply(null, arguments);
        });

        (Module['_sqlite3_changes64'] = function () {
          return (Module['_sqlite3_changes64'] =
            Module['asm']['sqlite3_changes64']).apply(null, arguments);
        });

        (Module['_sqlite3_changes'] = function () {
          return (Module['_sqlite3_changes'] =
            Module['asm']['sqlite3_changes']).apply(null, arguments);
        });

        (Module['_sqlite3_total_changes64'] =
          function () {
            return (Module['_sqlite3_total_changes64'] =
              Module['asm']['sqlite3_total_changes64']).apply(null, arguments);
          });

        (Module['_sqlite3_total_changes'] =
          function () {
            return (Module['_sqlite3_total_changes'] =
              Module['asm']['sqlite3_total_changes']).apply(null, arguments);
          });

        (Module['_sqlite3_txn_state'] = function () {
          return (Module['_sqlite3_txn_state'] =
            Module['asm']['sqlite3_txn_state']).apply(null, arguments);
        });

        (Module['_sqlite3_close_v2'] = function () {
          return (Module['_sqlite3_close_v2'] =
            Module['asm']['sqlite3_close_v2']).apply(null, arguments);
        });

        (Module['_sqlite3_busy_handler'] = function () {
          return (Module['_sqlite3_busy_handler'] =
            Module['asm']['sqlite3_busy_handler']).apply(null, arguments);
        });

        (Module['_sqlite3_progress_handler'] =
          function () {
            return (Module[
              '_sqlite3_progress_handler'
            ] =
              Module['asm']['sqlite3_progress_handler']).apply(null, arguments);
          });

        (Module['_sqlite3_busy_timeout'] = function () {
          return (Module['_sqlite3_busy_timeout'] =
            Module['asm']['sqlite3_busy_timeout']).apply(null, arguments);
        });

        (Module['_sqlite3_create_function'] =
          function () {
            return (Module['_sqlite3_create_function'] =
              Module['asm']['sqlite3_create_function']).apply(null, arguments);
          });

        (Module['_sqlite3_create_function_v2'] =
          function () {
            return (Module[
              '_sqlite3_create_function_v2'
            ] =
              Module['asm']['sqlite3_create_function_v2']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_create_window_function'
        ] = function () {
          return (Module[
            '_sqlite3_create_window_function'
          ] =
            Module['asm']['sqlite3_create_window_function']).apply(null, arguments);
        });

        (Module['_sqlite3_overload_function'] =
          function () {
            return (Module[
              '_sqlite3_overload_function'
            ] =
              Module['asm']['sqlite3_overload_function']).apply(null, arguments);
          });

        (Module['_sqlite3_trace_v2'] = function () {
          return (Module['_sqlite3_trace_v2'] =
            Module['asm']['sqlite3_trace_v2']).apply(null, arguments);
        });

        (Module['_sqlite3_commit_hook'] = function () {
          return (Module['_sqlite3_commit_hook'] =
            Module['asm']['sqlite3_commit_hook']).apply(null, arguments);
        });

        (Module['_sqlite3_update_hook'] = function () {
          return (Module['_sqlite3_update_hook'] =
            Module['asm']['sqlite3_update_hook']).apply(null, arguments);
        });

        (Module['_sqlite3_rollback_hook'] =
          function () {
            return (Module['_sqlite3_rollback_hook'] =
              Module['asm']['sqlite3_rollback_hook']).apply(null, arguments);
          });

        (Module['_sqlite3_preupdate_hook'] =
          function () {
            return (Module['_sqlite3_preupdate_hook'] =
              Module['asm']['sqlite3_preupdate_hook']).apply(null, arguments);
          });

        (Module['_sqlite3_error_offset'] = function () {
          return (Module['_sqlite3_error_offset'] =
            Module['asm']['sqlite3_error_offset']).apply(null, arguments);
        });

        (Module['_sqlite3_errcode'] = function () {
          return (Module['_sqlite3_errcode'] =
            Module['asm']['sqlite3_errcode']).apply(null, arguments);
        });

        (Module['_sqlite3_extended_errcode'] =
          function () {
            return (Module[
              '_sqlite3_extended_errcode'
            ] =
              Module['asm']['sqlite3_extended_errcode']).apply(null, arguments);
          });

        (Module['_sqlite3_errstr'] = function () {
          return (Module['_sqlite3_errstr'] =
            Module['asm']['sqlite3_errstr']).apply(null, arguments);
        });

        (Module['_sqlite3_limit'] = function () {
          return (Module['_sqlite3_limit'] =
            Module['asm']['sqlite3_limit']).apply(null, arguments);
        });

        (Module['_sqlite3_open'] = function () {
          return (Module['_sqlite3_open'] =
            Module['asm']['sqlite3_open']).apply(null, arguments);
        });

        (Module['_sqlite3_open_v2'] = function () {
          return (Module['_sqlite3_open_v2'] =
            Module['asm']['sqlite3_open_v2']).apply(null, arguments);
        });

        (Module['_sqlite3_create_collation'] =
          function () {
            return (Module[
              '_sqlite3_create_collation'
            ] =
              Module['asm']['sqlite3_create_collation']).apply(null, arguments);
          });

        (Module['_sqlite3_create_collation_v2'] =
          function () {
            return (Module[
              '_sqlite3_create_collation_v2'
            ] =
              Module['asm']['sqlite3_create_collation_v2']).apply(null, arguments);
          });

        (Module['_sqlite3_collation_needed'] =
          function () {
            return (Module[
              '_sqlite3_collation_needed'
            ] =
              Module['asm']['sqlite3_collation_needed']).apply(null, arguments);
          });

        (Module['_sqlite3_get_autocommit'] =
          function () {
            return (Module['_sqlite3_get_autocommit'] =
              Module['asm']['sqlite3_get_autocommit']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_table_column_metadata'
        ] = function () {
          return (Module[
            '_sqlite3_table_column_metadata'
          ] =
            Module['asm']['sqlite3_table_column_metadata']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_extended_result_codes'
        ] = function () {
          return (Module[
            '_sqlite3_extended_result_codes'
          ] =
            Module['asm']['sqlite3_extended_result_codes']).apply(null, arguments);
        });

        (Module['_sqlite3_uri_key'] = function () {
          return (Module['_sqlite3_uri_key'] =
            Module['asm']['sqlite3_uri_key']).apply(null, arguments);
        });

        (Module['_sqlite3_uri_int64'] = function () {
          return (Module['_sqlite3_uri_int64'] =
            Module['asm']['sqlite3_uri_int64']).apply(null, arguments);
        });

        (Module['_sqlite3_db_name'] = function () {
          return (Module['_sqlite3_db_name'] =
            Module['asm']['sqlite3_db_name']).apply(null, arguments);
        });

        (Module['_sqlite3_db_filename'] = function () {
          return (Module['_sqlite3_db_filename'] =
            Module['asm']['sqlite3_db_filename']).apply(null, arguments);
        });

        (Module['_sqlite3_compileoption_used'] =
          function () {
            return (Module[
              '_sqlite3_compileoption_used'
            ] =
              Module['asm']['sqlite3_compileoption_used']).apply(null, arguments);
          });

        (Module['_sqlite3_compileoption_get'] =
          function () {
            return (Module[
              '_sqlite3_compileoption_get'
            ] =
              Module['asm']['sqlite3_compileoption_get']).apply(null, arguments);
          });

        (Module['_sqlite3session_diff'] = function () {
          return (Module['_sqlite3session_diff'] =
            Module['asm']['sqlite3session_diff']).apply(null, arguments);
        });

        (Module['_sqlite3session_attach'] =
          function () {
            return (Module['_sqlite3session_attach'] =
              Module['asm']['sqlite3session_attach']).apply(null, arguments);
          });

        (Module['_sqlite3session_create'] =
          function () {
            return (Module['_sqlite3session_create'] =
              Module['asm']['sqlite3session_create']).apply(null, arguments);
          });

        (Module['_sqlite3session_delete'] =
          function () {
            return (Module['_sqlite3session_delete'] =
              Module['asm']['sqlite3session_delete']).apply(null, arguments);
          });

        (Module['_sqlite3session_table_filter'] =
          function () {
            return (Module[
              '_sqlite3session_table_filter'
            ] =
              Module['asm']['sqlite3session_table_filter']).apply(null, arguments);
          });

        (Module['_sqlite3session_changeset'] =
          function () {
            return (Module[
              '_sqlite3session_changeset'
            ] =
              Module['asm']['sqlite3session_changeset']).apply(null, arguments);
          });

        (Module[
          '_sqlite3session_changeset_strm'
        ] = function () {
          return (Module[
            '_sqlite3session_changeset_strm'
          ] =
            Module['asm']['sqlite3session_changeset_strm']).apply(null, arguments);
        });

        (Module[
          '_sqlite3session_patchset_strm'
        ] = function () {
          return (Module[
            '_sqlite3session_patchset_strm'
          ] =
            Module['asm']['sqlite3session_patchset_strm']).apply(null, arguments);
        });

        (Module['_sqlite3session_patchset'] =
          function () {
            return (Module['_sqlite3session_patchset'] =
              Module['asm']['sqlite3session_patchset']).apply(null, arguments);
          });

        (Module['_sqlite3session_enable'] =
          function () {
            return (Module['_sqlite3session_enable'] =
              Module['asm']['sqlite3session_enable']).apply(null, arguments);
          });

        (Module['_sqlite3session_indirect'] =
          function () {
            return (Module['_sqlite3session_indirect'] =
              Module['asm']['sqlite3session_indirect']).apply(null, arguments);
          });

        (Module['_sqlite3session_isempty'] =
          function () {
            return (Module['_sqlite3session_isempty'] =
              Module['asm']['sqlite3session_isempty']).apply(null, arguments);
          });

        (Module['_sqlite3session_memory_used'] =
          function () {
            return (Module[
              '_sqlite3session_memory_used'
            ] =
              Module['asm']['sqlite3session_memory_used']).apply(null, arguments);
          });

        (Module[
          '_sqlite3session_object_config'
        ] = function () {
          return (Module[
            '_sqlite3session_object_config'
          ] =
            Module['asm']['sqlite3session_object_config']).apply(null, arguments);
        });

        (Module[
          '_sqlite3session_changeset_size'
        ] = function () {
          return (Module[
            '_sqlite3session_changeset_size'
          ] =
            Module['asm']['sqlite3session_changeset_size']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_start'] =
          function () {
            return (Module['_sqlite3changeset_start'] =
              Module['asm']['sqlite3changeset_start']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_start_v2'] =
          function () {
            return (Module[
              '_sqlite3changeset_start_v2'
            ] =
              Module['asm']['sqlite3changeset_start_v2']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_start_strm'] =
          function () {
            return (Module[
              '_sqlite3changeset_start_strm'
            ] =
              Module['asm']['sqlite3changeset_start_strm']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changeset_start_v2_strm'
        ] = function () {
          return (Module[
            '_sqlite3changeset_start_v2_strm'
          ] =
            Module['asm']['sqlite3changeset_start_v2_strm']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_next'] =
          function () {
            return (Module['_sqlite3changeset_next'] =
              Module['asm']['sqlite3changeset_next']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_op'] = function () {
          return (Module['_sqlite3changeset_op'] =
            Module['asm']['sqlite3changeset_op']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_pk'] = function () {
          return (Module['_sqlite3changeset_pk'] =
            Module['asm']['sqlite3changeset_pk']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_old'] = function () {
          return (Module['_sqlite3changeset_old'] =
            Module['asm']['sqlite3changeset_old']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_new'] = function () {
          return (Module['_sqlite3changeset_new'] =
            Module['asm']['sqlite3changeset_new']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_conflict'] =
          function () {
            return (Module[
              '_sqlite3changeset_conflict'
            ] =
              Module['asm']['sqlite3changeset_conflict']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changeset_fk_conflicts'
        ] = function () {
          return (Module[
            '_sqlite3changeset_fk_conflicts'
          ] =
            Module['asm']['sqlite3changeset_fk_conflicts']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_finalize'] =
          function () {
            return (Module[
              '_sqlite3changeset_finalize'
            ] =
              Module['asm']['sqlite3changeset_finalize']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_invert'] =
          function () {
            return (Module['_sqlite3changeset_invert'] =
              Module['asm']['sqlite3changeset_invert']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changeset_invert_strm'
        ] = function () {
          return (Module[
            '_sqlite3changeset_invert_strm'
          ] =
            Module['asm']['sqlite3changeset_invert_strm']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_apply_v2'] =
          function () {
            return (Module[
              '_sqlite3changeset_apply_v2'
            ] =
              Module['asm']['sqlite3changeset_apply_v2']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_apply'] =
          function () {
            return (Module['_sqlite3changeset_apply'] =
              Module['asm']['sqlite3changeset_apply']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changeset_apply_v2_strm'
        ] = function () {
          return (Module[
            '_sqlite3changeset_apply_v2_strm'
          ] =
            Module['asm']['sqlite3changeset_apply_v2_strm']).apply(null, arguments);
        });

        (Module['_sqlite3changeset_apply_strm'] =
          function () {
            return (Module[
              '_sqlite3changeset_apply_strm'
            ] =
              Module['asm']['sqlite3changeset_apply_strm']).apply(null, arguments);
          });

        (Module['_sqlite3changegroup_new'] =
          function () {
            return (Module['_sqlite3changegroup_new'] =
              Module['asm']['sqlite3changegroup_new']).apply(null, arguments);
          });

        (Module['_sqlite3changegroup_add'] =
          function () {
            return (Module['_sqlite3changegroup_add'] =
              Module['asm']['sqlite3changegroup_add']).apply(null, arguments);
          });

        (Module['_sqlite3changegroup_output'] =
          function () {
            return (Module[
              '_sqlite3changegroup_output'
            ] =
              Module['asm']['sqlite3changegroup_output']).apply(null, arguments);
          });

        (Module['_sqlite3changegroup_add_strm'] =
          function () {
            return (Module[
              '_sqlite3changegroup_add_strm'
            ] =
              Module['asm']['sqlite3changegroup_add_strm']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changegroup_output_strm'
        ] = function () {
          return (Module[
            '_sqlite3changegroup_output_strm'
          ] =
            Module['asm']['sqlite3changegroup_output_strm']).apply(null, arguments);
        });

        (Module['_sqlite3changegroup_delete'] =
          function () {
            return (Module[
              '_sqlite3changegroup_delete'
            ] =
              Module['asm']['sqlite3changegroup_delete']).apply(null, arguments);
          });

        (Module['_sqlite3changeset_concat'] =
          function () {
            return (Module['_sqlite3changeset_concat'] =
              Module['asm']['sqlite3changeset_concat']).apply(null, arguments);
          });

        (Module[
          '_sqlite3changeset_concat_strm'
        ] = function () {
          return (Module[
            '_sqlite3changeset_concat_strm'
          ] =
            Module['asm']['sqlite3changeset_concat_strm']).apply(null, arguments);
        });

        (Module['_sqlite3session_config'] =
          function () {
            return (Module['_sqlite3session_config'] =
              Module['asm']['sqlite3session_config']).apply(null, arguments);
          });

        (Module['_sqlite3_sourceid'] = function () {
          return (Module['_sqlite3_sourceid'] =
            Module['asm']['sqlite3_sourceid']).apply(null, arguments);
        });

        (Module['_sqlite3_wasm_pstack_ptr'] =
          function () {
            return (Module['_sqlite3_wasm_pstack_ptr'] =
              Module['asm']['sqlite3_wasm_pstack_ptr']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_pstack_restore'] =
          function () {
            return (Module[
              '_sqlite3_wasm_pstack_restore'
            ] =
              Module['asm']['sqlite3_wasm_pstack_restore']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_pstack_alloc'] =
          function () {
            return (Module[
              '_sqlite3_wasm_pstack_alloc'
            ] =
              Module['asm']['sqlite3_wasm_pstack_alloc']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_pstack_remaining'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_pstack_remaining'
          ] =
            Module['asm']['sqlite3_wasm_pstack_remaining']).apply(null, arguments);
        });

        (Module['_sqlite3_wasm_pstack_quota'] =
          function () {
            return (Module[
              '_sqlite3_wasm_pstack_quota'
            ] =
              Module['asm']['sqlite3_wasm_pstack_quota']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_db_error'] =
          function () {
            return (Module['_sqlite3_wasm_db_error'] =
              Module['asm']['sqlite3_wasm_db_error']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_test_struct'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_struct'
            ] =
              Module['asm']['sqlite3_wasm_test_struct']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_enum_json'] =
          function () {
            return (Module['_sqlite3_wasm_enum_json'] =
              Module['asm']['sqlite3_wasm_enum_json']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_vfs_unlink'] =
          function () {
            return (Module['_sqlite3_wasm_vfs_unlink'] =
              Module['asm']['sqlite3_wasm_vfs_unlink']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_db_vfs'] = function () {
          return (Module['_sqlite3_wasm_db_vfs'] =
            Module['asm']['sqlite3_wasm_db_vfs']).apply(null, arguments);
        });

        (Module['_sqlite3_wasm_db_reset'] =
          function () {
            return (Module['_sqlite3_wasm_db_reset'] =
              Module['asm']['sqlite3_wasm_db_reset']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_db_export_chunked'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_db_export_chunked'
          ] =
            Module['asm']['sqlite3_wasm_db_export_chunked']).apply(null, arguments);
        });

        (Module['_sqlite3_wasm_db_serialize'] =
          function () {
            return (Module[
              '_sqlite3_wasm_db_serialize'
            ] =
              Module['asm']['sqlite3_wasm_db_serialize']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_vfs_create_file'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_vfs_create_file'
          ] =
            Module['asm']['sqlite3_wasm_vfs_create_file']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_wasm_posix_create_file'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_posix_create_file'
          ] =
            Module['asm']['sqlite3_wasm_posix_create_file']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_kvvfsMakeKeyOnPstack'
          ] =
            Module['asm']['sqlite3_wasm_kvvfsMakeKeyOnPstack']).apply(
            null,
            arguments,
          );
        });

        (Module['_sqlite3_wasm_kvvfs_methods'] =
          function () {
            return (Module[
              '_sqlite3_wasm_kvvfs_methods'
            ] =
              Module['asm']['sqlite3_wasm_kvvfs_methods']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_vtab_config'] =
          function () {
            return (Module[
              '_sqlite3_wasm_vtab_config'
            ] =
              Module['asm']['sqlite3_wasm_vtab_config']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_db_config_ip'] =
          function () {
            return (Module[
              '_sqlite3_wasm_db_config_ip'
            ] =
              Module['asm']['sqlite3_wasm_db_config_ip']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_db_config_pii'] =
          function () {
            return (Module[
              '_sqlite3_wasm_db_config_pii'
            ] =
              Module['asm']['sqlite3_wasm_db_config_pii']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_db_config_s'] =
          function () {
            return (Module[
              '_sqlite3_wasm_db_config_s'
            ] =
              Module['asm']['sqlite3_wasm_db_config_s']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_config_i'] =
          function () {
            return (Module['_sqlite3_wasm_config_i'] =
              Module['asm']['sqlite3_wasm_config_i']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_config_ii'] =
          function () {
            return (Module['_sqlite3_wasm_config_ii'] =
              Module['asm']['sqlite3_wasm_config_ii']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_config_j'] =
          function () {
            return (Module['_sqlite3_wasm_config_j'] =
              Module['asm']['sqlite3_wasm_config_j']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_init_wasmfs'] =
          function () {
            return (Module[
              '_sqlite3_wasm_init_wasmfs'
            ] =
              Module['asm']['sqlite3_wasm_init_wasmfs']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_test_intptr'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_intptr'
            ] =
              Module['asm']['sqlite3_wasm_test_intptr']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_test_voidptr'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_voidptr'
            ] =
              Module['asm']['sqlite3_wasm_test_voidptr']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_test_int64_max'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_int64_max'
            ] =
              Module['asm']['sqlite3_wasm_test_int64_max']).apply(null, arguments);
          });

        (Module['_sqlite3_wasm_test_int64_min'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_int64_min'
            ] =
              Module['asm']['sqlite3_wasm_test_int64_min']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_test_int64_times2'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_test_int64_times2'
          ] =
            Module['asm']['sqlite3_wasm_test_int64_times2']).apply(null, arguments);
        });

        (Module[
          '_sqlite3_wasm_test_int64_minmax'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_test_int64_minmax'
          ] =
            Module['asm']['sqlite3_wasm_test_int64_minmax']).apply(null, arguments);
        });

        (Module['_sqlite3_wasm_test_int64ptr'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_int64ptr'
            ] =
              Module['asm']['sqlite3_wasm_test_int64ptr']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_test_stack_overflow'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_test_stack_overflow'
          ] =
            Module['asm']['sqlite3_wasm_test_stack_overflow']).apply(
            null,
            arguments,
          );
        });

        (Module['_sqlite3_wasm_test_str_hello'] =
          function () {
            return (Module[
              '_sqlite3_wasm_test_str_hello'
            ] =
              Module['asm']['sqlite3_wasm_test_str_hello']).apply(null, arguments);
          });

        (Module[
          '_sqlite3_wasm_SQLTester_strglob'
        ] = function () {
          return (Module[
            '_sqlite3_wasm_SQLTester_strglob'
          ] =
            Module['asm']['sqlite3_wasm_SQLTester_strglob']).apply(null, arguments);
        });

        var _malloc = (Module['_malloc'] = function () {
          return (_malloc = Module['_malloc'] = Module['asm']['malloc']).apply(
            null,
            arguments,
          );
        });

        (Module['_free'] = function () {
          return (Module['_free'] = Module['asm']['free']).apply(
            null,
            arguments,
          );
        });

        (Module['_realloc'] = function () {
          return (Module['_realloc'] = Module['asm']['realloc']).apply(
            null,
            arguments,
          );
        });

        var _emscripten_builtin_memalign = (Module['_emscripten_builtin_memalign'] =
          function () {
            return (_emscripten_builtin_memalign = Module[
              '_emscripten_builtin_memalign'
            ] =
              Module['asm']['emscripten_builtin_memalign']).apply(null, arguments);
          });

        (Module['stackSave'] = function () {
          return (Module['stackSave'] =
            Module['asm']['stackSave']).apply(null, arguments);
        });

        (Module['stackRestore'] = function () {
          return (Module['stackRestore'] =
            Module['asm']['stackRestore']).apply(null, arguments);
        });

        (Module['stackAlloc'] = function () {
          return (Module['stackAlloc'] =
            Module['asm']['stackAlloc']).apply(null, arguments);
        });

        Module['wasmMemory'] = wasmMemory;

        var calledRun;

        dependenciesFulfilled = function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        };

        function run(args) {

          if (runDependencies > 0) {
            return;
          }

          preRun();

          if (runDependencies > 0) {
            return;
          }

          function doRun() {
            if (calledRun) return;
            calledRun = true;
            Module['calledRun'] = true;

            if (ABORT) return;

            initRuntime();

            readyPromiseResolve(Module);
            if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

            postRun();
          }

          if (Module['setStatus']) {
            Module['setStatus']('Running...');
            setTimeout(function () {
              setTimeout(function () {
                Module['setStatus']('');
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }

        if (Module['preInit']) {
          if (typeof Module['preInit'] == 'function')
            Module['preInit'] = [Module['preInit']];
          while (Module['preInit'].length > 0) {
            Module['preInit'].pop()();
          }
        }

        run();

        if (!Module.postRun) Module.postRun = [];
        Module.postRun.push(function (Module) {
          globalThis.sqlite3ApiBootstrap = function sqlite3ApiBootstrap(
            apiConfig = globalThis.sqlite3ApiConfig ||
              sqlite3ApiBootstrap.defaultConfig,
          ) {
            if (sqlite3ApiBootstrap.sqlite3) {
              console.warn(
                'sqlite3ApiBootstrap() called multiple times.',
                'Config and external initializers are ignored on calls after the first.',
              );
              return sqlite3ApiBootstrap.sqlite3;
            }
            const config = Object.assign(
              Object.create(null),
              {
                exports: undefined,
                memory: undefined,
                bigIntEnabled: (() => {
                  if ('undefined' !== typeof Module) {
                    return !!Module.HEAPU64;
                  }
                  return !!globalThis.BigInt64Array;
                })(),
                debug: console.debug.bind(console),
                warn: console.warn.bind(console),
                error: console.error.bind(console),
                log: console.log.bind(console),
                wasmfsOpfsDir: '/opfs',

                useStdAlloc: false,
              },
              apiConfig || {},
            );

            Object.assign(
              config,
              {
                allocExportName: config.useStdAlloc ? 'malloc' : 'sqlite3_malloc',
                deallocExportName: config.useStdAlloc ? 'free' : 'sqlite3_free',
                reallocExportName: config.useStdAlloc
                  ? 'realloc'
                  : 'sqlite3_realloc',
              },
              config,
            );

            ['exports', 'memory', 'wasmfsOpfsDir'].forEach((k) => {
              if ('function' === typeof config[k]) {
                config[k] = config[k]();
              }
            });

            const capi = Object.create(null);

            const wasm = Object.create(null);

            const __rcStr = (rc) => {
              return (
                (capi.sqlite3_js_rc_str && capi.sqlite3_js_rc_str(rc)) ||
                'Unknown result code #' + rc
              );
            };

            const __isInt = (n) => 'number' === typeof n && n === (n | 0);

            class SQLite3Error extends Error {
              constructor(...args) {
                let rc;
                if (args.length) {
                  if (__isInt(args[0])) {
                    rc = args[0];
                    if (1 === args.length) {
                      super(__rcStr(args[0]));
                    } else {
                      const rcStr = __rcStr(rc);
                      if ('object' === typeof args[1]) {
                        super(rcStr, args[1]);
                      } else {
                        args[0] = rcStr + ':';
                        super(args.join(' '));
                      }
                    }
                  } else {
                    if (2 === args.length && 'object' === typeof args[1]) {
                      super(...args);
                    } else {
                      super(args.join(' '));
                    }
                  }
                }
                this.resultCode = rc || capi.SQLITE_ERROR;
                this.name = 'SQLite3Error';
              }
            }

            SQLite3Error.toss = (...args) => {
              throw new SQLite3Error(...args);
            };
            const toss3 = SQLite3Error.toss;

            if (config.wasmfsOpfsDir && !/^\/[^/]+$/.test(config.wasmfsOpfsDir)) {
              toss3(
                "config.wasmfsOpfsDir must be falsy or in the form '/dir-name'.",
              );
            }

            const isInt32 = (n) => {
              return (
                'bigint' !== typeof n &&
                !!(n === (n | 0) && n <= 2147483647 && n >= -2147483648)
              );
            };

            const bigIntFits64 = function f(b) {
              if (!f._max) {
                f._max = BigInt('0x7fffffffffffffff');
                f._min = ~f._max;
              }
              return b >= f._min && b <= f._max;
            };

            const bigIntFits32 = (b) => b >= -0x7fffffffn - 1n && b <= 0x7fffffffn;

            const bigIntFitsDouble = function f(b) {
              if (!f._min) {
                f._min = Number.MIN_SAFE_INTEGER;
                f._max = Number.MAX_SAFE_INTEGER;
              }
              return b >= f._min && b <= f._max;
            };

            const isTypedArray = (v) => {
              return v && v.constructor && isInt32(v.constructor.BYTES_PER_ELEMENT)
                ? v
                : false;
            };

            const __SAB =
              'undefined' === typeof SharedArrayBuffer
                ? function () {}
                : SharedArrayBuffer;

            const isSharedTypedArray = (aTypedArray) =>
              aTypedArray.buffer instanceof __SAB;

            const typedArrayPart = (aTypedArray, begin, end) => {
              return isSharedTypedArray(aTypedArray)
                ? aTypedArray.slice(begin, end)
                : aTypedArray.subarray(begin, end);
            };

            const isBindableTypedArray = (v) => {
              return (
                v &&
                (v instanceof Uint8Array ||
                  v instanceof Int8Array ||
                  v instanceof ArrayBuffer)
              );
            };

            const isSQLableTypedArray = (v) => {
              return (
                v &&
                (v instanceof Uint8Array ||
                  v instanceof Int8Array ||
                  v instanceof ArrayBuffer)
              );
            };

            const affirmBindableTypedArray = (v) => {
              return (
                isBindableTypedArray(v) ||
                toss3('Value is not of a supported TypedArray type.')
              );
            };

            const utf8Decoder = new TextDecoder('utf-8');

            const typedArrayToString = function (typedArray, begin, end) {
              return utf8Decoder.decode(typedArrayPart(typedArray, begin, end));
            };

            const flexibleString = function (v) {
              if (isSQLableTypedArray(v)) {
                return typedArrayToString(
                  v instanceof ArrayBuffer ? new Uint8Array(v) : v,
                );
              } else if (Array.isArray(v)) return v.join('');
              else if (wasm.isPtr(v)) v = wasm.cstrToJs(v);
              return v;
            };

            class WasmAllocError extends Error {
              constructor(...args) {
                if (2 === args.length && 'object' === typeof args[1]) {
                  super(...args);
                } else if (args.length) {
                  super(args.join(' '));
                } else {
                  super('Allocation failed.');
                }
                this.resultCode = capi.SQLITE_NOMEM;
                this.name = 'WasmAllocError';
              }
            }

            WasmAllocError.toss = (...args) => {
              throw new WasmAllocError(...args);
            };

            Object.assign(capi, {
              sqlite3_bind_blob: undefined,

              sqlite3_bind_text: undefined,

              sqlite3_create_function_v2: (
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              ) => {},

              sqlite3_create_function: (
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
              ) => {},

              sqlite3_create_window_function: (
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              ) => {},

              sqlite3_prepare_v3: (
                dbPtr,
                sql,
                sqlByteLen,
                prepFlags,
                stmtPtrPtr,
                strPtrPtr,
              ) => {},

              sqlite3_prepare_v2: (
                dbPtr,
                sql,
                sqlByteLen,
                stmtPtrPtr,
                strPtrPtr,
              ) => {},

              sqlite3_exec: (pDb, sql, callback, pVoid, pErrMsg) => {},

              sqlite3_randomness: (n, outPtr) => {},
            });

            const util = {
              affirmBindableTypedArray,
              flexibleString,
              bigIntFits32,
              bigIntFits64,
              bigIntFitsDouble,
              isBindableTypedArray,
              isInt32,
              isSQLableTypedArray,
              isTypedArray,
              typedArrayToString,
              isUIThread: () =>
                globalThis.window === globalThis && !!globalThis.document,

              isSharedTypedArray,
              toss: function (...args) {
                throw new Error(args.join(' '));
              },
              toss3,
              typedArrayPart,

              affirmDbHeader: function (bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                const header = 'SQLite format 3';
                if (header.length > bytes.byteLength) {
                  toss3('Input does not contain an SQLite3 database header.');
                }
                for (let i = 0; i < header.length; ++i) {
                  if (header.charCodeAt(i) !== bytes[i]) {
                    toss3('Input does not contain an SQLite3 database header.');
                  }
                }
              },

              affirmIsDb: function (bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                const n = bytes.byteLength;
                if (n < 512 || n % 512 !== 0) {
                  toss3('Byte array size', n, 'is invalid for an SQLite3 db.');
                }
                util.affirmDbHeader(bytes);
              },
            };

            Object.assign(wasm, {
              ptrSizeof: config.wasmPtrSizeof || 4,

              ptrIR: config.wasmPtrIR || 'i32',

              bigIntEnabled: !!config.bigIntEnabled,

              exports:
                config.exports ||
                toss3('Missing API config.exports (WASM module exports).'),

              memory:
                config.memory ||
                config.exports['memory'] ||
                toss3(
                  'API config object requires a WebAssembly.Memory object',
                  'in either config.exports.memory (exported)',
                  'or config.memory (imported).',
                ),

              alloc: undefined,

              realloc: undefined,

              dealloc: undefined,
            });

            wasm.allocFromTypedArray = function (srcTypedArray) {
              if (srcTypedArray instanceof ArrayBuffer) {
                srcTypedArray = new Uint8Array(srcTypedArray);
              }
              affirmBindableTypedArray(srcTypedArray);
              const pRet = wasm.alloc(srcTypedArray.byteLength || 1);
              wasm
                .heapForSize(srcTypedArray.constructor)
                .set(srcTypedArray.byteLength ? srcTypedArray : [0], pRet);
              return pRet;
            };

            {
              const keyAlloc = config.allocExportName,
                keyDealloc = config.deallocExportName,
                keyRealloc = config.reallocExportName;
              for (const key of [keyAlloc, keyDealloc, keyRealloc]) {
                const f = wasm.exports[key];
                if (!(f instanceof Function))
                  toss3('Missing required exports[', key, '] function.');
              }

              wasm.alloc = function f(n) {
                return (
                  f.impl(n) ||
                  WasmAllocError.toss('Failed to allocate', n, ' bytes.')
                );
              };
              wasm.alloc.impl = wasm.exports[keyAlloc];
              wasm.realloc = function f(m, n) {
                const m2 = f.impl(m, n);
                return n
                  ? m2 || WasmAllocError.toss('Failed to reallocate', n, ' bytes.')
                  : 0;
              };
              wasm.realloc.impl = wasm.exports[keyRealloc];
              wasm.dealloc = wasm.exports[keyDealloc];
            }

            wasm.compileOptionUsed = function f(optName) {
              if (!arguments.length) {
                if (f._result) return f._result;
                else if (!f._opt) {
                  f._rx = /^([^=]+)=(.+)/;
                  f._rxInt = /^-?\d+$/;
                  f._opt = function (opt, rv) {
                    const m = f._rx.exec(opt);
                    rv[0] = m ? m[1] : opt;
                    rv[1] = m ? (f._rxInt.test(m[2]) ? +m[2] : m[2]) : true;
                  };
                }
                const rc = {},
                  ov = [0, 0];
                let i = 0,
                  k;
                while ((k = capi.sqlite3_compileoption_get(i++))) {
                  f._opt(k, ov);
                  rc[ov[0]] = ov[1];
                }
                return (f._result = rc);
              } else if (Array.isArray(optName)) {
                const rc = {};
                optName.forEach((v) => {
                  rc[v] = capi.sqlite3_compileoption_used(v);
                });
                return rc;
              } else if ('object' === typeof optName) {
                Object.keys(optName).forEach((k) => {
                  optName[k] = capi.sqlite3_compileoption_used(k);
                });
                return optName;
              }
              return 'string' === typeof optName
                ? !!capi.sqlite3_compileoption_used(optName)
                : false;
            };

            wasm.pstack = Object.assign(Object.create(null), {
              restore: wasm.exports.sqlite3_wasm_pstack_restore,

              alloc: function (n) {
                if ('string' === typeof n && !(n = wasm.sizeofIR(n))) {
                  WasmAllocError.toss(
                    'Invalid value for pstack.alloc(',
                    arguments[0],
                    ')',
                  );
                }
                return (
                  wasm.exports.sqlite3_wasm_pstack_alloc(n) ||
                  WasmAllocError.toss(
                    'Could not allocate',
                    n,
                    'bytes from the pstack.',
                  )
                );
              },

              allocChunks: function (n, sz) {
                if ('string' === typeof sz && !(sz = wasm.sizeofIR(sz))) {
                  WasmAllocError.toss(
                    'Invalid size value for allocChunks(',
                    arguments[1],
                    ')',
                  );
                }
                const mem = wasm.pstack.alloc(n * sz);
                const rc = [];
                let i = 0,
                  offset = 0;
                for (; i < n; ++i, offset += sz) rc.push(mem + offset);
                return rc;
              },

              allocPtr: (n = 1, safePtrSize = true) => {
                return 1 === n
                  ? wasm.pstack.alloc(safePtrSize ? 8 : wasm.ptrSizeof)
                  : wasm.pstack.allocChunks(n, safePtrSize ? 8 : wasm.ptrSizeof);
              },

              call: function (f) {
                const stackPos = wasm.pstack.pointer;
                try {
                  return f(sqlite3);
                } finally {
                  wasm.pstack.restore(stackPos);
                }
              },
            });
            Object.defineProperties(wasm.pstack, {
              pointer: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm.exports.sqlite3_wasm_pstack_ptr,
              },

              quota: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm.exports.sqlite3_wasm_pstack_quota,
              },

              remaining: {
                configurable: false,
                iterable: true,
                writeable: false,
                get: wasm.exports.sqlite3_wasm_pstack_remaining,
              },
            });

            capi.sqlite3_randomness = (...args) => {
              if (
                1 === args.length &&
                util.isTypedArray(args[0]) &&
                1 === args[0].BYTES_PER_ELEMENT
              ) {
                const ta = args[0];
                if (0 === ta.byteLength) {
                  wasm.exports.sqlite3_randomness(0, 0);
                  return ta;
                }
                const stack = wasm.pstack.pointer;
                try {
                  let n = ta.byteLength,
                    offset = 0;
                  const r = wasm.exports.sqlite3_randomness;
                  const heap = wasm.heap8u();
                  const nAlloc = n < 512 ? n : 512;
                  const ptr = wasm.pstack.alloc(nAlloc);
                  do {
                    const j = n > nAlloc ? nAlloc : n;
                    r(j, ptr);
                    ta.set(typedArrayPart(heap, ptr, ptr + j), offset);
                    n -= j;
                    offset += j;
                  } while (n > 0);
                } catch (e) {
                  console.error(
                    'Highly unexpected (and ignored!) ' +
                      'exception in sqlite3_randomness():',
                    e,
                  );
                } finally {
                  wasm.pstack.restore(stack);
                }
                return ta;
              }
              wasm.exports.sqlite3_randomness(...args);
            };

            let __wasmfsOpfsDir = undefined;

            capi.sqlite3_wasmfs_opfs_dir = function () {
              if (undefined !== __wasmfsOpfsDir) return __wasmfsOpfsDir;

              const pdir = config.wasmfsOpfsDir;
              if (
                !pdir ||
                !globalThis.FileSystemHandle ||
                !globalThis.FileSystemDirectoryHandle ||
                !globalThis.FileSystemFileHandle
              ) {
                return (__wasmfsOpfsDir = '');
              }
              try {
                if (
                  pdir &&
                  0 ===
                    wasm.xCallWrapped(
                      'sqlite3_wasm_init_wasmfs',
                      'i32',
                      ['string'],
                      pdir,
                    )
                ) {
                  return (__wasmfsOpfsDir = pdir);
                } else {
                  return (__wasmfsOpfsDir = '');
                }
              } catch (e) {
                return (__wasmfsOpfsDir = '');
              }
            };

            capi.sqlite3_wasmfs_filename_is_persistent = function (name) {
              const p = capi.sqlite3_wasmfs_opfs_dir();
              return p && name ? name.startsWith(p + '/') : false;
            };

            capi.sqlite3_js_db_uses_vfs = function (pDb, vfsName, dbName = 0) {
              try {
                const pK = capi.sqlite3_vfs_find(vfsName);
                if (!pK) return false;
                else if (!pDb) {
                  return pK === capi.sqlite3_vfs_find(0) ? pK : false;
                } else {
                  return pK === capi.sqlite3_js_db_vfs(pDb, dbName) ? pK : false;
                }
              } catch (e) {
                return false;
              }
            };

            capi.sqlite3_js_vfs_list = function () {
              const rc = [];
              let pVfs = capi.sqlite3_vfs_find(0);
              while (pVfs) {
                const oVfs = new capi.sqlite3_vfs(pVfs);
                rc.push(wasm.cstrToJs(oVfs.$zName));
                pVfs = oVfs.$pNext;
                oVfs.dispose();
              }
              return rc;
            };

            capi.sqlite3_js_db_export = function (pDb, schema = 0) {
              pDb = wasm.xWrap.testConvertArg('sqlite3*', pDb);
              if (!pDb) toss3('Invalid sqlite3* argument.');
              if (!wasm.bigIntEnabled) toss3('BigInt64 support is not enabled.');
              const scope = wasm.scopedAllocPush();
              let pOut;
              try {
                const pSize = wasm.scopedAlloc(8 + wasm.ptrSizeof);
                const ppOut = pSize + 8;

                const zSchema = schema
                  ? wasm.isPtr(schema)
                    ? schema
                    : wasm.scopedAllocCString('' + schema)
                  : 0;
                let rc = wasm.exports.sqlite3_wasm_db_serialize(
                  pDb,
                  zSchema,
                  ppOut,
                  pSize,
                  0,
                );
                if (rc) {
                  toss3(
                    'Database serialization failed with code',
                    sqlite3.capi.sqlite3_js_rc_str(rc),
                  );
                }
                pOut = wasm.peekPtr(ppOut);
                const nOut = wasm.peek(pSize, 'i64');
                rc = nOut
                  ? wasm.heap8u().slice(pOut, pOut + Number(nOut))
                  : new Uint8Array();
                return rc;
              } finally {
                if (pOut) wasm.exports.sqlite3_free(pOut);
                wasm.scopedAllocPop(scope);
              }
            };

            capi.sqlite3_js_db_vfs = (dbPointer, dbName = 0) =>
              wasm.sqlite3_wasm_db_vfs(dbPointer, dbName);

            capi.sqlite3_js_aggregate_context = (pCtx, n) => {
              return (
                capi.sqlite3_aggregate_context(pCtx, n) ||
                (n
                  ? WasmAllocError.toss(
                      'Cannot allocate',
                      n,
                      'bytes for sqlite3_aggregate_context()',
                    )
                  : 0)
              );
            };

            capi.sqlite3_js_posix_create_file = function (filename, data, dataLen) {
              let pData;
              if (data && wasm.isPtr(data)) {
                pData = data;
              } else if (
                data instanceof ArrayBuffer ||
                data instanceof Uint8Array
              ) {
                pData = wasm.allocFromTypedArray(data);
                if (arguments.length < 3 || !util.isInt32(dataLen) || dataLen < 0) {
                  dataLen = data.byteLength;
                }
              } else {
                SQLite3Error.toss(
                  'Invalid 2nd argument for sqlite3_js_posix_create_file().',
                );
              }
              try {
                if (!util.isInt32(dataLen) || dataLen < 0) {
                  SQLite3Error.toss(
                    'Invalid 3rd argument for sqlite3_js_posix_create_file().',
                  );
                }
                const rc = wasm.sqlite3_wasm_posix_create_file(
                  filename,
                  pData,
                  dataLen,
                );
                if (rc)
                  SQLite3Error.toss(
                    'Creation of file failed with sqlite3 result code',
                    capi.sqlite3_js_rc_str(rc),
                  );
              } finally {
                wasm.dealloc(pData);
              }
            };

            capi.sqlite3_js_vfs_create_file = function (
              vfs,
              filename,
              data,
              dataLen,
            ) {
              config.warn(
                'sqlite3_js_vfs_create_file() is deprecated and',
                'should be avoided because it can lead to C-level crashes.',
                'See its documentation for alternative options.',
              );
              let pData;
              if (data) {
                if (wasm.isPtr(data)) {
                  pData = data;
                } else if (data instanceof ArrayBuffer) {
                  data = new Uint8Array(data);
                }
                if (data instanceof Uint8Array) {
                  pData = wasm.allocFromTypedArray(data);
                  if (
                    arguments.length < 4 ||
                    !util.isInt32(dataLen) ||
                    dataLen < 0
                  ) {
                    dataLen = data.byteLength;
                  }
                } else {
                  SQLite3Error.toss(
                    'Invalid 3rd argument type for sqlite3_js_vfs_create_file().',
                  );
                }
              } else {
                pData = 0;
              }
              if (!util.isInt32(dataLen) || dataLen < 0) {
                wasm.dealloc(pData);
                SQLite3Error.toss(
                  'Invalid 4th argument for sqlite3_js_vfs_create_file().',
                );
              }
              try {
                const rc = wasm.sqlite3_wasm_vfs_create_file(
                  vfs,
                  filename,
                  pData,
                  dataLen,
                );
                if (rc)
                  SQLite3Error.toss(
                    'Creation of file failed with sqlite3 result code',
                    capi.sqlite3_js_rc_str(rc),
                  );
              } finally {
                wasm.dealloc(pData);
              }
            };

            capi.sqlite3_js_sql_to_string = (sql) => {
              if ('string' === typeof sql) {
                return sql;
              }
              const x = flexibleString(v);
              return x === v ? undefined : x;
            };

            if (util.isUIThread()) {
              const __kvvfsInfo = function (which) {
                const rc = Object.create(null);
                rc.prefix = 'kvvfs-' + which;
                rc.stores = [];
                if ('session' === which || '' === which)
                  rc.stores.push(globalThis.sessionStorage);
                if ('local' === which || '' === which)
                  rc.stores.push(globalThis.localStorage);
                return rc;
              };

              capi.sqlite3_js_kvvfs_clear = function (which = '') {
                let rc = 0;
                const kvinfo = __kvvfsInfo(which);
                kvinfo.stores.forEach((s) => {
                  const toRm = [];
                  let i;
                  for (i = 0; i < s.length; ++i) {
                    const k = s.key(i);
                    if (k.startsWith(kvinfo.prefix)) toRm.push(k);
                  }
                  toRm.forEach((kk) => s.removeItem(kk));
                  rc += toRm.length;
                });
                return rc;
              };

              capi.sqlite3_js_kvvfs_size = function (which = '') {
                let sz = 0;
                const kvinfo = __kvvfsInfo(which);
                kvinfo.stores.forEach((s) => {
                  let i;
                  for (i = 0; i < s.length; ++i) {
                    const k = s.key(i);
                    if (k.startsWith(kvinfo.prefix)) {
                      sz += k.length;
                      sz += s.getItem(k).length;
                    }
                  }
                });
                return sz * 2;
              };
            }

            capi.sqlite3_db_config = function (pDb, op, ...args) {
              if (!this.s) {
                this.s = wasm.xWrap('sqlite3_wasm_db_config_s', 'int', [
                  'sqlite3*',
                  'int',
                  'string:static',
                ]);
                this.pii = wasm.xWrap('sqlite3_wasm_db_config_pii', 'int', [
                  'sqlite3*',
                  'int',
                  '*',
                  'int',
                  'int',
                ]);
                this.ip = wasm.xWrap('sqlite3_wasm_db_config_ip', 'int', [
                  'sqlite3*',
                  'int',
                  'int',
                  '*',
                ]);
              }
              switch (op) {
                case capi.SQLITE_DBCONFIG_ENABLE_FKEY:
                case capi.SQLITE_DBCONFIG_ENABLE_TRIGGER:
                case capi.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER:
                case capi.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION:
                case capi.SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE:
                case capi.SQLITE_DBCONFIG_ENABLE_QPSG:
                case capi.SQLITE_DBCONFIG_TRIGGER_EQP:
                case capi.SQLITE_DBCONFIG_RESET_DATABASE:
                case capi.SQLITE_DBCONFIG_DEFENSIVE:
                case capi.SQLITE_DBCONFIG_WRITABLE_SCHEMA:
                case capi.SQLITE_DBCONFIG_LEGACY_ALTER_TABLE:
                case capi.SQLITE_DBCONFIG_DQS_DML:
                case capi.SQLITE_DBCONFIG_DQS_DDL:
                case capi.SQLITE_DBCONFIG_ENABLE_VIEW:
                case capi.SQLITE_DBCONFIG_LEGACY_FILE_FORMAT:
                case capi.SQLITE_DBCONFIG_TRUSTED_SCHEMA:
                case capi.SQLITE_DBCONFIG_STMT_SCANSTATUS:
                case capi.SQLITE_DBCONFIG_REVERSE_SCANORDER:
                  return this.ip(pDb, op, args[0], args[1] || 0);
                case capi.SQLITE_DBCONFIG_LOOKASIDE:
                  return this.pii(pDb, op, args[0], args[1], args[2]);
                case capi.SQLITE_DBCONFIG_MAINDBNAME:
                  return this.s(pDb, op, args[0]);
                default:
                  return capi.SQLITE_MISUSE;
              }
            }.bind(Object.create(null));

            capi.sqlite3_value_to_js = function (
              pVal,
              throwIfCannotConvert = true,
            ) {
              let arg;
              const valType = capi.sqlite3_value_type(pVal);
              switch (valType) {
                case capi.SQLITE_INTEGER:
                  if (wasm.bigIntEnabled) {
                    arg = capi.sqlite3_value_int64(pVal);
                    if (util.bigIntFitsDouble(arg)) arg = Number(arg);
                  } else arg = capi.sqlite3_value_double(pVal);
                  break;
                case capi.SQLITE_FLOAT:
                  arg = capi.sqlite3_value_double(pVal);
                  break;
                case capi.SQLITE_TEXT:
                  arg = capi.sqlite3_value_text(pVal);
                  break;
                case capi.SQLITE_BLOB: {
                  const n = capi.sqlite3_value_bytes(pVal);
                  const pBlob = capi.sqlite3_value_blob(pVal);
                  if (n && !pBlob)
                    sqlite3.WasmAllocError.toss(
                      'Cannot allocate memory for blob argument of',
                      n,
                      'byte(s)',
                    );
                  arg = n ? wasm.heap8u().slice(pBlob, pBlob + Number(n)) : null;
                  break;
                }
                case capi.SQLITE_NULL:
                  arg = null;
                  break;
                default:
                  if (throwIfCannotConvert) {
                    toss3(
                      capi.SQLITE_MISMATCH,
                      'Unhandled sqlite3_value_type():',
                      valType,
                    );
                  }
                  arg = undefined;
              }
              return arg;
            };

            capi.sqlite3_values_to_js = function (
              argc,
              pArgv,
              throwIfCannotConvert = true,
            ) {
              let i;
              const tgt = [];
              for (i = 0; i < argc; ++i) {
                tgt.push(
                  capi.sqlite3_value_to_js(
                    wasm.peekPtr(pArgv + wasm.ptrSizeof * i),
                    throwIfCannotConvert,
                  ),
                );
              }
              return tgt;
            };

            capi.sqlite3_result_error_js = function (pCtx, e) {
              if (e instanceof WasmAllocError) {
                capi.sqlite3_result_error_nomem(pCtx);
              } else {
                capi.sqlite3_result_error(pCtx, '' + e, -1);
              }
            };

            capi.sqlite3_result_js = function (pCtx, val) {
              if (val instanceof Error) {
                capi.sqlite3_result_error_js(pCtx, val);
                return;
              }
              try {
                switch (typeof val) {
                  case 'undefined':
                    break;
                  case 'boolean':
                    capi.sqlite3_result_int(pCtx, val ? 1 : 0);
                    break;
                  case 'bigint':
                    if (util.bigIntFits32(val)) {
                      capi.sqlite3_result_int(pCtx, Number(val));
                    } else if (util.bigIntFitsDouble(val)) {
                      capi.sqlite3_result_double(pCtx, Number(val));
                    } else if (wasm.bigIntEnabled) {
                      if (util.bigIntFits64(val))
                        capi.sqlite3_result_int64(pCtx, val);
                      else
                        toss3(
                          'BigInt value',
                          val.toString(),
                          'is too BigInt for int64.',
                        );
                    } else {
                      toss3('BigInt value', val.toString(), 'is too BigInt.');
                    }
                    break;
                  case 'number': {
                    let f;
                    if (util.isInt32(val)) {
                      f = capi.sqlite3_result_int;
                    } else if (
                      wasm.bigIntEnabled &&
                      Number.isInteger(val) &&
                      util.bigIntFits64(BigInt(val))
                    ) {
                      f = capi.sqlite3_result_int64;
                    } else {
                      f = capi.sqlite3_result_double;
                    }
                    f(pCtx, val);
                    break;
                  }
                  case 'string': {
                    const [p, n] = wasm.allocCString(val, true);
                    capi.sqlite3_result_text(pCtx, p, n, capi.SQLITE_WASM_DEALLOC);
                    break;
                  }
                  case 'object':
                    if (null === val) {
                      capi.sqlite3_result_null(pCtx);
                      break;
                    } else if (util.isBindableTypedArray(val)) {
                      const pBlob = wasm.allocFromTypedArray(val);
                      capi.sqlite3_result_blob(
                        pCtx,
                        pBlob,
                        val.byteLength,
                        capi.SQLITE_WASM_DEALLOC,
                      );
                      break;
                    }

                  default:
                    toss3(
                      "Don't not how to handle this UDF result value:",
                      typeof val,
                      val,
                    );
                }
              } catch (e) {
                capi.sqlite3_result_error_js(pCtx, e);
              }
            };

            capi.sqlite3_column_js = function (
              pStmt,
              iCol,
              throwIfCannotConvert = true,
            ) {
              const v = capi.sqlite3_column_value(pStmt, iCol);
              return 0 === v
                ? undefined
                : capi.sqlite3_value_to_js(v, throwIfCannotConvert);
            };

            const __newOldValue = function (pObj, iCol, impl) {
              impl = capi[impl];
              if (!this.ptr) this.ptr = wasm.allocPtr();
              else wasm.pokePtr(this.ptr, 0);
              const rc = impl(pObj, iCol, this.ptr);
              if (rc)
                return SQLite3Error.toss(
                  rc,
                  arguments[2] + '() failed with code ' + rc,
                );
              const pv = wasm.peekPtr(this.ptr);
              return pv ? capi.sqlite3_value_to_js(pv, true) : undefined;
            }.bind(Object.create(null));

            capi.sqlite3_preupdate_new_js = (pDb, iCol) =>
              __newOldValue(pDb, iCol, 'sqlite3_preupdate_new');

            capi.sqlite3_preupdate_old_js = (pDb, iCol) =>
              __newOldValue(pDb, iCol, 'sqlite3_preupdate_old');

            capi.sqlite3changeset_new_js = (pChangesetIter, iCol) =>
              __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_new');

            capi.sqlite3changeset_old_js = (pChangesetIter, iCol) =>
              __newOldValue(pChangesetIter, iCol, 'sqlite3changeset_old');

            const sqlite3 = {
              WasmAllocError: WasmAllocError,
              SQLite3Error: SQLite3Error,
              capi,
              util,
              wasm,
              config,

              version: Object.create(null),

              client: undefined,

              asyncPostInit: async function ff() {
                if (ff.isReady instanceof Promise) return ff.isReady;
                let lia = sqlite3ApiBootstrap.initializersAsync;
                delete sqlite3ApiBootstrap.initializersAsync;
                const postInit = async () => {
                  if (!sqlite3.__isUnderTest) {
                    delete sqlite3.util;

                    delete sqlite3.StructBinder;
                  }
                  return sqlite3;
                };
                const catcher = (e) => {
                  config.error('an async sqlite3 initializer failed:', e);
                  throw e;
                };
                if (!lia || !lia.length) {
                  return (ff.isReady = postInit().catch(catcher));
                }
                lia = lia.map((f) => {
                  return f instanceof Function ? async (x) => f(sqlite3) : f;
                });
                lia.push(postInit);
                let p = Promise.resolve(sqlite3);
                while (lia.length) p = p.then(lia.shift());
                return (ff.isReady = p.catch(catcher));
              },

              scriptInfo: undefined,
            };
            try {
              sqlite3ApiBootstrap.initializers.forEach((f) => {
                f(sqlite3);
              });
            } catch (e) {
              console.error('sqlite3 bootstrap initializer threw:', e);
              throw e;
            }
            delete sqlite3ApiBootstrap.initializers;
            sqlite3ApiBootstrap.sqlite3 = sqlite3;
            return sqlite3;
          };

          globalThis.sqlite3ApiBootstrap.initializers = [];

          globalThis.sqlite3ApiBootstrap.initializersAsync = [];

          globalThis.sqlite3ApiBootstrap.defaultConfig = Object.create(null);

          globalThis.sqlite3ApiBootstrap.sqlite3 = undefined;

          globalThis.WhWasmUtilInstaller = function (target) {
            if (undefined === target.bigIntEnabled) {
              target.bigIntEnabled = !!globalThis['BigInt64Array'];
            }

            const toss = (...args) => {
              throw new Error(args.join(' '));
            };

            if (!target.exports) {
              Object.defineProperty(target, 'exports', {
                enumerable: true,
                configurable: true,
                get: () => target.instance && target.instance.exports,
              });
            }

            const ptrIR = target.pointerIR || 'i32';
            const ptrSizeof = (target.ptrSizeof =
              'i32' === ptrIR
                ? 4
                : 'i64' === ptrIR
                  ? 8
                  : toss('Unhandled ptrSizeof:', ptrIR));

            const cache = Object.create(null);

            cache.heapSize = 0;

            cache.memory = null;

            cache.freeFuncIndexes = [];

            cache.scopedAlloc = [];

            cache.utf8Decoder = new TextDecoder();
            cache.utf8Encoder = new TextEncoder('utf-8');

            target.sizeofIR = (n) => {
              switch (n) {
                case 'i8':
                  return 1;
                case 'i16':
                  return 2;
                case 'i32':
                case 'f32':
                case 'float':
                  return 4;
                case 'i64':
                case 'f64':
                case 'double':
                  return 8;
                case '*':
                  return ptrSizeof;
                default:
                  return ('' + n).endsWith('*') ? ptrSizeof : undefined;
              }
            };

            const heapWrappers = function () {
              if (!cache.memory) {
                cache.memory =
                  target.memory instanceof WebAssembly.Memory
                    ? target.memory
                    : target.exports.memory;
              } else if (cache.heapSize === cache.memory.buffer.byteLength) {
                return cache;
              }

              const b = cache.memory.buffer;
              cache.HEAP8 = new Int8Array(b);
              cache.HEAP8U = new Uint8Array(b);
              cache.HEAP16 = new Int16Array(b);
              cache.HEAP16U = new Uint16Array(b);
              cache.HEAP32 = new Int32Array(b);
              cache.HEAP32U = new Uint32Array(b);
              if (target.bigIntEnabled) {
                cache.HEAP64 = new BigInt64Array(b);
                cache.HEAP64U = new BigUint64Array(b);
              }
              cache.HEAP32F = new Float32Array(b);
              cache.HEAP64F = new Float64Array(b);
              cache.heapSize = b.byteLength;
              return cache;
            };

            target.heap8 = () => heapWrappers().HEAP8;

            target.heap8u = () => heapWrappers().HEAP8U;

            target.heap16 = () => heapWrappers().HEAP16;

            target.heap16u = () => heapWrappers().HEAP16U;

            target.heap32 = () => heapWrappers().HEAP32;

            target.heap32u = () => heapWrappers().HEAP32U;

            target.heapForSize = function (n, unsigned = true) {
              const c =
                cache.memory && cache.heapSize === cache.memory.buffer.byteLength
                  ? cache
                  : heapWrappers();
              switch (n) {
                case Int8Array:
                  return c.HEAP8;
                case Uint8Array:
                  return c.HEAP8U;
                case Int16Array:
                  return c.HEAP16;
                case Uint16Array:
                  return c.HEAP16U;
                case Int32Array:
                  return c.HEAP32;
                case Uint32Array:
                  return c.HEAP32U;
                case 8:
                  return unsigned ? c.HEAP8U : c.HEAP8;
                case 16:
                  return unsigned ? c.HEAP16U : c.HEAP16;
                case 32:
                  return unsigned ? c.HEAP32U : c.HEAP32;
                case 64:
                  if (c.HEAP64) return unsigned ? c.HEAP64U : c.HEAP64;
                  break;
                default:
                  if (target.bigIntEnabled) {
                    if (n === globalThis['BigUint64Array']) return c.HEAP64U;
                    else if (n === globalThis['BigInt64Array']) return c.HEAP64;
                    break;
                  }
              }
              toss(
                'Invalid heapForSize() size: expecting 8, 16, 32,',
                'or (if BigInt is enabled) 64.',
              );
            };

            target.functionTable = function () {
              return target.exports.__indirect_function_table;
            };

            target.functionEntry = function (fptr) {
              const ft = target.functionTable();
              return fptr < ft.length ? ft.get(fptr) : undefined;
            };

            target.jsFuncToWasm = function f(func, sig) {
              if (!f._) {
                f._ = {
                  sigTypes: Object.assign(Object.create(null), {
                    i: 'i32',
                    p: 'i32',
                    P: 'i32',
                    s: 'i32',
                    j: 'i64',
                    f: 'f32',
                    d: 'f64',
                  }),

                  typeCodes: Object.assign(Object.create(null), {
                    f64: 0x7c,
                    f32: 0x7d,
                    i64: 0x7e,
                    i32: 0x7f,
                  }),

                  uleb128Encode: function (tgt, method, n) {
                    if (n < 128) tgt[method](n);
                    else tgt[method](n % 128 | 128, n >> 7);
                  },

                  rxJSig: /^(\w)\((\w*)\)$/,

                  sigParams: function (sig) {
                    const m = f._.rxJSig.exec(sig);
                    return m ? m[2] : sig.substr(1);
                  },

                  letterType: (x) =>
                    f._.sigTypes[x] || toss('Invalid signature letter:', x),

                  pushSigType: (dest, letter) =>
                    dest.push(f._.typeCodes[f._.letterType(letter)]),
                };
              }
              if ('string' === typeof func) {
                const x = sig;
                sig = func;
                func = x;
              }
              const sigParams = f._.sigParams(sig);
              const wasmCode = [0x01, 0x60];
              f._.uleb128Encode(wasmCode, 'push', sigParams.length);
              for (const x of sigParams) f._.pushSigType(wasmCode, x);
              if ('v' === sig[0]) wasmCode.push(0);
              else {
                wasmCode.push(1);
                f._.pushSigType(wasmCode, sig[0]);
              }
              f._.uleb128Encode(wasmCode, 'unshift', wasmCode.length);
              wasmCode.unshift(
                0x00,
                0x61,
                0x73,
                0x6d,
                0x01,
                0x00,
                0x00,
                0x00,
                0x01,
              );
              wasmCode.push(
                0x02,
                0x07,

                0x01,
                0x01,
                0x65,
                0x01,
                0x66,
                0x00,
                0x00,
                0x07,
                0x05,

                0x01,
                0x01,
                0x66,
                0x00,
                0x00,
              );
              return new WebAssembly.Instance(
                new WebAssembly.Module(new Uint8Array(wasmCode)),
                {
                  e: { f: func },
                },
              ).exports['f'];
            };

            const __installFunction = function f(func, sig, scoped) {
              if (scoped && !cache.scopedAlloc.length) {
                toss('No scopedAllocPush() scope is active.');
              }
              if ('string' === typeof func) {
                const x = sig;
                sig = func;
                func = x;
              }
              if ('string' !== typeof sig || !(func instanceof Function)) {
                toss(
                  'Invalid arguments: expecting (function,signature) ' +
                    'or (signature,function).',
                );
              }
              const ft = target.functionTable();
              const oldLen = ft.length;
              let ptr;
              while (cache.freeFuncIndexes.length) {
                ptr = cache.freeFuncIndexes.pop();
                if (ft.get(ptr)) {
                  ptr = null;
                  continue;
                } else {
                  break;
                }
              }
              if (!ptr) {
                ptr = oldLen;
                ft.grow(1);
              }
              try {
                ft.set(ptr, func);
                if (scoped) {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
                }
                return ptr;
              } catch (e) {
                if (!(e instanceof TypeError)) {
                  if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
                  throw e;
                }
              }

              try {
                const fptr = target.jsFuncToWasm(func, sig);
                ft.set(ptr, fptr);
                if (scoped) {
                  cache.scopedAlloc[cache.scopedAlloc.length - 1].push(ptr);
                }
              } catch (e) {
                if (ptr === oldLen) cache.freeFuncIndexes.push(oldLen);
                throw e;
              }
              return ptr;
            };

            target.installFunction = (func, sig) =>
              __installFunction(func, sig, false);

            target.scopedInstallFunction = (func, sig) =>
              __installFunction(func, sig, true);

            target.uninstallFunction = function (ptr) {
              if (!ptr && 0 !== ptr) return undefined;
              const fi = cache.freeFuncIndexes;
              const ft = target.functionTable();
              fi.push(ptr);
              const rc = ft.get(ptr);
              ft.set(ptr, null);
              return rc;
            };

            target.peek = function f(ptr, type = 'i8') {
              if (type.endsWith('*')) type = ptrIR;
              const c =
                cache.memory && cache.heapSize === cache.memory.buffer.byteLength
                  ? cache
                  : heapWrappers();
              const list = Array.isArray(ptr) ? [] : undefined;
              let rc;
              do {
                if (list) ptr = arguments[0].shift();
                switch (type) {
                  case 'i1':
                  case 'i8':
                    rc = c.HEAP8[ptr >> 0];
                    break;
                  case 'i16':
                    rc = c.HEAP16[ptr >> 1];
                    break;
                  case 'i32':
                    rc = c.HEAP32[ptr >> 2];
                    break;
                  case 'float':
                  case 'f32':
                    rc = c.HEAP32F[ptr >> 2];
                    break;
                  case 'double':
                  case 'f64':
                    rc = Number(c.HEAP64F[ptr >> 3]);
                    break;
                  case 'i64':
                    if (target.bigIntEnabled) {
                      rc = BigInt(c.HEAP64[ptr >> 3]);
                      break;
                    }

                  default:
                    toss('Invalid type for peek():', type);
                }
                if (list) list.push(rc);
              } while (list && arguments[0].length);
              return list || rc;
            };

            target.poke = function (ptr, value, type = 'i8') {
              if (type.endsWith('*')) type = ptrIR;
              const c =
                cache.memory && cache.heapSize === cache.memory.buffer.byteLength
                  ? cache
                  : heapWrappers();
              for (const p of Array.isArray(ptr) ? ptr : [ptr]) {
                switch (type) {
                  case 'i1':
                  case 'i8':
                    c.HEAP8[p >> 0] = value;
                    continue;
                  case 'i16':
                    c.HEAP16[p >> 1] = value;
                    continue;
                  case 'i32':
                    c.HEAP32[p >> 2] = value;
                    continue;
                  case 'float':
                  case 'f32':
                    c.HEAP32F[p >> 2] = value;
                    continue;
                  case 'double':
                  case 'f64':
                    c.HEAP64F[p >> 3] = value;
                    continue;
                  case 'i64':
                    if (c.HEAP64) {
                      c.HEAP64[p >> 3] = BigInt(value);
                      continue;
                    }

                  default:
                    toss('Invalid type for poke(): ' + type);
                }
              }
              return this;
            };

            target.peekPtr = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, ptrIR);

            target.pokePtr = (ptr, value = 0) => target.poke(ptr, value, ptrIR);

            target.peek8 = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'i8');

            target.poke8 = (ptr, value) => target.poke(ptr, value, 'i8');

            target.peek16 = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'i16');

            target.poke16 = (ptr, value) => target.poke(ptr, value, 'i16');

            target.peek32 = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'i32');

            target.poke32 = (ptr, value) => target.poke(ptr, value, 'i32');

            target.peek64 = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'i64');

            target.poke64 = (ptr, value) => target.poke(ptr, value, 'i64');

            target.peek32f = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'f32');

            target.poke32f = (ptr, value) => target.poke(ptr, value, 'f32');

            target.peek64f = (...ptr) =>
              target.peek(1 === ptr.length ? ptr[0] : ptr, 'f64');

            target.poke64f = (ptr, value) => target.poke(ptr, value, 'f64');

            target.getMemValue = target.peek;

            target.getPtrValue = target.peekPtr;

            target.setMemValue = target.poke;

            target.setPtrValue = target.pokePtr;

            target.isPtr32 = (ptr) =>
              'number' === typeof ptr && ptr === (ptr | 0) && ptr >= 0;

            target.isPtr = target.isPtr32;

            target.cstrlen = function (ptr) {
              if (!ptr || !target.isPtr(ptr)) return null;
              const h = heapWrappers().HEAP8U;
              let pos = ptr;
              for (; h[pos] !== 0; ++pos) {}
              return pos - ptr;
            };

            const __SAB =
              'undefined' === typeof SharedArrayBuffer
                ? function () {}
                : SharedArrayBuffer;
            const __utf8Decode = function (arrayBuffer, begin, end) {
              return cache.utf8Decoder.decode(
                arrayBuffer.buffer instanceof __SAB
                  ? arrayBuffer.slice(begin, end)
                  : arrayBuffer.subarray(begin, end),
              );
            };

            target.cstrToJs = function (ptr) {
              const n = target.cstrlen(ptr);
              return n
                ? __utf8Decode(heapWrappers().HEAP8U, ptr, ptr + n)
                : null === n
                  ? n
                  : '';
            };

            target.jstrlen = function (str) {
              if ('string' !== typeof str) return null;
              const n = str.length;
              let len = 0;
              for (let i = 0; i < n; ++i) {
                let u = str.charCodeAt(i);
                if (u >= 0xd800 && u <= 0xdfff) {
                  u =
                    (0x10000 + ((u & 0x3ff) << 10)) | (str.charCodeAt(++i) & 0x3ff);
                }
                if (u <= 0x7f) ++len;
                else if (u <= 0x7ff) len += 2;
                else if (u <= 0xffff) len += 3;
                else len += 4;
              }
              return len;
            };

            target.jstrcpy = function (
              jstr,
              tgt,
              offset = 0,
              maxBytes = -1,
              addNul = true,
            ) {
              if (
                !tgt ||
                (!(tgt instanceof Int8Array) && !(tgt instanceof Uint8Array))
              ) {
                toss('jstrcpy() target must be an Int8Array or Uint8Array.');
              }
              if (maxBytes < 0) maxBytes = tgt.length - offset;
              if (!(maxBytes > 0) || !(offset >= 0)) return 0;
              let i = 0,
                max = jstr.length;
              const begin = offset,
                end = offset + maxBytes - (addNul ? 1 : 0);
              for (; i < max && offset < end; ++i) {
                let u = jstr.charCodeAt(i);
                if (u >= 0xd800 && u <= 0xdfff) {
                  u =
                    (0x10000 + ((u & 0x3ff) << 10)) |
                    (jstr.charCodeAt(++i) & 0x3ff);
                }
                if (u <= 0x7f) {
                  if (offset >= end) break;
                  tgt[offset++] = u;
                } else if (u <= 0x7ff) {
                  if (offset + 1 >= end) break;
                  tgt[offset++] = 0xc0 | (u >> 6);
                  tgt[offset++] = 0x80 | (u & 0x3f);
                } else if (u <= 0xffff) {
                  if (offset + 2 >= end) break;
                  tgt[offset++] = 0xe0 | (u >> 12);
                  tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
                  tgt[offset++] = 0x80 | (u & 0x3f);
                } else {
                  if (offset + 3 >= end) break;
                  tgt[offset++] = 0xf0 | (u >> 18);
                  tgt[offset++] = 0x80 | ((u >> 12) & 0x3f);
                  tgt[offset++] = 0x80 | ((u >> 6) & 0x3f);
                  tgt[offset++] = 0x80 | (u & 0x3f);
                }
              }
              if (addNul) tgt[offset++] = 0;
              return offset - begin;
            };

            target.cstrncpy = function (tgtPtr, srcPtr, n) {
              if (!tgtPtr || !srcPtr)
                toss('cstrncpy() does not accept NULL strings.');
              if (n < 0) n = target.cstrlen(strPtr) + 1;
              else if (!(n > 0)) return 0;
              const heap = target.heap8u();
              let i = 0,
                ch;
              for (; i < n && (ch = heap[srcPtr + i]); ++i) {
                heap[tgtPtr + i] = ch;
              }
              if (i < n) heap[tgtPtr + i++] = 0;
              return i;
            };

            target.jstrToUintArray = (str, addNul = false) => {
              return cache.utf8Encoder.encode(addNul ? str + '\0' : str);
            };

            const __affirmAlloc = (obj, funcName) => {
              if (
                !(obj.alloc instanceof Function) ||
                !(obj.dealloc instanceof Function)
              ) {
                toss(
                  'Object is missing alloc() and/or dealloc() function(s)',
                  'required by',
                  funcName + '().',
                );
              }
            };

            const __allocCStr = function (
              jstr,
              returnWithLength,
              allocator,
              funcName,
            ) {
              __affirmAlloc(target, funcName);
              if ('string' !== typeof jstr) return null;
              {
                const u = cache.utf8Encoder.encode(jstr),
                  ptr = allocator(u.length + 1),
                  heap = heapWrappers().HEAP8U;
                heap.set(u, ptr);
                heap[ptr + u.length] = 0;
                return returnWithLength ? [ptr, u.length] : ptr;
              }
            };

            target.allocCString = (jstr, returnWithLength = false) =>
              __allocCStr(jstr, returnWithLength, target.alloc, 'allocCString()');

            target.scopedAllocPush = function () {
              __affirmAlloc(target, 'scopedAllocPush');
              const a = [];
              cache.scopedAlloc.push(a);
              return a;
            };

            target.scopedAllocPop = function (state) {
              __affirmAlloc(target, 'scopedAllocPop');
              const n = arguments.length
                ? cache.scopedAlloc.indexOf(state)
                : cache.scopedAlloc.length - 1;
              if (n < 0) toss('Invalid state object for scopedAllocPop().');
              if (0 === arguments.length) state = cache.scopedAlloc[n];
              cache.scopedAlloc.splice(n, 1);
              for (let p; (p = state.pop()); ) {
                if (target.functionEntry(p)) {
                  target.uninstallFunction(p);
                } else target.dealloc(p);
              }
            };

            target.scopedAlloc = function (n) {
              if (!cache.scopedAlloc.length) {
                toss('No scopedAllocPush() scope is active.');
              }
              const p = target.alloc(n);
              cache.scopedAlloc[cache.scopedAlloc.length - 1].push(p);
              return p;
            };

            Object.defineProperty(target.scopedAlloc, 'level', {
              configurable: false,
              enumerable: false,
              get: () => cache.scopedAlloc.length,
              set: () => toss("The 'active' property is read-only."),
            });

            target.scopedAllocCString = (jstr, returnWithLength = false) =>
              __allocCStr(
                jstr,
                returnWithLength,
                target.scopedAlloc,
                'scopedAllocCString()',
              );

            const __allocMainArgv = function (isScoped, list) {
              const pList = target[isScoped ? 'scopedAlloc' : 'alloc'](
                (list.length + 1) * target.ptrSizeof,
              );
              let i = 0;
              list.forEach((e) => {
                target.pokePtr(
                  pList + target.ptrSizeof * i++,
                  target[isScoped ? 'scopedAllocCString' : 'allocCString']('' + e),
                );
              });
              target.pokePtr(pList + target.ptrSizeof * i, 0);
              return pList;
            };

            target.scopedAllocMainArgv = (list) => __allocMainArgv(true, list);

            target.allocMainArgv = (list) => __allocMainArgv(false, list);

            target.cArgvToJs = (argc, pArgv) => {
              const list = [];
              for (let i = 0; i < argc; ++i) {
                const arg = target.peekPtr(pArgv + target.ptrSizeof * i);
                list.push(arg ? target.cstrToJs(arg) : null);
              }
              return list;
            };

            target.scopedAllocCall = function (func) {
              target.scopedAllocPush();
              try {
                return func();
              } finally {
                target.scopedAllocPop();
              }
            };

            const __allocPtr = function (howMany, safePtrSize, method) {
              __affirmAlloc(target, method);
              const pIr = safePtrSize ? 'i64' : ptrIR;
              let m = target[method](howMany * (safePtrSize ? 8 : ptrSizeof));
              target.poke(m, 0, pIr);
              if (1 === howMany) {
                return m;
              }
              const a = [m];
              for (let i = 1; i < howMany; ++i) {
                m += safePtrSize ? 8 : ptrSizeof;
                a[i] = m;
                target.poke(m, 0, pIr);
              }
              return a;
            };

            target.allocPtr = (howMany = 1, safePtrSize = true) =>
              __allocPtr(howMany, safePtrSize, 'alloc');

            target.scopedAllocPtr = (howMany = 1, safePtrSize = true) =>
              __allocPtr(howMany, safePtrSize, 'scopedAlloc');

            target.xGet = function (name) {
              return (
                target.exports[name] || toss('Cannot find exported symbol:', name)
              );
            };

            const __argcMismatch = (f, n) =>
              toss(f + '() requires', n, 'argument(s).');

            target.xCall = function (fname, ...args) {
              const f = target.xGet(fname);
              if (!(f instanceof Function))
                toss('Exported symbol', fname, 'is not a function.');
              if (f.length !== args.length) __argcMismatch(fname, f.length);
              return 2 === arguments.length && Array.isArray(arguments[1])
                ? f.apply(null, arguments[1])
                : f.apply(null, args);
            };

            cache.xWrap = Object.create(null);
            cache.xWrap.convert = Object.create(null);

            cache.xWrap.convert.arg = new Map();

            cache.xWrap.convert.result = new Map();
            const xArg = cache.xWrap.convert.arg,
              xResult = cache.xWrap.convert.result;

            if (target.bigIntEnabled) {
              xArg.set('i64', (i) => BigInt(i));
            }
            const __xArgPtr =
              'i32' === ptrIR ? (i) => i | 0 : (i) => BigInt(i) | BigInt(0);
            xArg
              .set('i32', __xArgPtr)
              .set('i16', (i) => (i | 0) & 0xffff)
              .set('i8', (i) => (i | 0) & 0xff)
              .set('f32', (i) => Number(i).valueOf())
              .set('float', xArg.get('f32'))
              .set('f64', xArg.get('f32'))
              .set('double', xArg.get('f64'))
              .set('int', xArg.get('i32'))
              .set('null', (i) => i)
              .set(null, xArg.get('null'))
              .set('**', __xArgPtr)
              .set('*', __xArgPtr);
            xResult
              .set('*', __xArgPtr)
              .set('pointer', __xArgPtr)
              .set('number', (v) => Number(v))
              .set('void', (v) => undefined)
              .set('null', (v) => v)
              .set(null, xResult.get('null'));

            {
              const copyToResult = [
                'i8',
                'i16',
                'i32',
                'int',
                'f32',
                'float',
                'f64',
                'double',
              ];
              if (target.bigIntEnabled) copyToResult.push('i64');
              const adaptPtr = xArg.get(ptrIR);
              for (const t of copyToResult) {
                xArg.set(t + '*', adaptPtr);
                xResult.set(t + '*', adaptPtr);
                xResult.set(t, xArg.get(t) || toss('Missing arg converter:', t));
              }
            }

            const __xArgString = function (v) {
              if ('string' === typeof v) return target.scopedAllocCString(v);
              return v ? __xArgPtr(v) : null;
            };
            xArg
              .set('string', __xArgString)
              .set('utf8', __xArgString)
              .set('pointer', __xArgString);

            xResult
              .set('string', (i) => target.cstrToJs(i))
              .set('utf8', xResult.get('string'))
              .set('string:dealloc', (i) => {
                try {
                  return i ? target.cstrToJs(i) : null;
                } finally {
                  target.dealloc(i);
                }
              })
              .set('utf8:dealloc', xResult.get('string:dealloc'))
              .set('json', (i) => JSON.parse(target.cstrToJs(i)))
              .set('json:dealloc', (i) => {
                try {
                  return i ? JSON.parse(target.cstrToJs(i)) : null;
                } finally {
                  target.dealloc(i);
                }
              });

            const AbstractArgAdapter = class {
              constructor(opt) {
                this.name = opt.name || 'unnamed adapter';
              }

              convertArg(v, argv, argIndex) {
                toss('AbstractArgAdapter must be subclassed.');
              }
            };

            xArg.FuncPtrAdapter = class FuncPtrAdapter extends AbstractArgAdapter {
              constructor(opt) {
                super(opt);
                if (xArg.FuncPtrAdapter.warnOnUse) {
                  console.warn(
                    'xArg.FuncPtrAdapter is an internal-only API',
                    'and is not intended to be invoked from',
                    'client-level code. Invoked with:',
                    opt,
                  );
                }
                this.name = opt.name || 'unnamed';
                this.signature = opt.signature;
                if (opt.contextKey instanceof Function) {
                  this.contextKey = opt.contextKey;
                  if (!opt.bindScope) opt.bindScope = 'context';
                }
                this.bindScope =
                  opt.bindScope ||
                  toss(
                    'FuncPtrAdapter options requires a bindScope (explicit or implied).',
                  );
                if (FuncPtrAdapter.bindScopes.indexOf(opt.bindScope) < 0) {
                  toss(
                    'Invalid options.bindScope (' +
                      opt.bindMod +
                      ') for FuncPtrAdapter. ' +
                      'Expecting one of: (' +
                      FuncPtrAdapter.bindScopes.join(', ') +
                      ')',
                  );
                }
                this.isTransient = 'transient' === this.bindScope;
                this.isContext = 'context' === this.bindScope;
                this.isPermanent = 'permanent' === this.bindScope;
                this.singleton = 'singleton' === this.bindScope ? [] : undefined;

                this.callProxy =
                  opt.callProxy instanceof Function ? opt.callProxy : undefined;
              }

              contextKey(argv, argIndex) {
                return this;
              }

              contextMap(key) {
                const cm = this.__cmap || (this.__cmap = new Map());
                let rc = cm.get(key);
                if (undefined === rc) cm.set(key, (rc = []));
                return rc;
              }

              convertArg(v, argv, argIndex) {
                let pair = this.singleton;
                if (!pair && this.isContext) {
                  pair = this.contextMap(this.contextKey(argv, argIndex));
                }
                if (pair && pair[0] === v) return pair[1];
                if (v instanceof Function) {
                  if (this.callProxy) v = this.callProxy(v);
                  const fp = __installFunction(v, this.signature, this.isTransient);
                  if (FuncPtrAdapter.debugFuncInstall) {
                    FuncPtrAdapter.debugOut(
                      'FuncPtrAdapter installed',
                      this,
                      this.contextKey(argv, argIndex),
                      '@' + fp,
                      v,
                    );
                  }
                  if (pair) {
                    if (pair[1]) {
                      if (FuncPtrAdapter.debugFuncInstall) {
                        FuncPtrAdapter.debugOut(
                          'FuncPtrAdapter uninstalling',
                          this,
                          this.contextKey(argv, argIndex),
                          '@' + pair[1],
                          v,
                        );
                      }
                      try {
                        cache.scopedAlloc[cache.scopedAlloc.length - 1].push(
                          pair[1],
                        );
                      } catch (e) {}
                    }
                    pair[0] = v;
                    pair[1] = fp;
                  }
                  return fp;
                } else if (target.isPtr(v) || null === v || undefined === v) {
                  if (pair && pair[1] && pair[1] !== v) {
                    if (FuncPtrAdapter.debugFuncInstall) {
                      FuncPtrAdapter.debugOut(
                        'FuncPtrAdapter uninstalling',
                        this,
                        this.contextKey(argv, argIndex),
                        '@' + pair[1],
                        v,
                      );
                    }
                    try {
                      cache.scopedAlloc[cache.scopedAlloc.length - 1].push(pair[1]);
                    } catch (e) {}
                    pair[0] = pair[1] = v | 0;
                  }
                  return v || 0;
                } else {
                  throw new TypeError(
                    'Invalid FuncPtrAdapter argument type. ' +
                      'Expecting a function pointer or a ' +
                      (this.name ? this.name + ' ' : '') +
                      'function matching signature ' +
                      this.signature +
                      '.',
                  );
                }
              }
            };

            xArg.FuncPtrAdapter.warnOnUse = false;

            xArg.FuncPtrAdapter.debugFuncInstall = false;

            xArg.FuncPtrAdapter.debugOut = console.debug.bind(console);

            xArg.FuncPtrAdapter.bindScopes = [
              'transient',
              'context',
              'singleton',
              'permanent',
            ];

            const __xArgAdapterCheck = (t) =>
              xArg.get(t) || toss('Argument adapter not found:', t);

            const __xResultAdapterCheck = (t) =>
              xResult.get(t) || toss('Result adapter not found:', t);

            cache.xWrap.convertArg = (t, ...args) => __xArgAdapterCheck(t)(...args);
            cache.xWrap.convertArgNoCheck = (t, ...args) => xArg.get(t)(...args);

            cache.xWrap.convertResult = (t, v) =>
              null === t ? v : t ? __xResultAdapterCheck(t)(v) : undefined;
            cache.xWrap.convertResultNoCheck = (t, v) =>
              null === t ? v : t ? xResult.get(t)(v) : undefined;

            target.xWrap = function (fArg, resultType, ...argTypes) {
              if (3 === arguments.length && Array.isArray(arguments[2])) {
                argTypes = arguments[2];
              }
              if (target.isPtr(fArg)) {
                fArg =
                  target.functionEntry(fArg) ||
                  toss('Function pointer not found in WASM function table.');
              }
              const fIsFunc = fArg instanceof Function;
              const xf = fIsFunc ? fArg : target.xGet(fArg);
              if (fIsFunc) fArg = xf.name || 'unnamed function';
              if (argTypes.length !== xf.length) __argcMismatch(fArg, xf.length);
              if (null === resultType && 0 === xf.length) {
                return xf;
              }
              if (undefined !== resultType && null !== resultType)
                __xResultAdapterCheck(resultType);
              for (const t of argTypes) {
                if (t instanceof AbstractArgAdapter)
                  xArg.set(t, (...args) => t.convertArg(...args));
                else __xArgAdapterCheck(t);
              }
              const cxw = cache.xWrap;
              if (0 === xf.length) {
                return (...args) =>
                  args.length
                    ? __argcMismatch(fArg, xf.length)
                    : cxw.convertResult(resultType, xf.call(null));
              }
              return function (...args) {
                if (args.length !== xf.length) __argcMismatch(fArg, xf.length);
                const scope = target.scopedAllocPush();
                try {
                  for (const i in args)
                    args[i] = cxw.convertArgNoCheck(argTypes[i], args[i], args, i);
                  return cxw.convertResultNoCheck(resultType, xf.apply(null, args));
                } finally {
                  target.scopedAllocPop(scope);
                }
              };
            };

            const __xAdapter = function (
              func,
              argc,
              typeName,
              adapter,
              modeName,
              xcvPart,
            ) {
              if ('string' === typeof typeName) {
                if (1 === argc) return xcvPart.get(typeName);
                else if (2 === argc) {
                  if (!adapter) {
                    delete xcvPart.get(typeName);
                    return func;
                  } else if (!(adapter instanceof Function)) {
                    toss(modeName, 'requires a function argument.');
                  }
                  xcvPart.set(typeName, adapter);
                  return func;
                }
              }
              toss('Invalid arguments to', modeName);
            };

            target.xWrap.resultAdapter = function f(typeName, adapter) {
              return __xAdapter(
                f,
                arguments.length,
                typeName,
                adapter,
                'resultAdapter()',
                xResult,
              );
            };

            target.xWrap.argAdapter = function f(typeName, adapter) {
              return __xAdapter(
                f,
                arguments.length,
                typeName,
                adapter,
                'argAdapter()',
                xArg,
              );
            };

            target.xWrap.FuncPtrAdapter = xArg.FuncPtrAdapter;

            target.xCallWrapped = function (fArg, resultType, argTypes, ...args) {
              if (Array.isArray(arguments[3])) args = arguments[3];
              return target
                .xWrap(fArg, resultType, argTypes || [])
                .apply(null, args || []);
            };

            target.xWrap.testConvertArg = cache.xWrap.convertArg;

            target.xWrap.testConvertResult = cache.xWrap.convertResult;

            return target;
          };

          globalThis.WhWasmUtilInstaller.yawl = function (config) {
            const wfetch = () => fetch(config.uri, { credentials: 'same-origin' });
            const wui = this;
            const finalThen = function (arg) {
              if (config.wasmUtilTarget) {
                const toss = (...args) => {
                  throw new Error(args.join(' '));
                };
                const tgt = config.wasmUtilTarget;
                tgt.module = arg.module;
                tgt.instance = arg.instance;

                if (!tgt.instance.exports.memory) {
                  tgt.memory =
                    (config.imports &&
                      config.imports.env &&
                      config.imports.env.memory) ||
                    toss("Missing 'memory' object!");
                }
                if (!tgt.alloc && arg.instance.exports.malloc) {
                  const exports = arg.instance.exports;
                  tgt.alloc = function (n) {
                    return (
                      exports.malloc(n) || toss('Allocation of', n, 'bytes failed.')
                    );
                  };
                  tgt.dealloc = function (m) {
                    exports.free(m);
                  };
                }
                wui(tgt);
              }
              if (config.onload) config.onload(arg, config);
              return arg;
            };
            const loadWasm = WebAssembly.instantiateStreaming
              ? function loadWasmStreaming() {
                  return WebAssembly.instantiateStreaming(
                    wfetch(),
                    config.imports || {},
                  ).then(finalThen);
                }
              : function loadWasmOldSchool() {
                  return wfetch()
                    .then((response) => response.arrayBuffer())
                    .then((bytes) =>
                      WebAssembly.instantiate(bytes, config.imports || {}),
                    )
                    .then(finalThen);
                };
            return loadWasm;
          }.bind(globalThis.WhWasmUtilInstaller);
          globalThis.Jaccwabyt = function StructBinderFactory(config) {
            const toss = (...args) => {
              throw new Error(args.join(' '));
            };

            if (
              !(config.heap instanceof WebAssembly.Memory) &&
              !(config.heap instanceof Function)
            ) {
              toss(
                'config.heap must be WebAssembly.Memory instance or a function.',
              );
            }
            ['alloc', 'dealloc'].forEach(function (k) {
              config[k] instanceof Function ||
                toss("Config option '" + k + "' must be a function.");
            });
            const SBF = StructBinderFactory;
            const heap =
                config.heap instanceof Function
                  ? config.heap
                  : () => new Uint8Array(config.heap.buffer),
              alloc = config.alloc,
              dealloc = config.dealloc,
              log = config.log || console.log.bind(console),
              memberPrefix = config.memberPrefix || '',
              memberSuffix = config.memberSuffix || '',
              bigIntEnabled =
                undefined === config.bigIntEnabled
                  ? !!globalThis['BigInt64Array']
                  : !!config.bigIntEnabled,
              BigInt = globalThis['BigInt'],
              BigInt64Array = globalThis['BigInt64Array'],
              ptrSizeof = config.ptrSizeof || 4,
              ptrIR = config.ptrIR || 'i32';
            if (!SBF.debugFlags) {
              SBF.__makeDebugFlags = function (deriveFrom = null) {
                if (deriveFrom && deriveFrom.__flags)
                  deriveFrom = deriveFrom.__flags;
                const f = function f(flags) {
                  if (0 === arguments.length) {
                    return f.__flags;
                  }
                  if (flags < 0) {
                    delete f.__flags.getter;
                    delete f.__flags.setter;
                    delete f.__flags.alloc;
                    delete f.__flags.dealloc;
                  } else {
                    f.__flags.getter = 0 !== (0x01 & flags);
                    f.__flags.setter = 0 !== (0x02 & flags);
                    f.__flags.alloc = 0 !== (0x04 & flags);
                    f.__flags.dealloc = 0 !== (0x08 & flags);
                  }
                  return f._flags;
                };
                Object.defineProperty(f, '__flags', {
                  iterable: false,
                  writable: false,
                  value: Object.create(deriveFrom),
                });
                if (!deriveFrom) f(0);
                return f;
              };
              SBF.debugFlags = SBF.__makeDebugFlags();
            }

            const isLittleEndian = (function () {
              const buffer = new ArrayBuffer(2);
              new DataView(buffer).setInt16(0, 256, true);

              return new Int16Array(buffer)[0] === 256;
            })();

            const isFuncSig = (s) => '(' === s[1];
            const isAutoPtrSig = (s) => 'P' === s;
            const sigLetter = (s) => (isFuncSig(s) ? 'p' : s[0]);

            const sigIR = function (s) {
              switch (sigLetter(s)) {
                case 'c':
                case 'C':
                  return 'i8';
                case 'i':
                  return 'i32';
                case 'p':
                case 'P':
                case 's':
                  return ptrIR;
                case 'j':
                  return 'i64';
                case 'f':
                  return 'float';
                case 'd':
                  return 'double';
              }
              toss('Unhandled signature IR:', s);
            };

            const affirmBigIntArray = BigInt64Array
              ? () => true
              : () => toss('BigInt64Array is not available.');

            const sigDVGetter = function (s) {
              switch (sigLetter(s)) {
                case 'p':
                case 'P':
                case 's': {
                  switch (ptrSizeof) {
                    case 4:
                      return 'getInt32';
                    case 8:
                      return affirmBigIntArray() && 'getBigInt64';
                  }
                  break;
                }
                case 'i':
                  return 'getInt32';
                case 'c':
                  return 'getInt8';
                case 'C':
                  return 'getUint8';
                case 'j':
                  return affirmBigIntArray() && 'getBigInt64';
                case 'f':
                  return 'getFloat32';
                case 'd':
                  return 'getFloat64';
              }
              toss('Unhandled DataView getter for signature:', s);
            };

            const sigDVSetter = function (s) {
              switch (sigLetter(s)) {
                case 'p':
                case 'P':
                case 's': {
                  switch (ptrSizeof) {
                    case 4:
                      return 'setInt32';
                    case 8:
                      return affirmBigIntArray() && 'setBigInt64';
                  }
                  break;
                }
                case 'i':
                  return 'setInt32';
                case 'c':
                  return 'setInt8';
                case 'C':
                  return 'setUint8';
                case 'j':
                  return affirmBigIntArray() && 'setBigInt64';
                case 'f':
                  return 'setFloat32';
                case 'd':
                  return 'setFloat64';
              }
              toss('Unhandled DataView setter for signature:', s);
            };

            const sigDVSetWrapper = function (s) {
              switch (sigLetter(s)) {
                case 'i':
                case 'f':
                case 'c':
                case 'C':
                case 'd':
                  return Number;
                case 'j':
                  return affirmBigIntArray() && BigInt;
                case 'p':
                case 'P':
                case 's':
                  switch (ptrSizeof) {
                    case 4:
                      return Number;
                    case 8:
                      return affirmBigIntArray() && BigInt;
                  }
                  break;
              }
              toss('Unhandled DataView set wrapper for signature:', s);
            };

            const sPropName = (s, k) => s + '::' + k;

            const __propThrowOnSet = function (structName, propName) {
              return () => toss(sPropName(structName, propName), 'is read-only.');
            };

            const __instancePointerMap = new WeakMap();

            const xPtrPropName = '(pointer-is-external)';

            const __freeStruct = function (ctor, obj, m) {
              if (!m) m = __instancePointerMap.get(obj);
              if (m) {
                __instancePointerMap.delete(obj);
                if (Array.isArray(obj.ondispose)) {
                  let x;
                  while ((x = obj.ondispose.shift())) {
                    try {
                      if (x instanceof Function) x.call(obj);
                      else if (x instanceof StructType) x.dispose();
                      else if ('number' === typeof x) dealloc(x);
                    } catch (e) {
                      console.warn(
                        'ondispose() for',
                        ctor.structName,
                        '@',
                        m,
                        'threw. NOT propagating it.',
                        e,
                      );
                    }
                  }
                } else if (obj.ondispose instanceof Function) {
                  try {
                    obj.ondispose();
                  } catch (e) {
                    console.warn(
                      'ondispose() for',
                      ctor.structName,
                      '@',
                      m,
                      'threw. NOT propagating it.',
                      e,
                    );
                  }
                }
                delete obj.ondispose;
                if (ctor.debugFlags.__flags.dealloc) {
                  log(
                    'debug.dealloc:',
                    obj[xPtrPropName] ? 'EXTERNAL' : '',
                    ctor.structName,
                    'instance:',
                    ctor.structInfo.sizeof,
                    'bytes @' + m,
                  );
                }
                if (!obj[xPtrPropName]) dealloc(m);
              }
            };

            const rop = (v) => {
              return {
                configurable: false,
                writable: false,
                iterable: false,
                value: v,
              };
            };

            const __allocStruct = function (ctor, obj, m) {
              let fill = !m;
              if (m) Object.defineProperty(obj, xPtrPropName, rop(m));
              else {
                m = alloc(ctor.structInfo.sizeof);
                if (!m) toss('Allocation of', ctor.structName, 'structure failed.');
              }
              try {
                if (ctor.debugFlags.__flags.alloc) {
                  log(
                    'debug.alloc:',
                    fill ? '' : 'EXTERNAL',
                    ctor.structName,
                    'instance:',
                    ctor.structInfo.sizeof,
                    'bytes @' + m,
                  );
                }
                if (fill) heap().fill(0, m, m + ctor.structInfo.sizeof);
                __instancePointerMap.set(obj, m);
              } catch (e) {
                __freeStruct(ctor, obj, m);
                throw e;
              }
            };

            const __memoryDump = function () {
              const p = this.pointer;
              return p
                ? new Uint8Array(heap().slice(p, p + this.structInfo.sizeof))
                : null;
            };

            const __memberKey = (k) => memberPrefix + k + memberSuffix;
            const __memberKeyProp = rop(__memberKey);

            const __lookupMember = function (
              structInfo,
              memberName,
              tossIfNotFound = true,
            ) {
              let m = structInfo.members[memberName];
              if (!m && (memberPrefix || memberSuffix)) {
                for (const v of Object.values(structInfo.members)) {
                  if (v.key === memberName) {
                    m = v;
                    break;
                  }
                }
                if (!m && tossIfNotFound) {
                  toss(
                    sPropName(structInfo.name, memberName),
                    'is not a mapped struct member.',
                  );
                }
              }
              return m;
            };

            const __memberSignature = function f(
              obj,
              memberName,
              emscriptenFormat = false,
            ) {
              if (!f._)
                f._ = (x) =>
                  x.replace(/[^vipPsjrdcC]/g, '').replace(/[pPscC]/g, 'i');
              const m = __lookupMember(obj.structInfo, memberName, true);
              return emscriptenFormat ? f._(m.signature) : m.signature;
            };

            const __ptrPropDescriptor = {
              configurable: false,
              enumerable: false,
              get: function () {
                return __instancePointerMap.get(this);
              },
              set: () => toss("Cannot assign the 'pointer' property of a struct."),
            };

            const __structMemberKeys = rop(function () {
              const a = [];
              for (const k of Object.keys(this.structInfo.members)) {
                a.push(this.memberKey(k));
              }
              return a;
            });

            const __utf8Decoder = new TextDecoder('utf-8');
            const __utf8Encoder = new TextEncoder();

            const __SAB =
              'undefined' === typeof SharedArrayBuffer
                ? function () {}
                : SharedArrayBuffer;
            const __utf8Decode = function (arrayBuffer, begin, end) {
              return __utf8Decoder.decode(
                arrayBuffer.buffer instanceof __SAB
                  ? arrayBuffer.slice(begin, end)
                  : arrayBuffer.subarray(begin, end),
              );
            };

            const __memberIsString = function (
              obj,
              memberName,
              tossIfNotFound = false,
            ) {
              const m = __lookupMember(obj.structInfo, memberName, tossIfNotFound);
              return m && 1 === m.signature.length && 's' === m.signature[0]
                ? m
                : false;
            };

            const __affirmCStringSignature = function (member) {
              if ('s' === member.signature) return;
              toss(
                'Invalid member type signature for C-string value:',
                JSON.stringify(member),
              );
            };

            const __memberToJsString = function f(obj, memberName) {
              const m = __lookupMember(obj.structInfo, memberName, true);
              __affirmCStringSignature(m);
              const addr = obj[m.key];

              if (!addr) return null;
              let pos = addr;
              const mem = heap();
              for (; mem[pos] !== 0; ++pos) {}

              return addr === pos ? '' : __utf8Decode(mem, addr, pos);
            };

            const __addOnDispose = function (obj, ...v) {
              if (obj.ondispose) {
                if (!Array.isArray(obj.ondispose)) {
                  obj.ondispose = [obj.ondispose];
                }
              } else {
                obj.ondispose = [];
              }
              obj.ondispose.push(...v);
            };

            const __allocCString = function (str) {
              const u = __utf8Encoder.encode(str);
              const mem = alloc(u.length + 1);
              if (!mem) toss('Allocation error while duplicating string:', str);
              const h = heap();

              h.set(u, mem);
              h[mem + u.length] = 0;

              return mem;
            };

            const __setMemberCString = function (obj, memberName, str) {
              const m = __lookupMember(obj.structInfo, memberName, true);
              __affirmCStringSignature(m);

              const mem = __allocCString(str);
              obj[m.key] = mem;
              __addOnDispose(obj, mem);
              return obj;
            };

            const StructType = function ctor(structName, structInfo) {
              if (arguments[2] !== rop) {
                toss(
                  'Do not call the StructType constructor',
                  'from client-level code.',
                );
              }
              Object.defineProperties(this, {
                structName: rop(structName),
                structInfo: rop(structInfo),
              });
            };

            StructType.prototype = Object.create(null, {
              dispose: rop(function () {
                __freeStruct(this.constructor, this);
              }),
              lookupMember: rop(function (memberName, tossIfNotFound = true) {
                return __lookupMember(this.structInfo, memberName, tossIfNotFound);
              }),
              memberToJsString: rop(function (memberName) {
                return __memberToJsString(this, memberName);
              }),
              memberIsString: rop(function (memberName, tossIfNotFound = true) {
                return __memberIsString(this, memberName, tossIfNotFound);
              }),
              memberKey: __memberKeyProp,
              memberKeys: __structMemberKeys,
              memberSignature: rop(function (memberName, emscriptenFormat = false) {
                return __memberSignature(this, memberName, emscriptenFormat);
              }),
              memoryDump: rop(__memoryDump),
              pointer: __ptrPropDescriptor,
              setMemberCString: rop(function (memberName, str) {
                return __setMemberCString(this, memberName, str);
              }),
            });

            Object.assign(StructType.prototype, {
              addOnDispose: function (...v) {
                __addOnDispose(this, ...v);
                return this;
              },
            });

            Object.defineProperties(StructType, {
              allocCString: rop(__allocCString),
              isA: rop((v) => v instanceof StructType),
              hasExternalPointer: rop(
                (v) => v instanceof StructType && !!v[xPtrPropName],
              ),
              memberKey: __memberKeyProp,
            });

            const isNumericValue = (v) =>
              Number.isFinite(v) || v instanceof (BigInt || Number);

            const makeMemberWrapper = function f(ctor, name, descr) {
              if (!f._) {
                f._ = { getters: {}, setters: {}, sw: {} };
                const a = ['i', 'c', 'C', 'p', 'P', 's', 'f', 'd', 'v()'];
                if (bigIntEnabled) a.push('j');
                a.forEach(function (v) {
                  f._.getters[v] = sigDVGetter(v);
                  f._.setters[v] = sigDVSetter(v);
                  f._.sw[v] = sigDVSetWrapper(v);
                });
                const rxSig1 = /^[ipPsjfdcC]$/,
                  rxSig2 = /^[vipPsjfdcC]\([ipPsjfdcC]*\)$/;
                f.sigCheck = function (obj, name, key, sig) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    toss(obj.structName, 'already has a property named', key + '.');
                  }
                  rxSig1.test(sig) ||
                    rxSig2.test(sig) ||
                    toss(
                      'Malformed signature for',
                      sPropName(obj.structName, name) + ':',
                      sig,
                    );
                };
              }
              const key = ctor.memberKey(name);
              f.sigCheck(ctor.prototype, name, key, descr.signature);
              descr.key = key;
              descr.name = name;
              const sigGlyph = sigLetter(descr.signature);
              const xPropName = sPropName(ctor.prototype.structName, key);
              const dbg = ctor.prototype.debugFlags.__flags;

              const prop = Object.create(null);
              prop.configurable = false;
              prop.enumerable = false;
              prop.get = function () {
                if (dbg.getter) {
                  log(
                    'debug.getter:',
                    f._.getters[sigGlyph],
                    'for',
                    sigIR(sigGlyph),
                    xPropName,
                    '@',
                    this.pointer,
                    '+',
                    descr.offset,
                    'sz',
                    descr.sizeof,
                  );
                }
                let rc = new DataView(
                  heap().buffer,
                  this.pointer + descr.offset,
                  descr.sizeof,
                )[f._.getters[sigGlyph]](0, isLittleEndian);
                if (dbg.getter) log('debug.getter:', xPropName, 'result =', rc);
                return rc;
              };
              if (descr.readOnly) {
                prop.set = __propThrowOnSet(ctor.prototype.structName, key);
              } else {
                prop.set = function (v) {
                  if (dbg.setter) {
                    log(
                      'debug.setter:',
                      f._.setters[sigGlyph],
                      'for',
                      sigIR(sigGlyph),
                      xPropName,
                      '@',
                      this.pointer,
                      '+',
                      descr.offset,
                      'sz',
                      descr.sizeof,
                      v,
                    );
                  }
                  if (!this.pointer) {
                    toss('Cannot set struct property on disposed instance.');
                  }
                  if (null === v) v = 0;
                  else
                    while (!isNumericValue(v)) {
                      if (
                        isAutoPtrSig(descr.signature) &&
                        v instanceof StructType
                      ) {
                        v = v.pointer || 0;
                        if (dbg.setter)
                          log('debug.setter:', xPropName, 'resolved to', v);
                        break;
                      }
                      toss('Invalid value for pointer-type', xPropName + '.');
                    }
                  new DataView(
                    heap().buffer,
                    this.pointer + descr.offset,
                    descr.sizeof,
                  )[f._.setters[sigGlyph]](0, f._.sw[sigGlyph](v), isLittleEndian);
                };
              }
              Object.defineProperty(ctor.prototype, key, prop);
            };

            const StructBinder = function StructBinder(structName, structInfo) {
              if (1 === arguments.length) {
                structInfo = structName;
                structName = structInfo.name;
              } else if (!structInfo.name) {
                structInfo.name = structName;
              }
              if (!structName) toss('Struct name is required.');
              let lastMember = false;
              Object.keys(structInfo.members).forEach((k) => {
                const m = structInfo.members[k];
                if (!m.sizeof) toss(structName, 'member', k, 'is missing sizeof.');
                else if (m.sizeof === 1) {
                  m.signature === 'c' ||
                    m.signature === 'C' ||
                    toss(
                      'Unexpected sizeof==1 member',
                      sPropName(structInfo.name, k),
                      'with signature',
                      m.signature,
                    );
                } else {
                  if (0 !== m.sizeof % 4) {
                    console.warn(
                      'Invalid struct member description =',
                      m,
                      'from',
                      structInfo,
                    );
                    toss(
                      structName,
                      'member',
                      k,
                      'sizeof is not aligned. sizeof=' + m.sizeof,
                    );
                  }
                  if (0 !== m.offset % 4) {
                    console.warn(
                      'Invalid struct member description =',
                      m,
                      'from',
                      structInfo,
                    );
                    toss(
                      structName,
                      'member',
                      k,
                      'offset is not aligned. offset=' + m.offset,
                    );
                  }
                }
                if (!lastMember || lastMember.offset < m.offset) lastMember = m;
              });
              if (!lastMember) toss('No member property descriptions found.');
              else if (structInfo.sizeof < lastMember.offset + lastMember.sizeof) {
                toss(
                  'Invalid struct config:',
                  structName,
                  'max member offset (' + lastMember.offset + ') ',
                  'extends past end of struct (sizeof=' + structInfo.sizeof + ').',
                );
              }
              const debugFlags = rop(SBF.__makeDebugFlags(StructBinder.debugFlags));

              const StructCtor = function StructCtor(externalMemory) {
                if (!(this instanceof StructCtor)) {
                  toss(
                    'The',
                    structName,
                    "constructor may only be called via 'new'.",
                  );
                } else if (arguments.length) {
                  if (
                    externalMemory !== (externalMemory | 0) ||
                    externalMemory <= 0
                  ) {
                    toss('Invalid pointer value for', structName, 'constructor.');
                  }
                  __allocStruct(StructCtor, this, externalMemory);
                } else {
                  __allocStruct(StructCtor, this);
                }
              };
              Object.defineProperties(StructCtor, {
                debugFlags: debugFlags,
                isA: rop((v) => v instanceof StructCtor),
                memberKey: __memberKeyProp,
                memberKeys: __structMemberKeys,
                methodInfoForKey: rop(function (mKey) {}),
                structInfo: rop(structInfo),
                structName: rop(structName),
              });
              StructCtor.prototype = new StructType(structName, structInfo, rop);
              Object.defineProperties(StructCtor.prototype, {
                debugFlags: debugFlags,
                constructor: rop(StructCtor),
              });
              Object.keys(structInfo.members).forEach((name) =>
                makeMemberWrapper(StructCtor, name, structInfo.members[name]),
              );
              return StructCtor;
            };
            StructBinder.StructType = StructType;
            StructBinder.config = config;
            StructBinder.allocCString = __allocCString;
            if (!StructBinder.debugFlags) {
              StructBinder.debugFlags = SBF.__makeDebugFlags(SBF.debugFlags);
            }
            return StructBinder;
          };

          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            const toss = (...args) => {
              throw new Error(args.join(' '));
            };
            sqlite3.SQLite3Error.toss;
            const capi = sqlite3.capi,
              wasm = sqlite3.wasm,
              util = sqlite3.util;
            globalThis.WhWasmUtilInstaller(wasm);
            delete globalThis.WhWasmUtilInstaller;

            wasm.bindingSignatures = [
              ['sqlite3_aggregate_context', 'void*', 'sqlite3_context*', 'int'],

              ['sqlite3_bind_double', 'int', 'sqlite3_stmt*', 'int', 'f64'],
              ['sqlite3_bind_int', 'int', 'sqlite3_stmt*', 'int', 'int'],
              ['sqlite3_bind_null', undefined, 'sqlite3_stmt*', 'int'],
              ['sqlite3_bind_parameter_count', 'int', 'sqlite3_stmt*'],
              ['sqlite3_bind_parameter_index', 'int', 'sqlite3_stmt*', 'string'],
              [
                'sqlite3_bind_pointer',
                'int',
                'sqlite3_stmt*',
                'int',
                '*',
                'string:static',
                '*',
              ],
              [
                'sqlite3_busy_handler',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    signature: 'i(pi)',
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                  '*',
                ],
              ],
              ['sqlite3_busy_timeout', 'int', 'sqlite3*', 'int'],

              ['sqlite3_changes', 'int', 'sqlite3*'],
              ['sqlite3_clear_bindings', 'int', 'sqlite3_stmt*'],
              ['sqlite3_collation_needed', 'int', 'sqlite3*', '*', '*'],
              ['sqlite3_column_blob', '*', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_bytes', 'int', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_count', 'int', 'sqlite3_stmt*'],
              ['sqlite3_column_double', 'f64', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_int', 'int', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_name', 'string', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_text', 'string', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_type', 'int', 'sqlite3_stmt*', 'int'],
              ['sqlite3_column_value', 'sqlite3_value*', 'sqlite3_stmt*', 'int'],
              [
                'sqlite3_commit_hook',
                'void*',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_commit_hook',
                    signature: 'i(p)',
                    contextKey: (argv) => argv[0],
                  }),
                  '*',
                ],
              ],
              ['sqlite3_compileoption_get', 'string', 'int'],
              ['sqlite3_compileoption_used', 'int', 'string'],
              ['sqlite3_complete', 'int', 'string:flexible'],
              ['sqlite3_context_db_handle', 'sqlite3*', 'sqlite3_context*'],

              ['sqlite3_data_count', 'int', 'sqlite3_stmt*'],
              ['sqlite3_db_filename', 'string', 'sqlite3*', 'string'],
              ['sqlite3_db_handle', 'sqlite3*', 'sqlite3_stmt*'],
              ['sqlite3_db_name', 'string', 'sqlite3*', 'int'],
              ['sqlite3_db_status', 'int', 'sqlite3*', 'int', '*', '*', 'int'],
              ['sqlite3_errcode', 'int', 'sqlite3*'],
              ['sqlite3_errmsg', 'string', 'sqlite3*'],
              ['sqlite3_error_offset', 'int', 'sqlite3*'],
              ['sqlite3_errstr', 'string', 'int'],
              [
                'sqlite3_exec',
                'int',
                [
                  'sqlite3*',
                  'string:flexible',
                  new wasm.xWrap.FuncPtrAdapter({
                    signature: 'i(pipp)',
                    bindScope: 'transient',
                    callProxy: (callback) => {
                      let aNames;
                      return (pVoid, nCols, pColVals, pColNames) => {
                        try {
                          const aVals = wasm.cArgvToJs(nCols, pColVals);
                          if (!aNames) aNames = wasm.cArgvToJs(nCols, pColNames);
                          return callback(aVals, aNames) | 0;
                        } catch (e) {
                          return e.resultCode || capi.SQLITE_ERROR;
                        }
                      };
                    },
                  }),
                  '*',
                  '**',
                ],
              ],
              ['sqlite3_expanded_sql', 'string', 'sqlite3_stmt*'],
              ['sqlite3_extended_errcode', 'int', 'sqlite3*'],
              ['sqlite3_extended_result_codes', 'int', 'sqlite3*', 'int'],
              ['sqlite3_file_control', 'int', 'sqlite3*', 'string', 'int', '*'],
              ['sqlite3_finalize', 'int', 'sqlite3_stmt*'],
              ['sqlite3_free', undefined, '*'],
              ['sqlite3_get_autocommit', 'int', 'sqlite3*'],
              ['sqlite3_get_auxdata', '*', 'sqlite3_context*', 'int'],
              ['sqlite3_initialize', undefined],

              ['sqlite3_keyword_count', 'int'],
              ['sqlite3_keyword_name', 'int', ['int', '**', '*']],
              ['sqlite3_keyword_check', 'int', ['string', 'int']],
              ['sqlite3_libversion', 'string'],
              ['sqlite3_libversion_number', 'int'],
              ['sqlite3_limit', 'int', ['sqlite3*', 'int', 'int']],
              ['sqlite3_malloc', '*', 'int'],
              ['sqlite3_open', 'int', 'string', '*'],
              ['sqlite3_open_v2', 'int', 'string', '*', 'int', 'string'],

              [
                'sqlite3_progress_handler',
                undefined,
                [
                  'sqlite3*',
                  'int',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xProgressHandler',
                    signature: 'i(p)',
                    bindScope: 'context',
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                  '*',
                ],
              ],
              ['sqlite3_realloc', '*', '*', 'int'],
              ['sqlite3_reset', 'int', 'sqlite3_stmt*'],

              [
                'sqlite3_result_blob',
                undefined,
                'sqlite3_context*',
                '*',
                'int',
                '*',
              ],
              ['sqlite3_result_double', undefined, 'sqlite3_context*', 'f64'],
              [
                'sqlite3_result_error',
                undefined,
                'sqlite3_context*',
                'string',
                'int',
              ],
              ['sqlite3_result_error_code', undefined, 'sqlite3_context*', 'int'],
              ['sqlite3_result_error_nomem', undefined, 'sqlite3_context*'],
              ['sqlite3_result_error_toobig', undefined, 'sqlite3_context*'],
              ['sqlite3_result_int', undefined, 'sqlite3_context*', 'int'],
              ['sqlite3_result_null', undefined, 'sqlite3_context*'],
              [
                'sqlite3_result_pointer',
                undefined,
                'sqlite3_context*',
                '*',
                'string:static',
                '*',
              ],
              ['sqlite3_result_subtype', undefined, 'sqlite3_value*', 'int'],
              [
                'sqlite3_result_text',
                undefined,
                'sqlite3_context*',
                'string',
                'int',
                '*',
              ],
              ['sqlite3_result_zeroblob', undefined, 'sqlite3_context*', 'int'],
              [
                'sqlite3_rollback_hook',
                'void*',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_rollback_hook',
                    signature: 'v(p)',
                    contextKey: (argv) => argv[0],
                  }),
                  '*',
                ],
              ],
              [
                'sqlite3_set_authorizer',
                'int',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_set_authorizer::xAuth',
                    signature: 'i(pi' + 'ssss)',
                    contextKey: (argv, argIndex) => argv[0],
                    callProxy: (callback) => {
                      return (pV, iCode, s0, s1, s2, s3) => {
                        try {
                          s0 = s0 && wasm.cstrToJs(s0);
                          s1 = s1 && wasm.cstrToJs(s1);
                          s2 = s2 && wasm.cstrToJs(s2);
                          s3 = s3 && wasm.cstrToJs(s3);
                          return callback(pV, iCode, s0, s1, s2, s3) || 0;
                        } catch (e) {
                          return e.resultCode || capi.SQLITE_ERROR;
                        }
                      };
                    },
                  }),
                  '*',
                ],
              ],
              [
                'sqlite3_set_auxdata',
                undefined,
                [
                  'sqlite3_context*',
                  'int',
                  '*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xDestroyAuxData',
                    signature: 'v(*)',
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                ],
              ],
              ['sqlite3_shutdown', undefined],
              ['sqlite3_sourceid', 'string'],
              ['sqlite3_sql', 'string', 'sqlite3_stmt*'],
              ['sqlite3_status', 'int', 'int', '*', '*', 'int'],
              ['sqlite3_step', 'int', 'sqlite3_stmt*'],
              ['sqlite3_stmt_isexplain', 'int', ['sqlite3_stmt*']],
              ['sqlite3_stmt_readonly', 'int', ['sqlite3_stmt*']],
              ['sqlite3_stmt_status', 'int', 'sqlite3_stmt*', 'int', 'int'],
              ['sqlite3_strglob', 'int', 'string', 'string'],
              ['sqlite3_stricmp', 'int', 'string', 'string'],
              ['sqlite3_strlike', 'int', 'string', 'string', 'int'],
              ['sqlite3_strnicmp', 'int', 'string', 'string', 'int'],
              [
                'sqlite3_table_column_metadata',
                'int',
                'sqlite3*',
                'string',
                'string',
                'string',
                '**',
                '**',
                '*',
                '*',
                '*',
              ],
              ['sqlite3_total_changes', 'int', 'sqlite3*'],
              [
                'sqlite3_trace_v2',
                'int',
                [
                  'sqlite3*',
                  'int',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_trace_v2::callback',
                    signature: 'i(ippp)',
                    contextKey: (argv, argIndex) => argv[0],
                  }),
                  '*',
                ],
              ],
              ['sqlite3_txn_state', 'int', ['sqlite3*', 'string']],

              ['sqlite3_uri_boolean', 'int', 'sqlite3_filename', 'string', 'int'],
              ['sqlite3_uri_key', 'string', 'sqlite3_filename', 'int'],
              ['sqlite3_uri_parameter', 'string', 'sqlite3_filename', 'string'],
              ['sqlite3_user_data', 'void*', 'sqlite3_context*'],
              ['sqlite3_value_blob', '*', 'sqlite3_value*'],
              ['sqlite3_value_bytes', 'int', 'sqlite3_value*'],
              ['sqlite3_value_double', 'f64', 'sqlite3_value*'],
              ['sqlite3_value_dup', 'sqlite3_value*', 'sqlite3_value*'],
              ['sqlite3_value_free', undefined, 'sqlite3_value*'],
              ['sqlite3_value_frombind', 'int', 'sqlite3_value*'],
              ['sqlite3_value_int', 'int', 'sqlite3_value*'],
              ['sqlite3_value_nochange', 'int', 'sqlite3_value*'],
              ['sqlite3_value_numeric_type', 'int', 'sqlite3_value*'],
              ['sqlite3_value_pointer', '*', 'sqlite3_value*', 'string:static'],
              ['sqlite3_value_subtype', 'int', 'sqlite3_value*'],
              ['sqlite3_value_text', 'string', 'sqlite3_value*'],
              ['sqlite3_value_type', 'int', 'sqlite3_value*'],
              ['sqlite3_vfs_find', '*', 'string'],
              ['sqlite3_vfs_register', 'int', 'sqlite3_vfs*', 'int'],
              ['sqlite3_vfs_unregister', 'int', 'sqlite3_vfs*'],
            ];

            if (wasm.exports.sqlite3_activate_see instanceof Function) {
              wasm.bindingSignatures.push(
                ['sqlite3_key', 'int', 'sqlite3*', 'string', 'int'],
                ['sqlite3_key_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
                ['sqlite3_rekey', 'int', 'sqlite3*', 'string', 'int'],
                ['sqlite3_rekey_v2', 'int', 'sqlite3*', 'string', '*', 'int'],
                ['sqlite3_activate_see', undefined, 'string'],
              );
            }

            wasm.bindingSignatures.int64 = [
              ['sqlite3_bind_int64', 'int', ['sqlite3_stmt*', 'int', 'i64']],
              ['sqlite3_changes64', 'i64', ['sqlite3*']],
              ['sqlite3_column_int64', 'i64', ['sqlite3_stmt*', 'int']],
              [
                'sqlite3_create_module',
                'int',
                ['sqlite3*', 'string', 'sqlite3_module*', '*'],
              ],
              [
                'sqlite3_create_module_v2',
                'int',
                ['sqlite3*', 'string', 'sqlite3_module*', '*', '*'],
              ],
              ['sqlite3_declare_vtab', 'int', ['sqlite3*', 'string:flexible']],
              [
                'sqlite3_deserialize',
                'int',
                'sqlite3*',
                'string',
                '*',
                'i64',
                'i64',
                'int',
              ],
              ['sqlite3_drop_modules', 'int', ['sqlite3*', '**']],
              ['sqlite3_last_insert_rowid', 'i64', ['sqlite3*']],
              ['sqlite3_malloc64', '*', 'i64'],
              ['sqlite3_msize', 'i64', '*'],
              ['sqlite3_overload_function', 'int', ['sqlite3*', 'string', 'int']],
              ['sqlite3_preupdate_blobwrite', 'int', 'sqlite3*'],
              ['sqlite3_preupdate_count', 'int', 'sqlite3*'],
              ['sqlite3_preupdate_depth', 'int', 'sqlite3*'],
              [
                'sqlite3_preupdate_hook',
                '*',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_preupdate_hook',
                    signature: 'v(ppippjj)',
                    contextKey: (argv) => argv[0],
                    callProxy: (callback) => {
                      return (p, db, op, zDb, zTbl, iKey1, iKey2) => {
                        callback(
                          p,
                          db,
                          op,
                          wasm.cstrToJs(zDb),
                          wasm.cstrToJs(zTbl),
                          iKey1,
                          iKey2,
                        );
                      };
                    },
                  }),
                  '*',
                ],
              ],
              ['sqlite3_preupdate_new', 'int', ['sqlite3*', 'int', '**']],
              ['sqlite3_preupdate_old', 'int', ['sqlite3*', 'int', '**']],
              ['sqlite3_realloc64', '*', '*', 'i64'],
              ['sqlite3_result_int64', undefined, '*', 'i64'],
              ['sqlite3_result_zeroblob64', 'int', '*', 'i64'],
              ['sqlite3_serialize', '*', 'sqlite3*', 'string', '*', 'int'],
              ['sqlite3_set_last_insert_rowid', undefined, ['sqlite3*', 'i64']],
              ['sqlite3_status64', 'int', 'int', '*', '*', 'int'],
              ['sqlite3_total_changes64', 'i64', ['sqlite3*']],
              [
                'sqlite3_update_hook',
                '*',
                [
                  'sqlite3*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'sqlite3_update_hook',
                    signature: 'v(iippj)',
                    contextKey: (argv) => argv[0],
                    callProxy: (callback) => {
                      return (p, op, z0, z1, rowid) => {
                        callback(
                          p,
                          op,
                          wasm.cstrToJs(z0),
                          wasm.cstrToJs(z1),
                          rowid,
                        );
                      };
                    },
                  }),
                  '*',
                ],
              ],
              ['sqlite3_uri_int64', 'i64', ['sqlite3_filename', 'string', 'i64']],
              ['sqlite3_value_int64', 'i64', 'sqlite3_value*'],
              ['sqlite3_vtab_collation', 'string', 'sqlite3_index_info*', 'int'],
              ['sqlite3_vtab_distinct', 'int', 'sqlite3_index_info*'],
              ['sqlite3_vtab_in', 'int', 'sqlite3_index_info*', 'int', 'int'],
              ['sqlite3_vtab_in_first', 'int', 'sqlite3_value*', '**'],
              ['sqlite3_vtab_in_next', 'int', 'sqlite3_value*', '**'],

              ['sqlite3_vtab_nochange', 'int', 'sqlite3_context*'],
              ['sqlite3_vtab_on_conflict', 'int', 'sqlite3*'],
              ['sqlite3_vtab_rhs_value', 'int', 'sqlite3_index_info*', 'int', '**'],
            ];

            if (wasm.bigIntEnabled && !!wasm.exports.sqlite3changegroup_add) {
              const __ipsProxy = {
                signature: 'i(ps)',
                callProxy: (callback) => {
                  return (p, s) => {
                    try {
                      return callback(p, wasm.cstrToJs(s)) | 0;
                    } catch (e) {
                      return e.resultCode || capi.SQLITE_ERROR;
                    }
                  };
                },
              };

              wasm.bindingSignatures.int64.push(
                ...[
                  [
                    'sqlite3changegroup_add',
                    'int',
                    ['sqlite3_changegroup*', 'int', 'void*'],
                  ],
                  [
                    'sqlite3changegroup_add_strm',
                    'int',
                    [
                      'sqlite3_changegroup*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changegroup_delete',
                    undefined,
                    ['sqlite3_changegroup*'],
                  ],
                  ['sqlite3changegroup_new', 'int', ['**']],
                  [
                    'sqlite3changegroup_output',
                    'int',
                    ['sqlite3_changegroup*', 'int*', '**'],
                  ],
                  [
                    'sqlite3changegroup_output_strm',
                    'int',
                    [
                      'sqlite3_changegroup*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xOutput',
                        signature: 'i(ppi)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changeset_apply',
                    'int',
                    [
                      'sqlite3*',
                      'int',
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xFilter',
                        bindScope: 'transient',
                        ...__ipsProxy,
                      }),
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xConflict',
                        signature: 'i(pip)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changeset_apply_strm',
                    'int',
                    [
                      'sqlite3*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xFilter',
                        bindScope: 'transient',
                        ...__ipsProxy,
                      }),
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xConflict',
                        signature: 'i(pip)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changeset_apply_v2',
                    'int',
                    [
                      'sqlite3*',
                      'int',
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xFilter',
                        bindScope: 'transient',
                        ...__ipsProxy,
                      }),
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xConflict',
                        signature: 'i(pip)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      '**',
                      'int*',
                      'int',
                    ],
                  ],
                  [
                    'sqlite3changeset_apply_v2_strm',
                    'int',
                    [
                      'sqlite3*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xFilter',
                        bindScope: 'transient',
                        ...__ipsProxy,
                      }),
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xConflict',
                        signature: 'i(pip)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      '**',
                      'int*',
                      'int',
                    ],
                  ],
                  [
                    'sqlite3changeset_concat',
                    'int',
                    ['int', 'void*', 'int', 'void*', 'int*', '**'],
                  ],
                  [
                    'sqlite3changeset_concat_strm',
                    'int',
                    [
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInputA',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInputB',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xOutput',
                        signature: 'i(ppi)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changeset_conflict',
                    'int',
                    ['sqlite3_changeset_iter*', 'int', '**'],
                  ],
                  ['sqlite3changeset_finalize', 'int', ['sqlite3_changeset_iter*']],
                  [
                    'sqlite3changeset_fk_conflicts',
                    'int',
                    ['sqlite3_changeset_iter*', 'int*'],
                  ],
                  [
                    'sqlite3changeset_invert',
                    'int',
                    ['int', 'void*', 'int*', '**'],
                  ],
                  [
                    'sqlite3changeset_invert_strm',
                    'int',
                    [
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xOutput',
                        signature: 'i(ppi)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3changeset_new',
                    'int',
                    ['sqlite3_changeset_iter*', 'int', '**'],
                  ],
                  ['sqlite3changeset_next', 'int', ['sqlite3_changeset_iter*']],
                  [
                    'sqlite3changeset_old',
                    'int',
                    ['sqlite3_changeset_iter*', 'int', '**'],
                  ],
                  [
                    'sqlite3changeset_op',
                    'int',
                    ['sqlite3_changeset_iter*', '**', 'int*', 'int*', 'int*'],
                  ],
                  [
                    'sqlite3changeset_pk',
                    'int',
                    ['sqlite3_changeset_iter*', '**', 'int*'],
                  ],
                  ['sqlite3changeset_start', 'int', ['**', 'int', '*']],
                  [
                    'sqlite3changeset_start_strm',
                    'int',
                    [
                      '**',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  ['sqlite3changeset_start_v2', 'int', ['**', 'int', '*', 'int']],
                  [
                    'sqlite3changeset_start_v2_strm',
                    'int',
                    [
                      '**',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xInput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                      'int',
                    ],
                  ],
                  ['sqlite3session_attach', 'int', ['sqlite3_session*', 'string']],
                  [
                    'sqlite3session_changeset',
                    'int',
                    ['sqlite3_session*', 'int*', '**'],
                  ],
                  ['sqlite3session_changeset_size', 'i64', ['sqlite3_session*']],
                  [
                    'sqlite3session_changeset_strm',
                    'int',
                    [
                      'sqlite3_session*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xOutput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  ['sqlite3session_config', 'int', ['int', 'void*']],
                  ['sqlite3session_create', 'int', ['sqlite3*', 'string', '**']],

                  [
                    'sqlite3session_diff',
                    'int',
                    ['sqlite3_session*', 'string', 'string', '**'],
                  ],
                  ['sqlite3session_enable', 'int', ['sqlite3_session*', 'int']],
                  ['sqlite3session_indirect', 'int', ['sqlite3_session*', 'int']],
                  ['sqlite3session_isempty', 'int', ['sqlite3_session*']],
                  ['sqlite3session_memory_used', 'i64', ['sqlite3_session*']],
                  [
                    'sqlite3session_object_config',
                    'int',
                    ['sqlite3_session*', 'int', 'void*'],
                  ],
                  [
                    'sqlite3session_patchset',
                    'int',
                    ['sqlite3_session*', '*', '**'],
                  ],
                  [
                    'sqlite3session_patchset_strm',
                    'int',
                    [
                      'sqlite3_session*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xOutput',
                        signature: 'i(ppp)',
                        bindScope: 'transient',
                      }),
                      'void*',
                    ],
                  ],
                  [
                    'sqlite3session_table_filter',
                    undefined,
                    [
                      'sqlite3_session*',
                      new wasm.xWrap.FuncPtrAdapter({
                        name: 'xFilter',
                        ...__ipsProxy,
                        contextKey: (argv, argIndex) => argv[0],
                      }),
                      '*',
                    ],
                  ],
                ],
              );
            }

            wasm.bindingSignatures.wasm = [
              ['sqlite3_wasm_db_reset', 'int', 'sqlite3*'],
              ['sqlite3_wasm_db_vfs', 'sqlite3_vfs*', 'sqlite3*', 'string'],
              [
                'sqlite3_wasm_vfs_create_file',
                'int',
                'sqlite3_vfs*',
                'string',
                '*',
                'int',
              ],
              ['sqlite3_wasm_posix_create_file', 'int', 'string', '*', 'int'],
              ['sqlite3_wasm_vfs_unlink', 'int', 'sqlite3_vfs*', 'string'],
            ];

            sqlite3.StructBinder = globalThis.Jaccwabyt({
              heap: wasm.heap8u,
              alloc: wasm.alloc,
              dealloc: wasm.dealloc,
              bigIntEnabled: wasm.bigIntEnabled,
              memberPrefix: '$',
            });
            delete globalThis.Jaccwabyt;

            {
              const __xString = wasm.xWrap.argAdapter('string');
              wasm.xWrap.argAdapter('string:flexible', (v) =>
                __xString(util.flexibleString(v)),
              );

              wasm.xWrap.argAdapter(
                'string:static',
                function (v) {
                  if (wasm.isPtr(v)) return v;
                  v = '' + v;
                  let rc = this[v];
                  return rc || (this[v] = wasm.allocCString(v));
                }.bind(Object.create(null)),
              );

              const __xArgPtr = wasm.xWrap.argAdapter('*');
              const nilType = function () {};
              wasm.xWrap.argAdapter('sqlite3_filename', __xArgPtr)(
                'sqlite3_context*',
                __xArgPtr,
              )('sqlite3_value*', __xArgPtr)('void*', __xArgPtr)(
                'sqlite3_changegroup*',
                __xArgPtr,
              )('sqlite3_changeset_iter*', __xArgPtr)(
                'sqlite3_session*',
                __xArgPtr,
              )('sqlite3_stmt*', (v) =>
                __xArgPtr(
                  v instanceof (sqlite3?.oo1?.Stmt || nilType) ? v.pointer : v,
                ),
              )('sqlite3*', (v) =>
                __xArgPtr(
                  v instanceof (sqlite3?.oo1?.DB || nilType) ? v.pointer : v,
                ),
              )('sqlite3_index_info*', (v) =>
                __xArgPtr(
                  v instanceof (capi.sqlite3_index_info || nilType) ? v.pointer : v,
                ),
              )('sqlite3_module*', (v) =>
                __xArgPtr(
                  v instanceof (capi.sqlite3_module || nilType) ? v.pointer : v,
                ),
              )('sqlite3_vfs*', (v) => {
                if ('string' === typeof v) {
                  return (
                    capi.sqlite3_vfs_find(v) ||
                    sqlite3.SQLite3Error.toss(
                      capi.SQLITE_NOTFOUND,
                      'Unknown sqlite3_vfs name:',
                      v,
                    )
                  );
                }
                return __xArgPtr(
                  v instanceof (capi.sqlite3_vfs || nilType) ? v.pointer : v,
                );
              });

              const __xRcPtr = wasm.xWrap.resultAdapter('*');
              wasm.xWrap.resultAdapter('sqlite3*', __xRcPtr)(
                'sqlite3_context*',
                __xRcPtr,
              )('sqlite3_stmt*', __xRcPtr)('sqlite3_value*', __xRcPtr)(
                'sqlite3_vfs*',
                __xRcPtr,
              )('void*', __xRcPtr);

              if (0 === wasm.exports.sqlite3_step.length) {
                wasm.xWrap.doArgcCheck = false;
                sqlite3.config.warn(
                  'Disabling sqlite3.wasm.xWrap.doArgcCheck due to environmental quirks.',
                );
              }
              for (const e of wasm.bindingSignatures) {
                capi[e[0]] = wasm.xWrap.apply(null, e);
              }
              for (const e of wasm.bindingSignatures.wasm) {
                wasm[e[0]] = wasm.xWrap.apply(null, e);
              }

              const fI64Disabled = function (fname) {
                return () =>
                  toss(
                    fname + '() is unavailable due to lack',
                    'of BigInt support in this build.',
                  );
              };
              for (const e of wasm.bindingSignatures.int64) {
                capi[e[0]] = wasm.bigIntEnabled
                  ? wasm.xWrap.apply(null, e)
                  : fI64Disabled(e[0]);
              }

              delete wasm.bindingSignatures;

              if (wasm.exports.sqlite3_wasm_db_error) {
                const __db_err = wasm.xWrap(
                  'sqlite3_wasm_db_error',
                  'int',
                  'sqlite3*',
                  'int',
                  'string',
                );

                util.sqlite3_wasm_db_error = function (pDb, resultCode, message) {
                  if (resultCode instanceof sqlite3.WasmAllocError) {
                    resultCode = capi.SQLITE_NOMEM;
                    message = 0;
                  } else if (resultCode instanceof Error) {
                    message = message || '' + resultCode;
                    resultCode = resultCode.resultCode || capi.SQLITE_ERROR;
                  }
                  return pDb ? __db_err(pDb, resultCode, message) : resultCode;
                };
              } else {
                util.sqlite3_wasm_db_error = function (pDb, errCode, msg) {
                  console.warn(
                    'sqlite3_wasm_db_error() is not exported.',
                    arguments,
                  );
                  return errCode;
                };
              }
            }

            {
              const cJson = wasm.xCall('sqlite3_wasm_enum_json');
              if (!cJson) {
                toss(
                  "Maintenance required: increase sqlite3_wasm_enum_json()'s",
                  'static buffer size!',
                );
              }

              wasm.ctype = JSON.parse(wasm.cstrToJs(cJson));

              const defineGroups = [
                'access',
                'authorizer',
                'blobFinalizers',
                'changeset',
                'config',
                'dataTypes',
                'dbConfig',
                'dbStatus',
                'encodings',
                'fcntl',
                'flock',
                'ioCap',
                'limits',
                'openFlags',
                'prepareFlags',
                'resultCodes',
                'sqlite3Status',
                'stmtStatus',
                'syncFlags',
                'trace',
                'txnState',
                'udfFlags',
                'version',
              ];
              if (wasm.bigIntEnabled) {
                defineGroups.push('serialize', 'session', 'vtab');
              }
              for (const t of defineGroups) {
                for (const e of Object.entries(wasm.ctype[t])) {
                  capi[e[0]] = e[1];
                }
              }
              if (!wasm.functionEntry(capi.SQLITE_WASM_DEALLOC)) {
                toss(
                  'Internal error: cannot resolve exported function',
                  'entry SQLITE_WASM_DEALLOC (==' + capi.SQLITE_WASM_DEALLOC + ').',
                );
              }
              const __rcMap = Object.create(null);
              for (const t of ['resultCodes']) {
                for (const e of Object.entries(wasm.ctype[t])) {
                  __rcMap[e[1]] = e[0];
                }
              }

              capi.sqlite3_js_rc_str = (rc) => __rcMap[rc];

              const notThese = Object.assign(Object.create(null), {
                WasmTestStruct: true,

                sqlite3_kvvfs_methods: !util.isUIThread(),

                sqlite3_index_info: !wasm.bigIntEnabled,
                sqlite3_index_constraint: !wasm.bigIntEnabled,
                sqlite3_index_orderby: !wasm.bigIntEnabled,
                sqlite3_index_constraint_usage: !wasm.bigIntEnabled,
              });
              for (const s of wasm.ctype.structs) {
                if (!notThese[s.name]) {
                  capi[s.name] = sqlite3.StructBinder(s);
                }
              }
              if (capi.sqlite3_index_info) {
                for (const k of [
                  'sqlite3_index_constraint',
                  'sqlite3_index_orderby',
                  'sqlite3_index_constraint_usage',
                ]) {
                  capi.sqlite3_index_info[k] = capi[k];
                  delete capi[k];
                }
                capi.sqlite3_vtab_config = wasm.xWrap(
                  'sqlite3_wasm_vtab_config',
                  'int',
                  ['sqlite3*', 'int', 'int'],
                );
              }
            }

            const __dbArgcMismatch = (pDb, f, n) => {
              return util.sqlite3_wasm_db_error(
                pDb,
                capi.SQLITE_MISUSE,
                f + '() requires ' + n + ' argument' + (1 === n ? '' : 's') + '.',
              );
            };

            const __errEncoding = (pDb) => {
              return util.sqlite3_wasm_db_error(
                pDb,
                capi.SQLITE_FORMAT,
                'SQLITE_UTF8 is the only supported encoding.',
              );
            };

            const __argPDb = (pDb) => wasm.xWrap.argAdapter('sqlite3*')(pDb);
            const __argStr = (str) => (wasm.isPtr(str) ? wasm.cstrToJs(str) : str);
            const __dbCleanupMap = function (pDb, mode) {
              pDb = __argPDb(pDb);
              let m = this.dbMap.get(pDb);
              if (!mode) {
                this.dbMap.delete(pDb);
                return m;
              } else if (!m && mode > 0) {
                this.dbMap.set(pDb, (m = Object.create(null)));
              }
              return m;
            }.bind(
              Object.assign(Object.create(null), {
                dbMap: new Map(),
              }),
            );

            __dbCleanupMap.addCollation = function (pDb, name) {
              const m = __dbCleanupMap(pDb, 1);
              if (!m.collation) m.collation = new Set();
              m.collation.add(__argStr(name).toLowerCase());
            };

            __dbCleanupMap._addUDF = function (pDb, name, arity, map) {
              name = __argStr(name).toLowerCase();
              let u = map.get(name);
              if (!u) map.set(name, (u = new Set()));
              u.add(arity < 0 ? -1 : arity);
            };

            __dbCleanupMap.addFunction = function (pDb, name, arity) {
              const m = __dbCleanupMap(pDb, 1);
              if (!m.udf) m.udf = new Map();
              this._addUDF(pDb, name, arity, m.udf);
            };

            __dbCleanupMap.addWindowFunc = function (pDb, name, arity) {
              const m = __dbCleanupMap(pDb, 1);
              if (!m.wudf) m.wudf = new Map();
              this._addUDF(pDb, name, arity, m.wudf);
            };

            __dbCleanupMap.cleanup = function (pDb) {
              pDb = __argPDb(pDb);

              const closeArgs = [pDb];
              for (const name of [
                'sqlite3_busy_handler',
                'sqlite3_commit_hook',
                'sqlite3_preupdate_hook',
                'sqlite3_progress_handler',
                'sqlite3_rollback_hook',
                'sqlite3_set_authorizer',
                'sqlite3_trace_v2',
                'sqlite3_update_hook',
              ]) {
                const x = wasm.exports[name];
                closeArgs.length = x.length;
                try {
                  capi[name](...closeArgs);
                } catch (e) {
                  console.warn(
                    'close-time call of',
                    name + '(',
                    closeArgs,
                    ') threw:',
                    e,
                  );
                }
              }
              const m = __dbCleanupMap(pDb, 0);
              if (!m) return;
              if (m.collation) {
                for (const name of m.collation) {
                  try {
                    capi.sqlite3_create_collation_v2(
                      pDb,
                      name,
                      capi.SQLITE_UTF8,
                      0,
                      0,
                      0,
                    );
                  } catch (e) {}
                }
                delete m.collation;
              }
              let i;
              for (i = 0; i < 2; ++i) {
                const fmap = i ? m.wudf : m.udf;
                if (!fmap) continue;
                const func = i
                  ? capi.sqlite3_create_window_function
                  : capi.sqlite3_create_function_v2;
                for (const e of fmap) {
                  const name = e[0],
                    arities = e[1];
                  const fargs = [pDb, name, 0, capi.SQLITE_UTF8, 0, 0, 0, 0, 0];
                  if (i) fargs.push(0);
                  for (const arity of arities) {
                    try {
                      fargs[2] = arity;
                      func.apply(null, fargs);
                    } catch (e) {}
                  }
                  arities.clear();
                }
                fmap.clear();
              }
              delete m.udf;
              delete m.wudf;
            };

            {
              const __sqlite3CloseV2 = wasm.xWrap(
                'sqlite3_close_v2',
                'int',
                'sqlite3*',
              );
              capi.sqlite3_close_v2 = function (pDb) {
                if (1 !== arguments.length)
                  return __dbArgcMismatch(pDb, 'sqlite3_close_v2', 1);
                if (pDb) {
                  try {
                    __dbCleanupMap.cleanup(pDb);
                  } catch (e) {}
                }
                return __sqlite3CloseV2(pDb);
              };
            }

            if (capi.sqlite3session_table_filter) {
              const __sqlite3SessionDelete = wasm.xWrap(
                'sqlite3session_delete',
                undefined,
                ['sqlite3_session*'],
              );
              capi.sqlite3session_delete = function (pSession) {
                if (1 !== arguments.length) {
                  return __dbArgcMismatch(pDb, 'sqlite3session_delete', 1);
                } else if (pSession) {
                  capi.sqlite3session_table_filter(pSession, 0, 0);
                }
                __sqlite3SessionDelete(pSession);
              };
            }

            {
              const contextKey = (argv, argIndex) => {
                return (
                  'argv[' +
                  argIndex +
                  ']:' +
                  argv[0] +
                  ':' +
                  wasm.cstrToJs(argv[1]).toLowerCase()
                );
              };
              const __sqlite3CreateCollationV2 = wasm.xWrap(
                'sqlite3_create_collation_v2',
                'int',
                [
                  'sqlite3*',
                  'string',
                  'int',
                  '*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xCompare',
                    signature: 'i(pipip)',
                    contextKey,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xDestroy',
                    signature: 'v(p)',
                    contextKey,
                  }),
                ],
              );

              capi.sqlite3_create_collation_v2 = function (
                pDb,
                zName,
                eTextRep,
                pArg,
                xCompare,
                xDestroy,
              ) {
                if (6 !== arguments.length)
                  return __dbArgcMismatch(pDb, 'sqlite3_create_collation_v2', 6);
                else if (0 === (eTextRep & 0xf)) {
                  eTextRep |= capi.SQLITE_UTF8;
                } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
                  return __errEncoding(pDb);
                }
                try {
                  const rc = __sqlite3CreateCollationV2(
                    pDb,
                    zName,
                    eTextRep,
                    pArg,
                    xCompare,
                    xDestroy,
                  );
                  if (0 === rc && xCompare instanceof Function) {
                    __dbCleanupMap.addCollation(pDb, zName);
                  }
                  return rc;
                } catch (e) {
                  return util.sqlite3_wasm_db_error(pDb, e);
                }
              };

              capi.sqlite3_create_collation = (
                pDb,
                zName,
                eTextRep,
                pArg,
                xCompare,
              ) => {
                return 5 === arguments.length
                  ? capi.sqlite3_create_collation_v2(
                      pDb,
                      zName,
                      eTextRep,
                      pArg,
                      xCompare,
                      0,
                    )
                  : __dbArgcMismatch(pDb, 'sqlite3_create_collation', 5);
              };
            }

            {
              const contextKey = function (argv, argIndex) {
                return (
                  argv[0] +
                  ':' +
                  (argv[2] < 0 ? -1 : argv[2]) +
                  ':' +
                  argIndex +
                  ':' +
                  wasm.cstrToJs(argv[1]).toLowerCase()
                );
              };

              const __cfProxy = Object.assign(Object.create(null), {
                xInverseAndStep: {
                  signature: 'v(pip)',
                  contextKey,
                  callProxy: (callback) => {
                    return (pCtx, argc, pArgv) => {
                      try {
                        callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv));
                      } catch (e) {
                        capi.sqlite3_result_error_js(pCtx, e);
                      }
                    };
                  },
                },
                xFinalAndValue: {
                  signature: 'v(p)',
                  contextKey,
                  callProxy: (callback) => {
                    return (pCtx) => {
                      try {
                        capi.sqlite3_result_js(pCtx, callback(pCtx));
                      } catch (e) {
                        capi.sqlite3_result_error_js(pCtx, e);
                      }
                    };
                  },
                },
                xFunc: {
                  signature: 'v(pip)',
                  contextKey,
                  callProxy: (callback) => {
                    return (pCtx, argc, pArgv) => {
                      try {
                        capi.sqlite3_result_js(
                          pCtx,
                          callback(pCtx, ...capi.sqlite3_values_to_js(argc, pArgv)),
                        );
                      } catch (e) {
                        capi.sqlite3_result_error_js(pCtx, e);
                      }
                    };
                  },
                },
                xDestroy: {
                  signature: 'v(p)',
                  contextKey,

                  callProxy: (callback) => {
                    return (pVoid) => {
                      try {
                        callback(pVoid);
                      } catch (e) {
                        console.error('UDF xDestroy method threw:', e);
                      }
                    };
                  },
                },
              });

              const __sqlite3CreateFunction = wasm.xWrap(
                'sqlite3_create_function_v2',
                'int',
                [
                  'sqlite3*',
                  'string',
                  'int',
                  'int',
                  '*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFunc',
                    ...__cfProxy.xFunc,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xStep',
                    ...__cfProxy.xInverseAndStep,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFinal',
                    ...__cfProxy.xFinalAndValue,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xDestroy',
                    ...__cfProxy.xDestroy,
                  }),
                ],
              );

              const __sqlite3CreateWindowFunction = wasm.xWrap(
                'sqlite3_create_window_function',
                'int',
                [
                  'sqlite3*',
                  'string',
                  'int',
                  'int',
                  '*',
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xStep',
                    ...__cfProxy.xInverseAndStep,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xFinal',
                    ...__cfProxy.xFinalAndValue,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xValue',
                    ...__cfProxy.xFinalAndValue,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xInverse',
                    ...__cfProxy.xInverseAndStep,
                  }),
                  new wasm.xWrap.FuncPtrAdapter({
                    name: 'xDestroy',
                    ...__cfProxy.xDestroy,
                  }),
                ],
              );

              capi.sqlite3_create_function_v2 = function f(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
                xDestroy,
              ) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    pDb,
                    'sqlite3_create_function_v2',
                    f.length,
                  );
                } else if (0 === (eTextRep & 0xf)) {
                  eTextRep |= capi.SQLITE_UTF8;
                } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
                  return __errEncoding(pDb);
                }
                try {
                  const rc = __sqlite3CreateFunction(
                    pDb,
                    funcName,
                    nArg,
                    eTextRep,
                    pApp,
                    xFunc,
                    xStep,
                    xFinal,
                    xDestroy,
                  );
                  if (
                    0 === rc &&
                    (xFunc instanceof Function ||
                      xStep instanceof Function ||
                      xFinal instanceof Function ||
                      xDestroy instanceof Function)
                  ) {
                    __dbCleanupMap.addFunction(pDb, funcName, nArg);
                  }
                  return rc;
                } catch (e) {
                  console.error('sqlite3_create_function_v2() setup threw:', e);
                  return util.sqlite3_wasm_db_error(
                    pDb,
                    e,
                    'Creation of UDF threw: ' + e,
                  );
                }
              };

              capi.sqlite3_create_function = function f(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xFunc,
                xStep,
                xFinal,
              ) {
                return f.length === arguments.length
                  ? capi.sqlite3_create_function_v2(
                      pDb,
                      funcName,
                      nArg,
                      eTextRep,
                      pApp,
                      xFunc,
                      xStep,
                      xFinal,
                      0,
                    )
                  : __dbArgcMismatch(pDb, 'sqlite3_create_function', f.length);
              };

              capi.sqlite3_create_window_function = function f(
                pDb,
                funcName,
                nArg,
                eTextRep,
                pApp,
                xStep,
                xFinal,
                xValue,
                xInverse,
                xDestroy,
              ) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    pDb,
                    'sqlite3_create_window_function',
                    f.length,
                  );
                } else if (0 === (eTextRep & 0xf)) {
                  eTextRep |= capi.SQLITE_UTF8;
                } else if (capi.SQLITE_UTF8 !== (eTextRep & 0xf)) {
                  return __errEncoding(pDb);
                }
                try {
                  const rc = __sqlite3CreateWindowFunction(
                    pDb,
                    funcName,
                    nArg,
                    eTextRep,
                    pApp,
                    xStep,
                    xFinal,
                    xValue,
                    xInverse,
                    xDestroy,
                  );
                  if (
                    0 === rc &&
                    (xStep instanceof Function ||
                      xFinal instanceof Function ||
                      xValue instanceof Function ||
                      xInverse instanceof Function ||
                      xDestroy instanceof Function)
                  ) {
                    __dbCleanupMap.addWindowFunc(pDb, funcName, nArg);
                  }
                  return rc;
                } catch (e) {
                  console.error('sqlite3_create_window_function() setup threw:', e);
                  return util.sqlite3_wasm_db_error(
                    pDb,
                    e,
                    'Creation of UDF threw: ' + e,
                  );
                }
              };

              capi.sqlite3_create_function_v2.udfSetResult =
                capi.sqlite3_create_function.udfSetResult =
                capi.sqlite3_create_window_function.udfSetResult =
                  capi.sqlite3_result_js;

              capi.sqlite3_create_function_v2.udfConvertArgs =
                capi.sqlite3_create_function.udfConvertArgs =
                capi.sqlite3_create_window_function.udfConvertArgs =
                  capi.sqlite3_values_to_js;

              capi.sqlite3_create_function_v2.udfSetError =
                capi.sqlite3_create_function.udfSetError =
                capi.sqlite3_create_window_function.udfSetError =
                  capi.sqlite3_result_error_js;
            }

            {
              const __flexiString = (v, n) => {
                if ('string' === typeof v) {
                  n = -1;
                } else if (util.isSQLableTypedArray(v)) {
                  n = v.byteLength;
                  v = util.typedArrayToString(
                    v instanceof ArrayBuffer ? new Uint8Array(v) : v,
                  );
                } else if (Array.isArray(v)) {
                  v = v.join('');
                  n = -1;
                }
                return [v, n];
              };

              const __prepare = {
                basic: wasm.xWrap('sqlite3_prepare_v3', 'int', [
                  'sqlite3*',
                  'string',
                  'int',
                  'int',
                  '**',
                  '**',
                ]),

                full: wasm.xWrap('sqlite3_prepare_v3', 'int', [
                  'sqlite3*',
                  '*',
                  'int',
                  'int',
                  '**',
                  '**',
                ]),
              };

              capi.sqlite3_prepare_v3 = function f(
                pDb,
                sql,
                sqlLen,
                prepFlags,
                ppStmt,
                pzTail,
              ) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(pDb, 'sqlite3_prepare_v3', f.length);
                }
                const [xSql, xSqlLen] = __flexiString(sql, sqlLen);
                switch (typeof xSql) {
                  case 'string':
                    return __prepare.basic(
                      pDb,
                      xSql,
                      xSqlLen,
                      prepFlags,
                      ppStmt,
                      null,
                    );
                  case 'number':
                    return __prepare.full(
                      pDb,
                      xSql,
                      xSqlLen,
                      prepFlags,
                      ppStmt,
                      pzTail,
                    );
                  default:
                    return util.sqlite3_wasm_db_error(
                      pDb,
                      capi.SQLITE_MISUSE,
                      'Invalid SQL argument type for sqlite3_prepare_v2/v3().',
                    );
                }
              };

              capi.sqlite3_prepare_v2 = function f(
                pDb,
                sql,
                sqlLen,
                ppStmt,
                pzTail,
              ) {
                return f.length === arguments.length
                  ? capi.sqlite3_prepare_v3(pDb, sql, sqlLen, 0, ppStmt, pzTail)
                  : __dbArgcMismatch(pDb, 'sqlite3_prepare_v2', f.length);
              };
            }

            {
              const __bindText = wasm.xWrap('sqlite3_bind_text', 'int', [
                'sqlite3_stmt*',
                'int',
                'string',
                'int',
                '*',
              ]);
              const __bindBlob = wasm.xWrap('sqlite3_bind_blob', 'int', [
                'sqlite3_stmt*',
                'int',
                '*',
                'int',
                '*',
              ]);

              capi.sqlite3_bind_text = function f(
                pStmt,
                iCol,
                text,
                nText,
                xDestroy,
              ) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    capi.sqlite3_db_handle(pStmt),
                    'sqlite3_bind_text',
                    f.length,
                  );
                } else if (wasm.isPtr(text) || null === text) {
                  return __bindText(pStmt, iCol, text, nText, xDestroy);
                } else if (text instanceof ArrayBuffer) {
                  text = new Uint8Array(text);
                } else if (Array.isArray(pMem)) {
                  text = pMem.join('');
                }
                let p, n;
                try {
                  if (util.isSQLableTypedArray(text)) {
                    p = wasm.allocFromTypedArray(text);
                    n = text.byteLength;
                  } else if ('string' === typeof text) {
                    [p, n] = wasm.allocCString(text);
                  } else {
                    return util.sqlite3_wasm_db_error(
                      capi.sqlite3_db_handle(pStmt),
                      capi.SQLITE_MISUSE,
                      'Invalid 3rd argument type for sqlite3_bind_text().',
                    );
                  }
                  return __bindText(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
                } catch (e) {
                  wasm.dealloc(p);
                  return util.sqlite3_wasm_db_error(
                    capi.sqlite3_db_handle(pStmt),
                    e,
                  );
                }
              };

              capi.sqlite3_bind_blob = function f(
                pStmt,
                iCol,
                pMem,
                nMem,
                xDestroy,
              ) {
                if (f.length !== arguments.length) {
                  return __dbArgcMismatch(
                    capi.sqlite3_db_handle(pStmt),
                    'sqlite3_bind_blob',
                    f.length,
                  );
                } else if (wasm.isPtr(pMem) || null === pMem) {
                  return __bindBlob(pStmt, iCol, pMem, nMem, xDestroy);
                } else if (pMem instanceof ArrayBuffer) {
                  pMem = new Uint8Array(pMem);
                } else if (Array.isArray(pMem)) {
                  pMem = pMem.join('');
                }
                let p, n;
                try {
                  if (util.isBindableTypedArray(pMem)) {
                    p = wasm.allocFromTypedArray(pMem);
                    n = nMem >= 0 ? nMem : pMem.byteLength;
                  } else if ('string' === typeof pMem) {
                    [p, n] = wasm.allocCString(pMem);
                  } else {
                    return util.sqlite3_wasm_db_error(
                      capi.sqlite3_db_handle(pStmt),
                      capi.SQLITE_MISUSE,
                      'Invalid 3rd argument type for sqlite3_bind_blob().',
                    );
                  }
                  return __bindBlob(pStmt, iCol, p, n, capi.SQLITE_WASM_DEALLOC);
                } catch (e) {
                  wasm.dealloc(p);
                  return util.sqlite3_wasm_db_error(
                    capi.sqlite3_db_handle(pStmt),
                    e,
                  );
                }
              };
            }

            {
              capi.sqlite3_config = function (op, ...args) {
                if (arguments.length < 2) return capi.SQLITE_MISUSE;
                switch (op) {
                  case capi.SQLITE_CONFIG_COVERING_INDEX_SCAN:
                  case capi.SQLITE_CONFIG_MEMSTATUS:
                  case capi.SQLITE_CONFIG_SMALL_MALLOC:
                  case capi.SQLITE_CONFIG_SORTERREF_SIZE:
                  case capi.SQLITE_CONFIG_STMTJRNL_SPILL:
                  case capi.SQLITE_CONFIG_URI:
                    return wasm.exports.sqlite3_wasm_config_i(op, args[0]);
                  case capi.SQLITE_CONFIG_LOOKASIDE:
                    return wasm.exports.sqlite3_wasm_config_ii(
                      op,
                      args[0],
                      args[1],
                    );
                  case capi.SQLITE_CONFIG_MEMDB_MAXSIZE:
                    return wasm.exports.sqlite3_wasm_config_j(op, args[0]);
                  case capi.SQLITE_CONFIG_GETMALLOC:
                  case capi.SQLITE_CONFIG_GETMUTEX:
                  case capi.SQLITE_CONFIG_GETPCACHE2:
                  case capi.SQLITE_CONFIG_GETPCACHE:
                  case capi.SQLITE_CONFIG_HEAP:
                  case capi.SQLITE_CONFIG_LOG:
                  case capi.SQLITE_CONFIG_MALLOC:
                  case capi.SQLITE_CONFIG_MMAP_SIZE:
                  case capi.SQLITE_CONFIG_MULTITHREAD:
                  case capi.SQLITE_CONFIG_MUTEX:
                  case capi.SQLITE_CONFIG_PAGECACHE:
                  case capi.SQLITE_CONFIG_PCACHE2:
                  case capi.SQLITE_CONFIG_PCACHE:
                  case capi.SQLITE_CONFIG_PCACHE_HDRSZ:
                  case capi.SQLITE_CONFIG_PMASZ:
                  case capi.SQLITE_CONFIG_SERIALIZED:
                  case capi.SQLITE_CONFIG_SINGLETHREAD:
                  case capi.SQLITE_CONFIG_SQLLOG:
                  case capi.SQLITE_CONFIG_WIN32_HEAPSIZE:
                  default:
                    return capi.SQLITE_NOTFOUND;
                }
              };
            }

            {
              const __autoExtFptr = new Set();

              capi.sqlite3_auto_extension = function (fPtr) {
                if (fPtr instanceof Function) {
                  fPtr = wasm.installFunction('i(ppp)', fPtr);
                } else if (1 !== arguments.length || !wasm.isPtr(fPtr)) {
                  return capi.SQLITE_MISUSE;
                }
                const rc = wasm.exports.sqlite3_auto_extension(fPtr);
                if (fPtr !== arguments[0]) {
                  if (0 === rc) __autoExtFptr.add(fPtr);
                  else wasm.uninstallFunction(fPtr);
                }
                return rc;
              };

              capi.sqlite3_cancel_auto_extension = function (fPtr) {
                if (!fPtr || 1 !== arguments.length || !wasm.isPtr(fPtr)) return 0;
                return wasm.exports.sqlite3_cancel_auto_extension(fPtr);
              };

              capi.sqlite3_reset_auto_extension = function () {
                wasm.exports.sqlite3_reset_auto_extension();
                for (const fp of __autoExtFptr) wasm.uninstallFunction(fp);
                __autoExtFptr.clear();
              };
            }

            const pKvvfs = capi.sqlite3_vfs_find('kvvfs');
            if (pKvvfs) {
              if (util.isUIThread()) {
                const kvvfsMethods = new capi.sqlite3_kvvfs_methods(
                  wasm.exports.sqlite3_wasm_kvvfs_methods(),
                );
                delete capi.sqlite3_kvvfs_methods;

                const kvvfsMakeKey = wasm.exports.sqlite3_wasm_kvvfsMakeKeyOnPstack,
                  pstack = wasm.pstack;

                const kvvfsStorage = (zClass) =>
                  115 === wasm.peek(zClass) ? sessionStorage : localStorage;

                const kvvfsImpls = {
                  xRead: (zClass, zKey, zBuf, nBuf) => {
                    const stack = pstack.pointer,
                      astack = wasm.scopedAllocPush();
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return -3;
                      const jKey = wasm.cstrToJs(zXKey);
                      const jV = kvvfsStorage(zClass).getItem(jKey);
                      if (!jV) return -1;
                      const nV = jV.length;
                      if (nBuf <= 0) return nV;
                      else if (1 === nBuf) {
                        wasm.poke(zBuf, 0);
                        return nV;
                      }
                      const zV = wasm.scopedAllocCString(jV);
                      if (nBuf > nV + 1) nBuf = nV + 1;
                      wasm.heap8u().copyWithin(zBuf, zV, zV + nBuf - 1);
                      wasm.poke(zBuf + nBuf - 1, 0);
                      return nBuf - 1;
                    } catch (e) {
                      console.error('kvstorageRead()', e);
                      return -2;
                    } finally {
                      pstack.restore(stack);
                      wasm.scopedAllocPop(astack);
                    }
                  },
                  xWrite: (zClass, zKey, zData) => {
                    const stack = pstack.pointer;
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return 1;
                      const jKey = wasm.cstrToJs(zXKey);
                      kvvfsStorage(zClass).setItem(jKey, wasm.cstrToJs(zData));
                      return 0;
                    } catch (e) {
                      console.error('kvstorageWrite()', e);
                      return capi.SQLITE_IOERR;
                    } finally {
                      pstack.restore(stack);
                    }
                  },
                  xDelete: (zClass, zKey) => {
                    const stack = pstack.pointer;
                    try {
                      const zXKey = kvvfsMakeKey(zClass, zKey);
                      if (!zXKey) return 1;
                      kvvfsStorage(zClass).removeItem(wasm.cstrToJs(zXKey));
                      return 0;
                    } catch (e) {
                      console.error('kvstorageDelete()', e);
                      return capi.SQLITE_IOERR;
                    } finally {
                      pstack.restore(stack);
                    }
                  },
                };
                for (const k of Object.keys(kvvfsImpls)) {
                  kvvfsMethods[kvvfsMethods.memberKey(k)] = wasm.installFunction(
                    kvvfsMethods.memberSignature(k),
                    kvvfsImpls[k],
                  );
                }
              } else {
                capi.sqlite3_vfs_unregister(pKvvfs);
              }
            }

            wasm.xWrap.FuncPtrAdapter.warnOnUse = true;
          });

          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            sqlite3.version = {
              libVersion: '3.45.2',
              libVersionNumber: 3045002,
              sourceId:
                '2024-03-12 11:06:23 d8cd6d49b46a395b13955387d05e9e1a2a47e54fb99f3c9b59835bbefad6af77',
              downloadVersion: 3450200,
            };
          });

          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            const toss3 = (...args) => {
              throw new sqlite3.SQLite3Error(...args);
            };

            const capi = sqlite3.capi,
              wasm = sqlite3.wasm,
              util = sqlite3.util;

            const __ptrMap = new WeakMap();

            const __stmtMap = new WeakMap();

            const getOwnOption = (opts, p, dflt) => {
              const d = Object.getOwnPropertyDescriptor(opts, p);
              return d ? d.value : dflt;
            };

            const checkSqlite3Rc = function (dbPtr, sqliteResultCode) {
              if (sqliteResultCode) {
                if (dbPtr instanceof DB) dbPtr = dbPtr.pointer;
                toss3(
                  sqliteResultCode,
                  'sqlite3 result code',
                  sqliteResultCode + ':',
                  dbPtr
                    ? capi.sqlite3_errmsg(dbPtr)
                    : capi.sqlite3_errstr(sqliteResultCode),
                );
              }
              return arguments[0];
            };

            const __dbTraceToConsole = wasm.installFunction(
              'i(ippp)',
              function (t, c, p, x) {
                if (capi.SQLITE_TRACE_STMT === t) {
                  console.log(
                    'SQL TRACE #' + ++this.counter + ' via sqlite3@' + c + ':',
                    wasm.cstrToJs(x),
                  );
                }
              }.bind({ counter: 0 }),
            );

            const __vfsPostOpenSql = Object.create(null);

            const dbCtorHelper = function ctor(...args) {
              if (!ctor._name2vfs) {
                ctor._name2vfs = Object.create(null);
                const isWorkerThread =
                  'function' === typeof importScripts
                    ? (n) =>
                        toss3(
                          'The VFS for',
                          n,
                          'is only available in the main window thread.',
                        )
                    : false;
                ctor._name2vfs[':localStorage:'] = {
                  vfs: 'kvvfs',
                  filename: isWorkerThread || (() => 'local'),
                };
                ctor._name2vfs[':sessionStorage:'] = {
                  vfs: 'kvvfs',
                  filename: isWorkerThread || (() => 'session'),
                };
              }
              const opt = ctor.normalizeArgs(...args);
              let fn = opt.filename,
                vfsName = opt.vfs,
                flagsStr = opt.flags;
              if (
                ('string' !== typeof fn && 'number' !== typeof fn) ||
                'string' !== typeof flagsStr ||
                (vfsName &&
                  'string' !== typeof vfsName &&
                  'number' !== typeof vfsName)
              ) {
                sqlite3.config.error('Invalid DB ctor args', opt, arguments);
                toss3('Invalid arguments for DB constructor.');
              }
              let fnJs = 'number' === typeof fn ? wasm.cstrToJs(fn) : fn;
              const vfsCheck = ctor._name2vfs[fnJs];
              if (vfsCheck) {
                vfsName = vfsCheck.vfs;
                fn = fnJs = vfsCheck.filename(fnJs);
              }
              let pDb,
                oflags = 0;
              if (flagsStr.indexOf('c') >= 0) {
                oflags |= capi.SQLITE_OPEN_CREATE | capi.SQLITE_OPEN_READWRITE;
              }
              if (flagsStr.indexOf('w') >= 0) oflags |= capi.SQLITE_OPEN_READWRITE;
              if (0 === oflags) oflags |= capi.SQLITE_OPEN_READONLY;
              oflags |= capi.SQLITE_OPEN_EXRESCODE;
              const stack = wasm.pstack.pointer;
              try {
                const pPtr = wasm.pstack.allocPtr();
                let rc = capi.sqlite3_open_v2(fn, pPtr, oflags, vfsName || 0);
                pDb = wasm.peekPtr(pPtr);
                checkSqlite3Rc(pDb, rc);
                capi.sqlite3_extended_result_codes(pDb, 1);
                if (flagsStr.indexOf('t') >= 0) {
                  capi.sqlite3_trace_v2(
                    pDb,
                    capi.SQLITE_TRACE_STMT,
                    __dbTraceToConsole,
                    pDb,
                  );
                }
              } catch (e) {
                if (pDb) capi.sqlite3_close_v2(pDb);
                throw e;
              } finally {
                wasm.pstack.restore(stack);
              }
              this.filename = fnJs;
              __ptrMap.set(this, pDb);
              __stmtMap.set(this, Object.create(null));
              try {
                const pVfs = capi.sqlite3_js_db_vfs(pDb);
                if (!pVfs)
                  toss3('Internal error: cannot get VFS for new db handle.');
                const postInitSql = __vfsPostOpenSql[pVfs];
                if (postInitSql instanceof Function) {
                  postInitSql(this, sqlite3);
                } else if (postInitSql) {
                  checkSqlite3Rc(pDb, capi.sqlite3_exec(pDb, postInitSql, 0, 0, 0));
                }
              } catch (e) {
                this.close();
                throw e;
              }
            };

            dbCtorHelper.setVfsPostOpenSql = function (pVfs, sql) {
              __vfsPostOpenSql[pVfs] = sql;
            };

            dbCtorHelper.normalizeArgs = function (
              filename = ':memory:',
              flags = 'c',
              vfs = null,
            ) {
              const arg = {};
              if (
                1 === arguments.length &&
                arguments[0] &&
                'object' === typeof arguments[0]
              ) {
                Object.assign(arg, arguments[0]);
                if (undefined === arg.flags) arg.flags = 'c';
                if (undefined === arg.vfs) arg.vfs = null;
                if (undefined === arg.filename) arg.filename = ':memory:';
              } else {
                arg.filename = filename;
                arg.flags = flags;
                arg.vfs = vfs;
              }
              return arg;
            };

            const DB = function (...args) {
              dbCtorHelper.apply(this, args);
            };
            DB.dbCtorHelper = dbCtorHelper;

            const BindTypes = {
              null: 1,
              number: 2,
              string: 3,
              boolean: 4,
              blob: 5,
            };
            BindTypes['undefined'] == BindTypes.null;
            if (wasm.bigIntEnabled) {
              BindTypes.bigint = BindTypes.number;
            }

            const Stmt = function () {
              if (BindTypes !== arguments[2]) {
                toss3(
                  capi.SQLITE_MISUSE,
                  'Do not call the Stmt constructor directly. Use DB.prepare().',
                );
              }
              this.db = arguments[0];
              __ptrMap.set(this, arguments[1]);
              this.parameterCount = capi.sqlite3_bind_parameter_count(this.pointer);
            };

            const affirmDbOpen = function (db) {
              if (!db.pointer) toss3('DB has been closed.');
              return db;
            };

            const affirmColIndex = function (stmt, ndx) {
              if (ndx !== (ndx | 0) || ndx < 0 || ndx >= stmt.columnCount) {
                toss3('Column index', ndx, 'is out of range.');
              }
              return stmt;
            };

            const parseExecArgs = function (db, args) {
              const out = Object.create(null);
              out.opt = Object.create(null);
              switch (args.length) {
                case 1:
                  if (
                    'string' === typeof args[0] ||
                    util.isSQLableTypedArray(args[0])
                  ) {
                    out.sql = args[0];
                  } else if (Array.isArray(args[0])) {
                    out.sql = args[0];
                  } else if (args[0] && 'object' === typeof args[0]) {
                    out.opt = args[0];
                    out.sql = out.opt.sql;
                  }
                  break;
                case 2:
                  out.sql = args[0];
                  out.opt = args[1];
                  break;
                default:
                  toss3('Invalid argument count for exec().');
              }
              out.sql = util.flexibleString(out.sql);
              if ('string' !== typeof out.sql) {
                toss3('Missing SQL argument or unsupported SQL value type.');
              }
              const opt = out.opt;
              switch (opt.returnValue) {
                case 'resultRows':
                  if (!opt.resultRows) opt.resultRows = [];
                  out.returnVal = () => opt.resultRows;
                  break;
                case 'saveSql':
                  if (!opt.saveSql) opt.saveSql = [];
                  out.returnVal = () => opt.saveSql;
                  break;
                case undefined:
                case 'this':
                  out.returnVal = () => db;
                  break;
                default:
                  toss3('Invalid returnValue value:', opt.returnValue);
              }
              if (!opt.callback && !opt.returnValue && undefined !== opt.rowMode) {
                if (!opt.resultRows) opt.resultRows = [];
                out.returnVal = () => opt.resultRows;
              }
              if (opt.callback || opt.resultRows) {
                switch (undefined === opt.rowMode ? 'array' : opt.rowMode) {
                  case 'object':
                    out.cbArg = (stmt) => stmt.get(Object.create(null));
                    break;
                  case 'array':
                    out.cbArg = (stmt) => stmt.get([]);
                    break;
                  case 'stmt':
                    if (Array.isArray(opt.resultRows)) {
                      toss3(
                        'exec(): invalid rowMode for a resultRows array: must',
                        "be one of 'array', 'object',",
                        'a result column number, or column name reference.',
                      );
                    }
                    out.cbArg = (stmt) => stmt;
                    break;
                  default:
                    if (util.isInt32(opt.rowMode)) {
                      out.cbArg = (stmt) => stmt.get(opt.rowMode);
                      break;
                    } else if (
                      'string' === typeof opt.rowMode &&
                      opt.rowMode.length > 1 &&
                      '$' === opt.rowMode[0]
                    ) {
                      const $colName = opt.rowMode.substr(1);
                      out.cbArg = (stmt) => {
                        const rc = stmt.get(Object.create(null))[$colName];
                        return undefined === rc
                          ? toss3(
                              capi.SQLITE_NOTFOUND,
                              'exec(): unknown result column:',
                              $colName,
                            )
                          : rc;
                      };
                      break;
                    }
                    toss3('Invalid rowMode:', opt.rowMode);
                }
              }
              return out;
            };

            const __selectFirstRow = (db, sql, bind, ...getArgs) => {
              const stmt = db.prepare(sql);
              try {
                const rc = stmt.bind(bind).step()
                  ? stmt.get(...getArgs)
                  : undefined;
                stmt.reset();
                return rc;
              } finally {
                stmt.finalize();
              }
            };

            const __selectAll = (db, sql, bind, rowMode) =>
              db.exec({
                sql,
                bind,
                rowMode,
                returnValue: 'resultRows',
              });

            DB.checkRc = (db, resultCode) => checkSqlite3Rc(db, resultCode);

            DB.prototype = {
              isOpen: function () {
                return !!this.pointer;
              },

              affirmOpen: function () {
                return affirmDbOpen(this);
              },

              close: function () {
                if (this.pointer) {
                  if (this.onclose && this.onclose.before instanceof Function) {
                    try {
                      this.onclose.before(this);
                    } catch (e) {}
                  }
                  const pDb = this.pointer;
                  Object.keys(__stmtMap.get(this)).forEach((k, s) => {
                    if (s && s.pointer) {
                      try {
                        s.finalize();
                      } catch (e) {}
                    }
                  });
                  __ptrMap.delete(this);
                  __stmtMap.delete(this);
                  capi.sqlite3_close_v2(pDb);
                  if (this.onclose && this.onclose.after instanceof Function) {
                    try {
                      this.onclose.after(this);
                    } catch (e) {}
                  }
                  delete this.filename;
                }
              },

              changes: function (total = false, sixtyFour = false) {
                const p = affirmDbOpen(this).pointer;
                if (total) {
                  return sixtyFour
                    ? capi.sqlite3_total_changes64(p)
                    : capi.sqlite3_total_changes(p);
                } else {
                  return sixtyFour
                    ? capi.sqlite3_changes64(p)
                    : capi.sqlite3_changes(p);
                }
              },

              dbFilename: function (dbName = 'main') {
                return capi.sqlite3_db_filename(affirmDbOpen(this).pointer, dbName);
              },

              dbName: function (dbNumber = 0) {
                return capi.sqlite3_db_name(affirmDbOpen(this).pointer, dbNumber);
              },

              dbVfsName: function (dbName = 0) {
                let rc;
                const pVfs = capi.sqlite3_js_db_vfs(
                  affirmDbOpen(this).pointer,
                  dbName,
                );
                if (pVfs) {
                  const v = new capi.sqlite3_vfs(pVfs);
                  try {
                    rc = wasm.cstrToJs(v.$zName);
                  } finally {
                    v.dispose();
                  }
                }
                return rc;
              },

              prepare: function (sql) {
                affirmDbOpen(this);
                const stack = wasm.pstack.pointer;
                let ppStmt, pStmt;
                try {
                  ppStmt = wasm.pstack.alloc(8);
                  DB.checkRc(
                    this,
                    capi.sqlite3_prepare_v2(this.pointer, sql, -1, ppStmt, null),
                  );
                  pStmt = wasm.peekPtr(ppStmt);
                } finally {
                  wasm.pstack.restore(stack);
                }
                if (!pStmt) toss3('Cannot prepare empty SQL.');
                const stmt = new Stmt(this, pStmt, BindTypes);
                __stmtMap.get(this)[pStmt] = stmt;
                return stmt;
              },

              exec: function () {
                affirmDbOpen(this);
                const arg = parseExecArgs(this, arguments);
                if (!arg.sql) {
                  return toss3('exec() requires an SQL string.');
                }
                const opt = arg.opt;
                const callback = opt.callback;
                const resultRows = Array.isArray(opt.resultRows)
                  ? opt.resultRows
                  : undefined;
                let stmt;
                let bind = opt.bind;
                let evalFirstResult = !!(
                  arg.cbArg ||
                  opt.columnNames ||
                  resultRows
                );
                const stack = wasm.scopedAllocPush();
                const saveSql = Array.isArray(opt.saveSql)
                  ? opt.saveSql
                  : undefined;
                try {
                  const isTA = util.isSQLableTypedArray(arg.sql);
                  let sqlByteLen = isTA
                    ? arg.sql.byteLength
                    : wasm.jstrlen(arg.sql);
                  const ppStmt = wasm.scopedAlloc(
                    2 * wasm.ptrSizeof + (sqlByteLen + 1),
                  );
                  const pzTail = ppStmt + wasm.ptrSizeof;
                  let pSql = pzTail + wasm.ptrSizeof;
                  const pSqlEnd = pSql + sqlByteLen;
                  if (isTA) wasm.heap8().set(arg.sql, pSql);
                  else wasm.jstrcpy(arg.sql, wasm.heap8(), pSql, sqlByteLen, false);
                  wasm.poke(pSql + sqlByteLen, 0);
                  while (pSql && wasm.peek(pSql, 'i8')) {
                    wasm.pokePtr([ppStmt, pzTail], 0);
                    DB.checkRc(
                      this,
                      capi.sqlite3_prepare_v3(
                        this.pointer,
                        pSql,
                        sqlByteLen,
                        0,
                        ppStmt,
                        pzTail,
                      ),
                    );
                    const pStmt = wasm.peekPtr(ppStmt);
                    pSql = wasm.peekPtr(pzTail);
                    sqlByteLen = pSqlEnd - pSql;
                    if (!pStmt) continue;
                    if (saveSql) saveSql.push(capi.sqlite3_sql(pStmt).trim());
                    stmt = new Stmt(this, pStmt, BindTypes);
                    if (bind && stmt.parameterCount) {
                      stmt.bind(bind);
                      bind = null;
                    }
                    if (evalFirstResult && stmt.columnCount) {
                      let gotColNames = Array.isArray(opt.columnNames) ? 0 : 1;
                      evalFirstResult = false;
                      if (arg.cbArg || resultRows) {
                        for (; stmt.step(); stmt._lockedByExec = false) {
                          if (0 === gotColNames++)
                            stmt.getColumnNames(opt.columnNames);
                          stmt._lockedByExec = true;
                          const row = arg.cbArg(stmt);
                          if (resultRows) resultRows.push(row);
                          if (callback && false === callback.call(opt, row, stmt)) {
                            break;
                          }
                        }
                        stmt._lockedByExec = false;
                      }
                      if (0 === gotColNames) {
                        stmt.getColumnNames(opt.columnNames);
                      }
                    } else {
                      stmt.step();
                    }
                    stmt.reset().finalize();
                    stmt = null;
                  }
                } finally {
                  wasm.scopedAllocPop(stack);
                  if (stmt) {
                    delete stmt._lockedByExec;
                    stmt.finalize();
                  }
                }
                return arg.returnVal();
              },

              createFunction: function f(name, xFunc, opt) {
                const isFunc = (f) => f instanceof Function;
                switch (arguments.length) {
                  case 1:
                    opt = name;
                    name = opt.name;
                    xFunc = opt.xFunc || 0;
                    break;
                  case 2:
                    if (!isFunc(xFunc)) {
                      opt = xFunc;
                      xFunc = opt.xFunc || 0;
                    }
                    break;
                }
                if (!opt) opt = {};
                if ('string' !== typeof name) {
                  toss3('Invalid arguments: missing function name.');
                }
                let xStep = opt.xStep || 0;
                let xFinal = opt.xFinal || 0;
                const xValue = opt.xValue || 0;
                const xInverse = opt.xInverse || 0;
                let isWindow = undefined;
                if (isFunc(xFunc)) {
                  isWindow = false;
                  if (isFunc(xStep) || isFunc(xFinal)) {
                    toss3('Ambiguous arguments: scalar or aggregate?');
                  }
                  xStep = xFinal = null;
                } else if (isFunc(xStep)) {
                  if (!isFunc(xFinal)) {
                    toss3('Missing xFinal() callback for aggregate or window UDF.');
                  }
                  xFunc = null;
                } else if (isFunc(xFinal)) {
                  toss3('Missing xStep() callback for aggregate or window UDF.');
                } else {
                  toss3('Missing function-type properties.');
                }
                if (false === isWindow) {
                  if (isFunc(xValue) || isFunc(xInverse)) {
                    toss3(
                      'xValue and xInverse are not permitted for non-window UDFs.',
                    );
                  }
                } else if (isFunc(xValue)) {
                  if (!isFunc(xInverse)) {
                    toss3('xInverse must be provided if xValue is.');
                  }
                  isWindow = true;
                } else if (isFunc(xInverse)) {
                  toss3('xValue must be provided if xInverse is.');
                }
                const pApp = opt.pApp;
                if (
                  undefined !== pApp &&
                  null !== pApp &&
                  ('number' !== typeof pApp || !util.isInt32(pApp))
                ) {
                  toss3(
                    'Invalid value for pApp property. Must be a legal WASM pointer value.',
                  );
                }
                const xDestroy = opt.xDestroy || 0;
                if (xDestroy && !isFunc(xDestroy)) {
                  toss3('xDestroy property must be a function.');
                }
                let fFlags = 0;
                if (getOwnOption(opt, 'deterministic'))
                  fFlags |= capi.SQLITE_DETERMINISTIC;
                if (getOwnOption(opt, 'directOnly'))
                  fFlags |= capi.SQLITE_DIRECTONLY;
                if (getOwnOption(opt, 'innocuous')) fFlags |= capi.SQLITE_INNOCUOUS;
                name = name.toLowerCase();
                const xArity = xFunc || xStep;
                const arity = getOwnOption(opt, 'arity');
                const arityArg =
                  'number' === typeof arity
                    ? arity
                    : xArity.length
                      ? xArity.length - 1
                      : 0;
                let rc;
                if (isWindow) {
                  rc = capi.sqlite3_create_window_function(
                    this.pointer,
                    name,
                    arityArg,
                    capi.SQLITE_UTF8 | fFlags,
                    pApp || 0,
                    xStep,
                    xFinal,
                    xValue,
                    xInverse,
                    xDestroy,
                  );
                } else {
                  rc = capi.sqlite3_create_function_v2(
                    this.pointer,
                    name,
                    arityArg,
                    capi.SQLITE_UTF8 | fFlags,
                    pApp || 0,
                    xFunc,
                    xStep,
                    xFinal,
                    xDestroy,
                  );
                }
                DB.checkRc(this, rc);
                return this;
              },

              selectValue: function (sql, bind, asType) {
                return __selectFirstRow(this, sql, bind, 0, asType);
              },

              selectValues: function (sql, bind, asType) {
                const stmt = this.prepare(sql),
                  rc = [];
                try {
                  stmt.bind(bind);
                  while (stmt.step()) rc.push(stmt.get(0, asType));
                  stmt.reset();
                } finally {
                  stmt.finalize();
                }
                return rc;
              },

              selectArray: function (sql, bind) {
                return __selectFirstRow(this, sql, bind, []);
              },

              selectObject: function (sql, bind) {
                return __selectFirstRow(this, sql, bind, {});
              },

              selectArrays: function (sql, bind) {
                return __selectAll(this, sql, bind, 'array');
              },

              selectObjects: function (sql, bind) {
                return __selectAll(this, sql, bind, 'object');
              },

              openStatementCount: function () {
                return this.pointer ? Object.keys(__stmtMap.get(this)).length : 0;
              },

              transaction: function (callback) {
                let opener = 'BEGIN';
                if (arguments.length > 1) {
                  if (/[^a-zA-Z]/.test(arguments[0])) {
                    toss3(
                      capi.SQLITE_MISUSE,
                      'Invalid argument for BEGIN qualifier.',
                    );
                  }
                  opener += ' ' + arguments[0];
                  callback = arguments[1];
                }
                affirmDbOpen(this).exec(opener);
                try {
                  const rc = callback(this);
                  this.exec('COMMIT');
                  return rc;
                } catch (e) {
                  this.exec('ROLLBACK');
                  throw e;
                }
              },

              savepoint: function (callback) {
                affirmDbOpen(this).exec('SAVEPOINT oo1');
                try {
                  const rc = callback(this);
                  this.exec('RELEASE oo1');
                  return rc;
                } catch (e) {
                  this.exec('ROLLBACK to SAVEPOINT oo1; RELEASE SAVEPOINT oo1');
                  throw e;
                }
              },

              checkRc: function (resultCode) {
                return checkSqlite3Rc(this, resultCode);
              },
            };

            const affirmStmtOpen = function (stmt) {
              if (!stmt.pointer) toss3('Stmt has been closed.');
              return stmt;
            };

            const isSupportedBindType = function (v) {
              let t = BindTypes[null === v || undefined === v ? 'null' : typeof v];
              switch (t) {
                case BindTypes.boolean:
                case BindTypes.null:
                case BindTypes.number:
                case BindTypes.string:
                  return t;
                case BindTypes.bigint:
                  if (wasm.bigIntEnabled) return t;

                default:
                  return util.isBindableTypedArray(v) ? BindTypes.blob : undefined;
              }
            };

            const affirmSupportedBindType = function (v) {
              return (
                isSupportedBindType(v) ||
                toss3('Unsupported bind() argument type:', typeof v)
              );
            };

            const affirmParamIndex = function (stmt, key) {
              const n =
                'number' === typeof key
                  ? key
                  : capi.sqlite3_bind_parameter_index(stmt.pointer, key);
              if (0 === n || !util.isInt32(n)) {
                toss3('Invalid bind() parameter name: ' + key);
              } else if (n < 1 || n > stmt.parameterCount)
                toss3('Bind index', key, 'is out of range.');
              return n;
            };

            const affirmNotLockedByExec = function (stmt, currentOpName) {
              if (stmt._lockedByExec) {
                toss3(
                  'Operation is illegal when statement is locked:',
                  currentOpName,
                );
              }
              return stmt;
            };

            const bindOne = function f(stmt, ndx, bindType, val) {
              affirmNotLockedByExec(affirmStmtOpen(stmt), 'bind()');
              if (!f._) {
                f._tooBigInt = (v) =>
                  toss3(
                    'BigInt value is too big to store without precision loss:',
                    v,
                  );
                f._ = {
                  string: function (stmt, ndx, val, asBlob) {
                    const [pStr, n] = wasm.allocCString(val, true);
                    const f = asBlob
                      ? capi.sqlite3_bind_blob
                      : capi.sqlite3_bind_text;
                    return f(stmt.pointer, ndx, pStr, n, capi.SQLITE_WASM_DEALLOC);
                  },
                };
              }
              affirmSupportedBindType(val);
              ndx = affirmParamIndex(stmt, ndx);
              let rc = 0;
              switch (
                null === val || undefined === val ? BindTypes.null : bindType
              ) {
                case BindTypes.null:
                  rc = capi.sqlite3_bind_null(stmt.pointer, ndx);
                  break;
                case BindTypes.string:
                  rc = f._.string(stmt, ndx, val, false);
                  break;
                case BindTypes.number: {
                  let m;
                  if (util.isInt32(val)) m = capi.sqlite3_bind_int;
                  else if ('bigint' === typeof val) {
                    if (!util.bigIntFits64(val)) {
                      f._tooBigInt(val);
                    } else if (wasm.bigIntEnabled) {
                      m = capi.sqlite3_bind_int64;
                    } else if (util.bigIntFitsDouble(val)) {
                      val = Number(val);
                      m = capi.sqlite3_bind_double;
                    } else {
                      f._tooBigInt(val);
                    }
                  } else {
                    val = Number(val);
                    if (wasm.bigIntEnabled && Number.isInteger(val)) {
                      m = capi.sqlite3_bind_int64;
                    } else {
                      m = capi.sqlite3_bind_double;
                    }
                  }
                  rc = m(stmt.pointer, ndx, val);
                  break;
                }
                case BindTypes.boolean:
                  rc = capi.sqlite3_bind_int(stmt.pointer, ndx, val ? 1 : 0);
                  break;
                case BindTypes.blob: {
                  if ('string' === typeof val) {
                    rc = f._.string(stmt, ndx, val, true);
                    break;
                  } else if (val instanceof ArrayBuffer) {
                    val = new Uint8Array(val);
                  } else if (!util.isBindableTypedArray(val)) {
                    toss3(
                      'Binding a value as a blob requires',
                      'that it be a string, Uint8Array, Int8Array, or ArrayBuffer.',
                    );
                  }
                  const pBlob = wasm.alloc(val.byteLength || 1);
                  wasm.heap8().set(val.byteLength ? val : [0], pBlob);
                  rc = capi.sqlite3_bind_blob(
                    stmt.pointer,
                    ndx,
                    pBlob,
                    val.byteLength,
                    capi.SQLITE_WASM_DEALLOC,
                  );
                  break;
                }
                default:
                  sqlite3.config.warn('Unsupported bind() argument type:', val);
                  toss3('Unsupported bind() argument type: ' + typeof val);
              }
              if (rc) DB.checkRc(stmt.db.pointer, rc);
              stmt._mayGet = false;
              return stmt;
            };

            Stmt.prototype = {
              finalize: function () {
                if (this.pointer) {
                  affirmNotLockedByExec(this, 'finalize()');
                  const rc = capi.sqlite3_finalize(this.pointer);
                  delete __stmtMap.get(this.db)[this.pointer];
                  __ptrMap.delete(this);
                  delete this._mayGet;
                  delete this.parameterCount;
                  delete this._lockedByExec;
                  delete this.db;
                  return rc;
                }
              },

              clearBindings: function () {
                affirmNotLockedByExec(affirmStmtOpen(this), 'clearBindings()');
                capi.sqlite3_clear_bindings(this.pointer);
                this._mayGet = false;
                return this;
              },

              reset: function (alsoClearBinds) {
                affirmNotLockedByExec(this, 'reset()');
                if (alsoClearBinds) this.clearBindings();
                const rc = capi.sqlite3_reset(affirmStmtOpen(this).pointer);
                this._mayGet = false;
                checkSqlite3Rc(this.db, rc);
                return this;
              },

              bind: function () {
                affirmStmtOpen(this);
                let ndx, arg;
                switch (arguments.length) {
                  case 1:
                    ndx = 1;
                    arg = arguments[0];
                    break;
                  case 2:
                    ndx = arguments[0];
                    arg = arguments[1];
                    break;
                  default:
                    toss3('Invalid bind() arguments.');
                }
                if (undefined === arg) {
                  return this;
                } else if (!this.parameterCount) {
                  toss3('This statement has no bindable parameters.');
                }
                this._mayGet = false;
                if (null === arg) {
                  return bindOne(this, ndx, BindTypes.null, arg);
                } else if (Array.isArray(arg)) {
                  if (1 !== arguments.length) {
                    toss3(
                      'When binding an array, an index argument is not permitted.',
                    );
                  }
                  arg.forEach((v, i) =>
                    bindOne(this, i + 1, affirmSupportedBindType(v), v),
                  );
                  return this;
                } else if (arg instanceof ArrayBuffer) {
                  arg = new Uint8Array(arg);
                }
                if ('object' === typeof arg && !util.isBindableTypedArray(arg)) {
                  if (1 !== arguments.length) {
                    toss3(
                      'When binding an object, an index argument is not permitted.',
                    );
                  }
                  Object.keys(arg).forEach((k) =>
                    bindOne(this, k, affirmSupportedBindType(arg[k]), arg[k]),
                  );
                  return this;
                } else {
                  return bindOne(this, ndx, affirmSupportedBindType(arg), arg);
                }
              },

              bindAsBlob: function (ndx, arg) {
                affirmStmtOpen(this);
                if (1 === arguments.length) {
                  arg = ndx;
                  ndx = 1;
                }
                const t = affirmSupportedBindType(arg);
                if (
                  BindTypes.string !== t &&
                  BindTypes.blob !== t &&
                  BindTypes.null !== t
                ) {
                  toss3('Invalid value type for bindAsBlob()');
                }
                return bindOne(this, ndx, BindTypes.blob, arg);
              },

              step: function () {
                affirmNotLockedByExec(this, 'step()');
                const rc = capi.sqlite3_step(affirmStmtOpen(this).pointer);
                switch (rc) {
                  case capi.SQLITE_DONE:
                    return (this._mayGet = false);
                  case capi.SQLITE_ROW:
                    return (this._mayGet = true);
                  default:
                    this._mayGet = false;
                    sqlite3.config.warn(
                      'sqlite3_step() rc=',
                      rc,
                      capi.sqlite3_js_rc_str(rc),
                      'SQL =',
                      capi.sqlite3_sql(this.pointer),
                    );
                    DB.checkRc(this.db.pointer, rc);
                }
              },

              stepReset: function () {
                this.step();
                return this.reset();
              },

              stepFinalize: function () {
                try {
                  const rc = this.step();
                  this.reset();
                  return rc;
                } finally {
                  try {
                    this.finalize();
                  } catch (e) {}
                }
              },

              get: function (ndx, asType) {
                if (!affirmStmtOpen(this)._mayGet) {
                  toss3('Stmt.step() has not (recently) returned true.');
                }
                if (Array.isArray(ndx)) {
                  let i = 0;
                  const n = this.columnCount;
                  while (i < n) {
                    ndx[i] = this.get(i++);
                  }
                  return ndx;
                } else if (ndx && 'object' === typeof ndx) {
                  let i = 0;
                  const n = this.columnCount;
                  while (i < n) {
                    ndx[capi.sqlite3_column_name(this.pointer, i)] = this.get(i++);
                  }
                  return ndx;
                }
                affirmColIndex(this, ndx);
                switch (
                  undefined === asType
                    ? capi.sqlite3_column_type(this.pointer, ndx)
                    : asType
                ) {
                  case capi.SQLITE_NULL:
                    return null;
                  case capi.SQLITE_INTEGER: {
                    if (wasm.bigIntEnabled) {
                      const rc = capi.sqlite3_column_int64(this.pointer, ndx);
                      if (
                        rc >= Number.MIN_SAFE_INTEGER &&
                        rc <= Number.MAX_SAFE_INTEGER
                      ) {
                        return Number(rc).valueOf();
                      }
                      return rc;
                    } else {
                      const rc = capi.sqlite3_column_double(this.pointer, ndx);
                      if (
                        rc > Number.MAX_SAFE_INTEGER ||
                        rc < Number.MIN_SAFE_INTEGER
                      ) {
                        toss3(
                          'Integer is out of range for JS integer range: ' + rc,
                        );
                      }

                      return util.isInt32(rc) ? rc | 0 : rc;
                    }
                  }
                  case capi.SQLITE_FLOAT:
                    return capi.sqlite3_column_double(this.pointer, ndx);
                  case capi.SQLITE_TEXT:
                    return capi.sqlite3_column_text(this.pointer, ndx);
                  case capi.SQLITE_BLOB: {
                    const n = capi.sqlite3_column_bytes(this.pointer, ndx),
                      ptr = capi.sqlite3_column_blob(this.pointer, ndx),
                      rc = new Uint8Array(n);

                    if (n) rc.set(wasm.heap8u().slice(ptr, ptr + n), 0);

                    if (n && this.db._blobXfer instanceof Array) {
                      this.db._blobXfer.push(rc.buffer);
                    }
                    return rc;
                  }
                  default:
                    toss3(
                      "Don't know how to translate",
                      'type of result column #' + ndx + '.',
                    );
                }
                toss3('Not reached.');
              },

              getInt: function (ndx) {
                return this.get(ndx, capi.SQLITE_INTEGER);
              },

              getFloat: function (ndx) {
                return this.get(ndx, capi.SQLITE_FLOAT);
              },

              getString: function (ndx) {
                return this.get(ndx, capi.SQLITE_TEXT);
              },

              getBlob: function (ndx) {
                return this.get(ndx, capi.SQLITE_BLOB);
              },

              getJSON: function (ndx) {
                const s = this.get(ndx, capi.SQLITE_STRING);
                return null === s ? s : JSON.parse(s);
              },

              getColumnName: function (ndx) {
                return capi.sqlite3_column_name(
                  affirmColIndex(affirmStmtOpen(this), ndx).pointer,
                  ndx,
                );
              },

              getColumnNames: function (tgt = []) {
                affirmColIndex(affirmStmtOpen(this), 0);
                const n = this.columnCount;
                for (let i = 0; i < n; ++i) {
                  tgt.push(capi.sqlite3_column_name(this.pointer, i));
                }
                return tgt;
              },

              getParamIndex: function (name) {
                return affirmStmtOpen(this).parameterCount
                  ? capi.sqlite3_bind_parameter_index(this.pointer, name)
                  : undefined;
              },
            };

            {
              const prop = {
                enumerable: true,
                get: function () {
                  return __ptrMap.get(this);
                },
                set: () => toss3('The pointer property is read-only.'),
              };
              Object.defineProperty(Stmt.prototype, 'pointer', prop);
              Object.defineProperty(DB.prototype, 'pointer', prop);
            }

            Object.defineProperty(Stmt.prototype, 'columnCount', {
              enumerable: false,
              get: function () {
                return capi.sqlite3_column_count(this.pointer);
              },
              set: () => toss3('The columnCount property is read-only.'),
            });

            sqlite3.oo1 = {
              DB,
              Stmt,
            };

            if (util.isUIThread()) {
              sqlite3.oo1.JsStorageDb = function (storageName = 'session') {
                if ('session' !== storageName && 'local' !== storageName) {
                  toss3("JsStorageDb db name must be one of 'session' or 'local'.");
                }
                dbCtorHelper.call(this, {
                  filename: storageName,
                  flags: 'c',
                  vfs: 'kvvfs',
                });
              };
              const jdb = sqlite3.oo1.JsStorageDb;
              jdb.prototype = Object.create(DB.prototype);

              jdb.clearStorage = capi.sqlite3_js_kvvfs_clear;

              jdb.prototype.clearStorage = function () {
                return jdb.clearStorage(affirmDbOpen(this).filename);
              };

              jdb.storageSize = capi.sqlite3_js_kvvfs_size;

              jdb.prototype.storageSize = function () {
                return jdb.storageSize(affirmDbOpen(this).filename);
              };
            }
          });

          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            sqlite3.initWorker1API = function () {
              const toss = (...args) => {
                throw new Error(args.join(' '));
              };
              if (!(globalThis.WorkerGlobalScope instanceof Function)) {
                toss('initWorker1API() must be run from a Worker thread.');
              }
              const sqlite3 = this.sqlite3 || toss('Missing this.sqlite3 object.');
              const DB = sqlite3.oo1.DB;

              const getDbId = function (db) {
                let id = wState.idMap.get(db);
                if (id) return id;
                id = 'db#' + ++wState.idSeq + '@' + db.pointer;

                wState.idMap.set(db, id);
                return id;
              };

              const wState = {
                dbList: [],

                idSeq: 0,

                idMap: new WeakMap(),

                xfer: [],
                open: function (opt) {
                  const db = new DB(opt);
                  this.dbs[getDbId(db)] = db;
                  if (this.dbList.indexOf(db) < 0) this.dbList.push(db);
                  return db;
                },
                close: function (db, alsoUnlink) {
                  if (db) {
                    delete this.dbs[getDbId(db)];
                    const filename = db.filename;
                    const pVfs = sqlite3.wasm.sqlite3_wasm_db_vfs(db.pointer, 0);
                    db.close();
                    const ddNdx = this.dbList.indexOf(db);
                    if (ddNdx >= 0) this.dbList.splice(ddNdx, 1);
                    if (alsoUnlink && filename && pVfs) {
                      sqlite3.wasm.sqlite3_wasm_vfs_unlink(pVfs, filename);
                    }
                  }
                },

                post: function (msg, xferList) {
                  if (xferList && xferList.length) {
                    globalThis.postMessage(msg, Array.from(xferList));
                    xferList.length = 0;
                  } else {
                    globalThis.postMessage(msg);
                  }
                },

                dbs: Object.create(null),

                getDb: function (id, require = true) {
                  return (
                    this.dbs[id] ||
                    (require ? toss('Unknown (or closed) DB ID:', id) : undefined)
                  );
                },
              };

              const affirmDbOpen = function (db = wState.dbList[0]) {
                return db && db.pointer ? db : toss('DB is not opened.');
              };

              const getMsgDb = function (msgData, affirmExists = true) {
                const db = wState.getDb(msgData.dbId, false) || wState.dbList[0];
                return affirmExists ? affirmDbOpen(db) : db;
              };

              const getDefaultDbId = function () {
                return wState.dbList[0] ;
              };

              const guessVfs = function (filename) {
                const m = /^file:.+(vfs=(\w+))/.exec(filename);
                return sqlite3.capi.sqlite3_vfs_find(m ? m[2] : 0);
              };

              const isSpecialDbFilename = (n) => {
                return '' === n || ':' === n[0];
              };

              const wMsgHandler = {
                open: function (ev) {
                  const oargs = Object.create(null),
                    args = ev.args || Object.create(null);
                  if (args.simulateError) {
                    toss('Throwing because of simulateError flag.');
                  }
                  const rc = Object.create(null);
                  let byteArray, pVfs;
                  oargs.vfs = args.vfs;
                  if (isSpecialDbFilename(args.filename)) {
                    oargs.filename = args.filename || '';
                  } else {
                    oargs.filename = args.filename;
                    byteArray = args.byteArray;
                    if (byteArray) pVfs = guessVfs(args.filename);
                  }
                  if (pVfs) {
                    let pMem;
                    try {
                      pMem = sqlite3.wasm.allocFromTypedArray(byteArray);
                      const rc = sqlite3.wasm.sqlite3_wasm_vfs_create_file(
                        pVfs,
                        oargs.filename,
                        pMem,
                        byteArray.byteLength,
                      );
                      if (rc) sqlite3.SQLite3Error.toss(rc);
                    } catch (e) {
                      throw new sqlite3.SQLite3Error(
                        e.name + ' creating ' + args.filename + ': ' + e.message,
                        {
                          cause: e,
                        },
                      );
                    } finally {
                      if (pMem) sqlite3.wasm.dealloc(pMem);
                    }
                  }
                  const db = wState.open(oargs);
                  rc.filename = db.filename;
                  rc.persistent = !!sqlite3.capi.sqlite3_js_db_uses_vfs(
                    db.pointer,
                    'opfs',
                  );
                  rc.dbId = getDbId(db);
                  rc.vfs = db.dbVfsName();
                  return rc;
                },

                close: function (ev) {
                  const db = getMsgDb(ev, false);
                  const response = {
                    filename: db && db.filename,
                  };
                  if (db) {
                    const doUnlink =
                      ev.args && 'object' === typeof ev.args
                        ? !!ev.args.unlink
                        : false;
                    wState.close(db, doUnlink);
                  }
                  return response;
                },

                exec: function (ev) {
                  const rc =
                    'string' === typeof ev.args
                      ? { sql: ev.args }
                      : ev.args || Object.create(null);
                  if ('stmt' === rc.rowMode) {
                    toss(
                      "Invalid rowMode for 'exec': stmt mode",
                      'does not work in the Worker API.',
                    );
                  } else if (!rc.sql) {
                    toss("'exec' requires input SQL.");
                  }
                  const db = getMsgDb(ev);
                  if (rc.callback || Array.isArray(rc.resultRows)) {
                    db._blobXfer = wState.xfer;
                  }
                  const theCallback = rc.callback;
                  let rowNumber = 0;
                  const hadColNames = !!rc.columnNames;
                  if ('string' === typeof theCallback) {
                    if (!hadColNames) rc.columnNames = [];

                    rc.callback = function (row, stmt) {
                      wState.post(
                        {
                          type: theCallback,
                          columnNames: rc.columnNames,
                          rowNumber: ++rowNumber,
                          row: row,
                        },
                        wState.xfer,
                      );
                    };
                  }
                  try {
                    const changeCount = !!rc.countChanges
                      ? db.changes(true, 64 === rc.countChanges)
                      : undefined;
                    db.exec(rc);
                    if (undefined !== changeCount) {
                      rc.changeCount =
                        db.changes(true, 64 === rc.countChanges) - changeCount;
                    }
                    if (rc.callback instanceof Function) {
                      rc.callback = theCallback;

                      wState.post({
                        type: theCallback,
                        columnNames: rc.columnNames,
                        rowNumber: null,
                        row: undefined,
                      });
                    }
                  } finally {
                    delete db._blobXfer;
                    if (rc.callback) rc.callback = theCallback;
                  }
                  return rc;
                },

                'config-get': function () {
                  const rc = Object.create(null),
                    src = sqlite3.config;
                  ['bigIntEnabled'].forEach(function (k) {
                    if (Object.getOwnPropertyDescriptor(src, k)) rc[k] = src[k];
                  });
                  rc.version = sqlite3.version;
                  rc.vfsList = sqlite3.capi.sqlite3_js_vfs_list();
                  rc.opfsEnabled = !!sqlite3.opfs;
                  return rc;
                },

                export: function (ev) {
                  const db = getMsgDb(ev);
                  const response = {
                    byteArray: sqlite3.capi.sqlite3_js_db_export(db.pointer),
                    filename: db.filename,
                    mimetype: 'application/x-sqlite3',
                  };
                  wState.xfer.push(response.byteArray.buffer);
                  return response;
                },

                toss: function (ev) {
                  toss('Testing worker exception');
                },

                'opfs-tree': async function (ev) {
                  if (!sqlite3.opfs) toss('OPFS support is unavailable.');
                  const response = await sqlite3.opfs.treeList();
                  return response;
                },
              };

              globalThis.onmessage = async function (ev) {
                ev = ev.data;
                let result,
                  dbId = ev.dbId,
                  evType = ev.type;
                const arrivalTime = performance.now();
                try {
                  if (
                    wMsgHandler.hasOwnProperty(evType) &&
                    wMsgHandler[evType] instanceof Function
                  ) {
                    result = await wMsgHandler[evType](ev);
                  } else {
                    toss('Unknown db worker message type:', ev.type);
                  }
                } catch (err) {
                  evType = 'error';
                  result = {
                    operation: ev.type,
                    message: err.message,
                    errorClass: err.name,
                    input: ev,
                  };
                  if (err.stack) {
                    result.stack =
                      'string' === typeof err.stack
                        ? err.stack.split(/\n\s*/)
                        : err.stack;
                  }
                }
                if (!dbId) {
                  dbId = result.dbId || getDefaultDbId();
                }

                wState.post(
                  {
                    type: evType,
                    dbId: dbId,
                    messageId: ev.messageId,
                    workerReceivedTime: arrivalTime,
                    workerRespondTime: performance.now(),
                    departureTime: ev.departureTime,

                    result: result,
                  },
                  wState.xfer,
                );
              };
              globalThis.postMessage({
                type: 'sqlite3-api',
                result: 'worker1-ready',
              });
            }.bind({ sqlite3 });
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            const wasm = sqlite3.wasm,
              capi = sqlite3.capi,
              toss = sqlite3.util.toss3;
            const vfs = Object.create(null),
              vtab = Object.create(null);

            const StructBinder = sqlite3.StructBinder;
            sqlite3.vfs = vfs;
            sqlite3.vtab = vtab;

            const sii = capi.sqlite3_index_info;

            sii.prototype.nthConstraint = function (n, asPtr = false) {
              if (n < 0 || n >= this.$nConstraint) return false;
              const ptr =
                this.$aConstraint +
                sii.sqlite3_index_constraint.structInfo.sizeof * n;
              return asPtr ? ptr : new sii.sqlite3_index_constraint(ptr);
            };

            sii.prototype.nthConstraintUsage = function (n, asPtr = false) {
              if (n < 0 || n >= this.$nConstraint) return false;
              const ptr =
                this.$aConstraintUsage +
                sii.sqlite3_index_constraint_usage.structInfo.sizeof * n;
              return asPtr ? ptr : new sii.sqlite3_index_constraint_usage(ptr);
            };

            sii.prototype.nthOrderBy = function (n, asPtr = false) {
              if (n < 0 || n >= this.$nOrderBy) return false;
              const ptr =
                this.$aOrderBy + sii.sqlite3_index_orderby.structInfo.sizeof * n;
              return asPtr ? ptr : new sii.sqlite3_index_orderby(ptr);
            };

            const installMethod = function callee(
              tgt,
              name,
              func,
              applyArgcCheck = callee.installMethodArgcCheck,
            ) {
              if (!(tgt instanceof StructBinder.StructType)) {
                toss('Usage error: target object is-not-a StructType.');
              } else if (!(func instanceof Function) && !wasm.isPtr(func)) {
                toss('Usage errror: expecting a Function or WASM pointer to one.');
              }
              if (1 === arguments.length) {
                return (n, f) => callee(tgt, n, f, applyArgcCheck);
              }
              if (!callee.argcProxy) {
                callee.argcProxy = function (tgt, funcName, func, sig) {
                  return function (...args) {
                    if (func.length !== arguments.length) {
                      toss(
                        'Argument mismatch for',
                        tgt.structInfo.name +
                          '::' +
                          funcName +
                          ': Native signature is:',
                        sig,
                      );
                    }
                    return func.apply(this, args);
                  };
                };

                callee.removeFuncList = function () {
                  if (this.ondispose.__removeFuncList) {
                    this.ondispose.__removeFuncList.forEach((v, ndx) => {
                      if ('number' === typeof v) {
                        try {
                          wasm.uninstallFunction(v);
                        } catch (e) {}
                      }
                    });
                    delete this.ondispose.__removeFuncList;
                  }
                };
              }
              const sigN = tgt.memberSignature(name);
              if (sigN.length < 2) {
                toss(
                  'Member',
                  name,
                  'does not have a function pointer signature:',
                  sigN,
                );
              }
              const memKey = tgt.memberKey(name);
              const fProxy =
                applyArgcCheck && !wasm.isPtr(func)
                  ? callee.argcProxy(tgt, memKey, func, sigN)
                  : func;
              if (wasm.isPtr(fProxy)) {
                if (fProxy && !wasm.functionEntry(fProxy)) {
                  toss('Pointer', fProxy, 'is not a WASM function table entry.');
                }
                tgt[memKey] = fProxy;
              } else {
                const pFunc = wasm.installFunction(
                  fProxy,
                  tgt.memberSignature(name, true),
                );
                tgt[memKey] = pFunc;
                if (!tgt.ondispose || !tgt.ondispose.__removeFuncList) {
                  tgt.addOnDispose(
                    'ondispose.__removeFuncList handler',
                    callee.removeFuncList,
                  );
                  tgt.ondispose.__removeFuncList = [];
                }
                tgt.ondispose.__removeFuncList.push(memKey, pFunc);
              }
              return (n, f) => callee(tgt, n, f, applyArgcCheck);
            };
            installMethod.installMethodArgcCheck = false;

            const installMethods = function (
              structInstance,
              methods,
              applyArgcCheck = installMethod.installMethodArgcCheck,
            ) {
              const seen = new Map();
              for (const k of Object.keys(methods)) {
                const m = methods[k];
                const prior = seen.get(m);
                if (prior) {
                  const mkey = structInstance.memberKey(k);
                  structInstance[mkey] =
                    structInstance[structInstance.memberKey(prior)];
                } else {
                  installMethod(structInstance, k, m, applyArgcCheck);
                  seen.set(m, k);
                }
              }
              return structInstance;
            };

            StructBinder.StructType.prototype.installMethod = function callee(
              name,
              func,
              applyArgcCheck = installMethod.installMethodArgcCheck,
            ) {
              return arguments.length < 3 && name && 'object' === typeof name
                ? installMethods(this, ...arguments)
                : installMethod(this, ...arguments);
            };

            StructBinder.StructType.prototype.installMethods = function (
              methods,
              applyArgcCheck = installMethod.installMethodArgcCheck,
            ) {
              return installMethods(this, methods, applyArgcCheck);
            };

            capi.sqlite3_vfs.prototype.registerVfs = function (asDefault = false) {
              if (!(this instanceof sqlite3.capi.sqlite3_vfs)) {
                toss('Expecting a sqlite3_vfs-type argument.');
              }
              const rc = capi.sqlite3_vfs_register(this, asDefault ? 1 : 0);
              if (rc) {
                toss('sqlite3_vfs_register(', this, ') failed with rc', rc);
              }
              if (this.pointer !== capi.sqlite3_vfs_find(this.$zName)) {
                toss(
                  'BUG: sqlite3_vfs_find(vfs.$zName) failed for just-installed VFS',
                  this,
                );
              }
              return this;
            };

            vfs.installVfs = function (opt) {
              let count = 0;
              const propList = ['io', 'vfs'];
              for (const key of propList) {
                const o = opt[key];
                if (o) {
                  ++count;
                  installMethods(o.struct, o.methods, !!o.applyArgcCheck);
                  if ('vfs' === key) {
                    if (!o.struct.$zName && 'string' === typeof o.name) {
                      o.struct.addOnDispose(
                        (o.struct.$zName = wasm.allocCString(o.name)),
                      );
                    }
                    o.struct.registerVfs(!!o.asDefault);
                  }
                }
              }
              if (!count)
                toss(
                  'Misuse: installVfs() options object requires at least',
                  'one of:',
                  propList,
                );
              return this;
            };

            const __xWrapFactory = function (methodName, StructType) {
              return function (ptr, removeMapping = false) {
                if (0 === arguments.length) ptr = new StructType();
                if (ptr instanceof StructType) {
                  this.set(ptr.pointer, ptr);
                  return ptr;
                } else if (!wasm.isPtr(ptr)) {
                  sqlite3.SQLite3Error.toss(
                    'Invalid argument to',
                    methodName + '()',
                  );
                }
                let rc = this.get(ptr);
                if (removeMapping) this.delete(ptr);
                return rc;
              }.bind(new Map());
            };

            const StructPtrMapper = function (name, StructType) {
              const __xWrap = __xWrapFactory(name, StructType);

              return Object.assign(Object.create(null), {
                StructType,

                create: (ppOut) => {
                  const rc = __xWrap();
                  wasm.pokePtr(ppOut, rc.pointer);
                  return rc;
                },

                get: (pCObj) => __xWrap(pCObj),

                unget: (pCObj) => __xWrap(pCObj, true),

                dispose: (pCObj) => {
                  const o = __xWrap(pCObj, true);
                  if (o) o.dispose();
                },
              });
            };

            vtab.xVtab = StructPtrMapper('xVtab', capi.sqlite3_vtab);

            vtab.xCursor = StructPtrMapper('xCursor', capi.sqlite3_vtab_cursor);

            vtab.xIndexInfo = (pIdxInfo) => new capi.sqlite3_index_info(pIdxInfo);

            vtab.xError = function f(methodName, err, defaultRc) {
              if (f.errorReporter instanceof Function) {
                try {
                  f.errorReporter(
                    'sqlite3_module::' + methodName + '(): ' + err.message,
                  );
                } catch (e) {}
              }
              let rc;
              if (err instanceof sqlite3.WasmAllocError) rc = capi.SQLITE_NOMEM;
              else if (arguments.length > 2) rc = defaultRc;
              else if (err instanceof sqlite3.SQLite3Error) rc = err.resultCode;
              return rc || capi.SQLITE_ERROR;
            };
            vtab.xError.errorReporter = console.error.bind(console) ;

            vtab.xRowid = (ppRowid64, value) => wasm.poke(ppRowid64, value, 'i64');

            vtab.setupModule = function (opt) {
              let createdMod = false;
              const mod =
                this instanceof capi.sqlite3_module
                  ? this
                  : opt.struct || (createdMod = new capi.sqlite3_module());
              try {
                const methods = opt.methods || toss("Missing 'methods' object.");
                for (const e of Object.entries({
                  xConnect: 'xCreate',
                  xDisconnect: 'xDestroy',
                })) {
                  const k = e[0],
                    v = e[1];
                  if (true === methods[k]) methods[k] = methods[v];
                  else if (true === methods[v]) methods[v] = methods[k];
                }
                if (opt.catchExceptions) {
                  const fwrap = function (methodName, func) {
                    if (['xConnect', 'xCreate'].indexOf(methodName) >= 0) {
                      return function (pDb, pAux, argc, argv, ppVtab, pzErr) {
                        try {
                          return func(...arguments) || 0;
                        } catch (e) {
                          if (!(e instanceof sqlite3.WasmAllocError)) {
                            wasm.dealloc(wasm.peekPtr(pzErr));
                            wasm.pokePtr(pzErr, wasm.allocCString(e.message));
                          }
                          return vtab.xError(methodName, e);
                        }
                      };
                    } else {
                      return function (...args) {
                        try {
                          return func(...args) || 0;
                        } catch (e) {
                          return vtab.xError(methodName, e);
                        }
                      };
                    }
                  };
                  const mnames = [
                    'xCreate',
                    'xConnect',
                    'xBestIndex',
                    'xDisconnect',
                    'xDestroy',
                    'xOpen',
                    'xClose',
                    'xFilter',
                    'xNext',
                    'xEof',
                    'xColumn',
                    'xRowid',
                    'xUpdate',
                    'xBegin',
                    'xSync',
                    'xCommit',
                    'xRollback',
                    'xFindFunction',
                    'xRename',
                    'xSavepoint',
                    'xRelease',
                    'xRollbackTo',
                    'xShadowName',
                  ];
                  const remethods = Object.create(null);
                  for (const k of mnames) {
                    const m = methods[k];
                    if (!(m instanceof Function)) continue;
                    else if ('xConnect' === k && methods.xCreate === m) {
                      remethods[k] = methods.xCreate;
                    } else if ('xCreate' === k && methods.xConnect === m) {
                      remethods[k] = methods.xConnect;
                    } else {
                      remethods[k] = fwrap(k, m);
                    }
                  }
                  installMethods(mod, remethods, false);
                } else {
                  installMethods(mod, methods, !!opt.applyArgcCheck);
                }
                if (0 === mod.$iVersion) {
                  let v;
                  if ('number' === typeof opt.iVersion) v = opt.iVersion;
                  else if (mod.$xShadowName) v = 3;
                  else if (mod.$xSavePoint || mod.$xRelease || mod.$xRollbackTo)
                    v = 2;
                  else v = 1;
                  mod.$iVersion = v;
                }
              } catch (e) {
                if (createdMod) createdMod.dispose();
                throw e;
              }
              return mod;
            };

            capi.sqlite3_module.prototype.setupModule = function (opt) {
              return vtab.setupModule.call(this, opt);
            };
          });
          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            const installOpfsVfs = function callee(options) {
              if (!globalThis.SharedArrayBuffer || !globalThis.Atomics) {
                return Promise.reject(
                  new Error(
                    'Cannot install OPFS: Missing SharedArrayBuffer and/or Atomics. ' +
                      'The server must emit the COOP/COEP response headers to enable those. ' +
                      'See https://sqlite.org/wasm/doc/trunk/persistence.md#coop-coep',
                  ),
                );
              } else if ('undefined' === typeof WorkerGlobalScope) {
                return Promise.reject(
                  new Error(
                    'The OPFS sqlite3_vfs cannot run in the main thread ' +
                      'because it requires Atomics.wait().',
                  ),
                );
              } else if (
                !globalThis.FileSystemHandle ||
                !globalThis.FileSystemDirectoryHandle ||
                !globalThis.FileSystemFileHandle ||
                !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
                !navigator?.storage?.getDirectory
              ) {
                return Promise.reject(new Error('Missing required OPFS APIs.'));
              }
              if (!options || 'object' !== typeof options) {
                options = Object.create(null);
              }
              const urlParams = new URL(globalThis.location.href).searchParams;
              if (urlParams.has('opfs-disable')) {
                return Promise.resolve(sqlite3);
              }
              if (undefined === options.verbose) {
                options.verbose = urlParams.has('opfs-verbose')
                  ? +urlParams.get('opfs-verbose') || 2
                  : 1;
              }
              if (undefined === options.sanityChecks) {
                options.sanityChecks = urlParams.has('opfs-sanity-check');
              }
              if (undefined === options.proxyUri) {
                options.proxyUri = callee.defaultProxyUri;
              }

              if ('function' === typeof options.proxyUri) {
                options.proxyUri = options.proxyUri();
              }
              const thePromise = new Promise(function (
                promiseResolve_,
                promiseReject_,
              ) {
                const loggers = [
                  sqlite3.config.error,
                  sqlite3.config.warn,
                  sqlite3.config.log,
                ];
                const logImpl = (level, ...args) => {
                  if (options.verbose > level)
                    loggers[level]('OPFS syncer:', ...args);
                };
                const log = (...args) => logImpl(2, ...args);
                const warn = (...args) => logImpl(1, ...args);
                const error = (...args) => logImpl(0, ...args);
                const toss = sqlite3.util.toss;
                const capi = sqlite3.capi;
                const util = sqlite3.util;
                const wasm = sqlite3.wasm;
                const sqlite3_vfs = capi.sqlite3_vfs;
                const sqlite3_file = capi.sqlite3_file;
                const sqlite3_io_methods = capi.sqlite3_io_methods;

                const opfsUtil = Object.create(null);

                const thisThreadHasOPFS = () => {
                  return (
                    globalThis.FileSystemHandle &&
                    globalThis.FileSystemDirectoryHandle &&
                    globalThis.FileSystemFileHandle &&
                    globalThis.FileSystemFileHandle.prototype
                      .createSyncAccessHandle &&
                    navigator?.storage?.getDirectory
                  );
                };

                opfsUtil.metrics = {
                  dump: function () {
                    let k,
                      n = 0,
                      t = 0,
                      w = 0;
                    for (k in state.opIds) {
                      const m = metrics[k];
                      n += m.count;
                      t += m.time;
                      w += m.wait;
                      m.avgTime = m.count && m.time ? m.time / m.count : 0;
                      m.avgWait = m.count && m.wait ? m.wait / m.count : 0;
                    }
                    sqlite3.config.log(
                      globalThis.location.href,
                      'metrics for',
                      globalThis.location.href,
                      ':',
                      metrics,
                      '\nTotal of',
                      n,
                      'op(s) for',
                      t,
                      'ms (incl. ' + w + ' ms of waiting on the async side)',
                    );
                    sqlite3.config.log('Serialization metrics:', metrics.s11n);
                    W.postMessage({ type: 'opfs-async-metrics' });
                  },
                  reset: function () {
                    let k;
                    const r = (m) => (m.count = m.time = m.wait = 0);
                    for (k in state.opIds) {
                      r((metrics[k] = Object.create(null)));
                    }
                    let s = (metrics.s11n = Object.create(null));
                    s = s.serialize = Object.create(null);
                    s.count = s.time = 0;
                    s = metrics.s11n.deserialize = Object.create(null);
                    s.count = s.time = 0;
                  },
                };
                const opfsIoMethods = new sqlite3_io_methods();
                const opfsVfs = new sqlite3_vfs().addOnDispose(() =>
                  opfsIoMethods.dispose(),
                );
                let promiseWasRejected = undefined;
                const promiseReject = (err) => {
                  promiseWasRejected = true;
                  opfsVfs.dispose();
                  return promiseReject_(err);
                };
                const promiseResolve = () => {
                  promiseWasRejected = false;
                  return promiseResolve_(sqlite3);
                };
                const W = new Worker(
                  new URL('sqlite3-opfs-async-proxy.js', (document.currentScript && document.currentScript.src || new URL('bundle.js', document.baseURI).href)),
                );
                setTimeout(() => {
                  if (undefined === promiseWasRejected) {
                    promiseReject(
                      new Error(
                        'Timeout while waiting for OPFS async proxy worker.',
                      ),
                    );
                  }
                }, 4000);
                W._originalOnError = W.onerror;
                W.onerror = function (err) {
                  error('Error initializing OPFS asyncer:', err);
                  promiseReject(
                    new Error(
                      'Loading OPFS async Worker failed for unknown reasons.',
                    ),
                  );
                };
                const pDVfs = capi.sqlite3_vfs_find(null);
                const dVfs = pDVfs ? new sqlite3_vfs(pDVfs) : null;
                opfsIoMethods.$iVersion = 1;
                opfsVfs.$iVersion = 2;
                opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
                opfsVfs.$mxPathname = 1024;
                opfsVfs.$zName = wasm.allocCString('opfs');

                opfsVfs.$xDlOpen =
                  opfsVfs.$xDlError =
                  opfsVfs.$xDlSym =
                  opfsVfs.$xDlClose =
                    null;
                opfsVfs.addOnDispose(
                  '$zName',
                  opfsVfs.$zName,
                  'cleanup default VFS wrapper',
                  () => (dVfs ? dVfs.dispose() : null),
                );

                const state = Object.create(null);
                state.verbose = options.verbose;
                state.littleEndian = (() => {
                  const buffer = new ArrayBuffer(2);
                  new DataView(buffer).setInt16(0, 256, true);

                  return new Int16Array(buffer)[0] === 256;
                })();

                state.asyncIdleWaitTime = 150;

                state.asyncS11nExceptions = 1;

                state.fileBufferSize = 1024 * 64;
                state.sabS11nOffset = state.fileBufferSize;

                state.sabS11nSize = opfsVfs.$mxPathname * 2;

                state.sabIO = new SharedArrayBuffer(
                  state.fileBufferSize + state.sabS11nSize,
                );
                state.opIds = Object.create(null);
                const metrics = Object.create(null);
                {
                  let i = 0;

                  state.opIds.whichOp = i++;

                  state.opIds.rc = i++;

                  state.opIds.xAccess = i++;
                  state.opIds.xClose = i++;
                  state.opIds.xDelete = i++;
                  state.opIds.xDeleteNoWait = i++;
                  state.opIds.xFileSize = i++;
                  state.opIds.xLock = i++;
                  state.opIds.xOpen = i++;
                  state.opIds.xRead = i++;
                  state.opIds.xSleep = i++;
                  state.opIds.xSync = i++;
                  state.opIds.xTruncate = i++;
                  state.opIds.xUnlock = i++;
                  state.opIds.xWrite = i++;
                  state.opIds.mkdir = i++;
                  state.opIds['opfs-async-metrics'] = i++;
                  state.opIds['opfs-async-shutdown'] = i++;

                  state.opIds.retry = i++;
                  state.sabOP = new SharedArrayBuffer(i * 4);
                  opfsUtil.metrics.reset();
                }

                state.sq3Codes = Object.create(null);
                [
                  'SQLITE_ACCESS_EXISTS',
                  'SQLITE_ACCESS_READWRITE',
                  'SQLITE_BUSY',
                  'SQLITE_ERROR',
                  'SQLITE_IOERR',
                  'SQLITE_IOERR_ACCESS',
                  'SQLITE_IOERR_CLOSE',
                  'SQLITE_IOERR_DELETE',
                  'SQLITE_IOERR_FSYNC',
                  'SQLITE_IOERR_LOCK',
                  'SQLITE_IOERR_READ',
                  'SQLITE_IOERR_SHORT_READ',
                  'SQLITE_IOERR_TRUNCATE',
                  'SQLITE_IOERR_UNLOCK',
                  'SQLITE_IOERR_WRITE',
                  'SQLITE_LOCK_EXCLUSIVE',
                  'SQLITE_LOCK_NONE',
                  'SQLITE_LOCK_PENDING',
                  'SQLITE_LOCK_RESERVED',
                  'SQLITE_LOCK_SHARED',
                  'SQLITE_LOCKED',
                  'SQLITE_MISUSE',
                  'SQLITE_NOTFOUND',
                  'SQLITE_OPEN_CREATE',
                  'SQLITE_OPEN_DELETEONCLOSE',
                  'SQLITE_OPEN_MAIN_DB',
                  'SQLITE_OPEN_READONLY',
                ].forEach((k) => {
                  if (undefined === (state.sq3Codes[k] = capi[k])) {
                    toss('Maintenance required: not found:', k);
                  }
                });
                state.opfsFlags = Object.assign(Object.create(null), {
                  OPFS_UNLOCK_ASAP: 0x01,

                  defaultUnlockAsap: false,
                });

                const opRun = (op, ...args) => {
                  const opNdx = state.opIds[op] || toss('Invalid op ID:', op);
                  state.s11n.serialize(...args);
                  Atomics.store(state.sabOPView, state.opIds.rc, -1);
                  Atomics.store(state.sabOPView, state.opIds.whichOp, opNdx);
                  Atomics.notify(state.sabOPView, state.opIds.whichOp);
                  const t = performance.now();
                  Atomics.wait(state.sabOPView, state.opIds.rc, -1);
                  const rc = Atomics.load(state.sabOPView, state.opIds.rc);
                  metrics[op].wait += performance.now() - t;
                  if (rc && state.asyncS11nExceptions) {
                    const err = state.s11n.deserialize();
                    if (err) error(op + '() async error:', ...err);
                  }
                  return rc;
                };

                opfsUtil.debug = {
                  asyncShutdown: () => {
                    warn(
                      'Shutting down OPFS async listener. The OPFS VFS will no longer work.',
                    );
                    opRun('opfs-async-shutdown');
                  },
                  asyncRestart: () => {
                    warn(
                      'Attempting to restart OPFS VFS async listener. Might work, might not.',
                    );
                    W.postMessage({ type: 'opfs-async-restart' });
                  },
                };

                const initS11n = () => {
                  if (state.s11n) return state.s11n;
                  const textDecoder = new TextDecoder(),
                    textEncoder = new TextEncoder('utf-8'),
                    viewU8 = new Uint8Array(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize,
                    ),
                    viewDV = new DataView(
                      state.sabIO,
                      state.sabS11nOffset,
                      state.sabS11nSize,
                    );
                  state.s11n = Object.create(null);

                  const TypeIds = Object.create(null);
                  TypeIds.number = {
                    id: 1,
                    size: 8,
                    getter: 'getFloat64',
                    setter: 'setFloat64',
                  };
                  TypeIds.bigint = {
                    id: 2,
                    size: 8,
                    getter: 'getBigInt64',
                    setter: 'setBigInt64',
                  };
                  TypeIds.boolean = {
                    id: 3,
                    size: 4,
                    getter: 'getInt32',
                    setter: 'setInt32',
                  };
                  TypeIds.string = { id: 4 };

                  const getTypeId = (v) =>
                    TypeIds[typeof v] ||
                    toss(
                      'Maintenance required: this value type cannot be serialized.',
                      v,
                    );
                  const getTypeIdById = (tid) => {
                    switch (tid) {
                      case TypeIds.number.id:
                        return TypeIds.number;
                      case TypeIds.bigint.id:
                        return TypeIds.bigint;
                      case TypeIds.boolean.id:
                        return TypeIds.boolean;
                      case TypeIds.string.id:
                        return TypeIds.string;
                      default:
                        toss('Invalid type ID:', tid);
                    }
                  };

                  state.s11n.deserialize = function (clear = false) {
                    ++metrics.s11n.deserialize.count;
                    const t = performance.now();
                    const argc = viewU8[0];
                    const rc = argc ? [] : null;
                    if (argc) {
                      const typeIds = [];
                      let offset = 1,
                        i,
                        n,
                        v;
                      for (i = 0; i < argc; ++i, ++offset) {
                        typeIds.push(getTypeIdById(viewU8[offset]));
                      }
                      for (i = 0; i < argc; ++i) {
                        const t = typeIds[i];
                        if (t.getter) {
                          v = viewDV[t.getter](offset, state.littleEndian);
                          offset += t.size;
                        } else {
                          n = viewDV.getInt32(offset, state.littleEndian);
                          offset += 4;
                          v = textDecoder.decode(viewU8.slice(offset, offset + n));
                          offset += n;
                        }
                        rc.push(v);
                      }
                    }
                    if (clear) viewU8[0] = 0;

                    metrics.s11n.deserialize.time += performance.now() - t;
                    return rc;
                  };

                  state.s11n.serialize = function (...args) {
                    const t = performance.now();
                    ++metrics.s11n.serialize.count;
                    if (args.length) {
                      const typeIds = [];
                      let i = 0,
                        offset = 1;
                      viewU8[0] = args.length & 0xff;
                      for (; i < args.length; ++i, ++offset) {
                        typeIds.push(getTypeId(args[i]));
                        viewU8[offset] = typeIds[i].id;
                      }
                      for (i = 0; i < args.length; ++i) {
                        const t = typeIds[i];
                        if (t.setter) {
                          viewDV[t.setter](offset, args[i], state.littleEndian);
                          offset += t.size;
                        } else {
                          const s = textEncoder.encode(args[i]);
                          viewDV.setInt32(offset, s.byteLength, state.littleEndian);
                          offset += 4;
                          viewU8.set(s, offset);
                          offset += s.byteLength;
                        }
                      }
                    } else {
                      viewU8[0] = 0;
                    }
                    metrics.s11n.serialize.time += performance.now() - t;
                  };
                  return state.s11n;
                };

                const randomFilename = function f(len = 16) {
                  if (!f._chars) {
                    f._chars =
                      'abcdefghijklmnopqrstuvwxyz' +
                      'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
                      '012346789';
                    f._n = f._chars.length;
                  }
                  const a = [];
                  let i = 0;
                  for (; i < len; ++i) {
                    const ndx = (Math.random() * (f._n * 64)) % f._n | 0;
                    a[i] = f._chars[ndx];
                  }
                  return a.join('');
                };

                const __openFiles = Object.create(null);

                const opTimer = Object.create(null);
                opTimer.op = undefined;
                opTimer.start = undefined;
                const mTimeStart = (op) => {
                  opTimer.start = performance.now();
                  opTimer.op = op;
                  ++metrics[op].count;
                };
                const mTimeEnd = () =>
                  (metrics[opTimer.op].time += performance.now() - opTimer.start);

                const ioSyncWrappers = {
                  xCheckReservedLock: function (pFile, pOut) {
                    const f = __openFiles[pFile];
                    wasm.poke(pOut, f.lockType ? 1 : 0, 'i32');
                    return 0;
                  },
                  xClose: function (pFile) {
                    mTimeStart('xClose');
                    let rc = 0;
                    const f = __openFiles[pFile];
                    if (f) {
                      delete __openFiles[pFile];
                      rc = opRun('xClose', pFile);
                      if (f.sq3File) f.sq3File.dispose();
                    }
                    mTimeEnd();
                    return rc;
                  },
                  xDeviceCharacteristics: function (pFile) {
                    return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
                  },
                  xFileControl: function (pFile, opId, pArg) {
                    return capi.SQLITE_NOTFOUND;
                  },
                  xFileSize: function (pFile, pSz64) {
                    mTimeStart('xFileSize');
                    let rc = opRun('xFileSize', pFile);
                    if (0 == rc) {
                      try {
                        const sz = state.s11n.deserialize()[0];
                        wasm.poke(pSz64, sz, 'i64');
                      } catch (e) {
                        error('Unexpected error reading xFileSize() result:', e);
                        rc = state.sq3Codes.SQLITE_IOERR;
                      }
                    }
                    mTimeEnd();
                    return rc;
                  },
                  xLock: function (pFile, lockType) {
                    mTimeStart('xLock');
                    const f = __openFiles[pFile];
                    let rc = 0;

                    if (!f.lockType) {
                      rc = opRun('xLock', pFile, lockType);
                      if (0 === rc) f.lockType = lockType;
                    } else {
                      f.lockType = lockType;
                    }
                    mTimeEnd();
                    return rc;
                  },
                  xRead: function (pFile, pDest, n, offset64) {
                    mTimeStart('xRead');
                    const f = __openFiles[pFile];
                    let rc;
                    try {
                      rc = opRun('xRead', pFile, n, Number(offset64));
                      if (0 === rc || capi.SQLITE_IOERR_SHORT_READ === rc) {
                        wasm.heap8u().set(f.sabView.subarray(0, n), pDest);
                      }
                    } catch (e) {
                      error('xRead(', arguments, ') failed:', e, f);
                      rc = capi.SQLITE_IOERR_READ;
                    }
                    mTimeEnd();
                    return rc;
                  },
                  xSync: function (pFile, flags) {
                    mTimeStart('xSync');
                    ++metrics.xSync.count;
                    const rc = opRun('xSync', pFile, flags);
                    mTimeEnd();
                    return rc;
                  },
                  xTruncate: function (pFile, sz64) {
                    mTimeStart('xTruncate');
                    const rc = opRun('xTruncate', pFile, Number(sz64));
                    mTimeEnd();
                    return rc;
                  },
                  xUnlock: function (pFile, lockType) {
                    mTimeStart('xUnlock');
                    const f = __openFiles[pFile];
                    let rc = 0;
                    if (capi.SQLITE_LOCK_NONE === lockType && f.lockType) {
                      rc = opRun('xUnlock', pFile, lockType);
                    }
                    if (0 === rc) f.lockType = lockType;
                    mTimeEnd();
                    return rc;
                  },
                  xWrite: function (pFile, pSrc, n, offset64) {
                    mTimeStart('xWrite');
                    const f = __openFiles[pFile];
                    let rc;
                    try {
                      f.sabView.set(wasm.heap8u().subarray(pSrc, pSrc + n));
                      rc = opRun('xWrite', pFile, n, Number(offset64));
                    } catch (e) {
                      error('xWrite(', arguments, ') failed:', e, f);
                      rc = capi.SQLITE_IOERR_WRITE;
                    }
                    mTimeEnd();
                    return rc;
                  },
                };

                const vfsSyncWrappers = {
                  xAccess: function (pVfs, zName, flags, pOut) {
                    mTimeStart('xAccess');
                    const rc = opRun('xAccess', wasm.cstrToJs(zName));
                    wasm.poke(pOut, rc ? 0 : 1, 'i32');
                    mTimeEnd();
                    return 0;
                  },
                  xCurrentTime: function (pVfs, pOut) {
                    wasm.poke(
                      pOut,
                      2440587.5 + new Date().getTime() / 86400000,
                      'double',
                    );
                    return 0;
                  },
                  xCurrentTimeInt64: function (pVfs, pOut) {
                    wasm.poke(
                      pOut,
                      2440587.5 * 86400000 + new Date().getTime(),
                      'i64',
                    );
                    return 0;
                  },
                  xDelete: function (pVfs, zName, doSyncDir) {
                    mTimeStart('xDelete');
                    const rc = opRun(
                      'xDelete',
                      wasm.cstrToJs(zName),
                      doSyncDir,
                      false,
                    );
                    mTimeEnd();
                    return rc;
                  },
                  xFullPathname: function (pVfs, zName, nOut, pOut) {
                    const i = wasm.cstrncpy(pOut, zName, nOut);
                    return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
                  },
                  xGetLastError: function (pVfs, nOut, pOut) {
                    warn('OPFS xGetLastError() has nothing sensible to return.');
                    return 0;
                  },

                  xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
                    mTimeStart('xOpen');
                    let opfsFlags = 0;
                    if (0 === zName) {
                      zName = randomFilename();
                    } else if ('number' === typeof zName) {
                      if (capi.sqlite3_uri_boolean(zName, 'opfs-unlock-asap', 0)) {
                        opfsFlags |= state.opfsFlags.OPFS_UNLOCK_ASAP;
                      }
                      zName = wasm.cstrToJs(zName);
                    }
                    const fh = Object.create(null);
                    fh.fid = pFile;
                    fh.filename = zName;
                    fh.sab = new SharedArrayBuffer(state.fileBufferSize);
                    fh.flags = flags;
                    const rc = opRun('xOpen', pFile, zName, flags, opfsFlags);
                    if (!rc) {
                      if (fh.readOnly) {
                        wasm.poke(pOutFlags, capi.SQLITE_OPEN_READONLY, 'i32');
                      }
                      __openFiles[pFile] = fh;
                      fh.sabView = state.sabFileBufView;
                      fh.sq3File = new sqlite3_file(pFile);
                      fh.sq3File.$pMethods = opfsIoMethods.pointer;
                      fh.lockType = capi.SQLITE_LOCK_NONE;
                    }
                    mTimeEnd();
                    return rc;
                  },
                };

                if (dVfs) {
                  opfsVfs.$xRandomness = dVfs.$xRandomness;
                  opfsVfs.$xSleep = dVfs.$xSleep;
                }
                if (!opfsVfs.$xRandomness) {
                  vfsSyncWrappers.xRandomness = function (pVfs, nOut, pOut) {
                    const heap = wasm.heap8u();
                    let i = 0;
                    for (; i < nOut; ++i)
                      heap[pOut + i] = (Math.random() * 255000) & 0xff;
                    return i;
                  };
                }
                if (!opfsVfs.$xSleep) {
                  vfsSyncWrappers.xSleep = function (pVfs, ms) {
                    Atomics.wait(state.sabOPView, state.opIds.xSleep, 0, ms);
                    return 0;
                  };
                }

                opfsUtil.getResolvedPath = function (filename, splitIt) {
                  const p = new URL(filename, 'file://irrelevant').pathname;
                  return splitIt ? p.split('/').filter((v) => !!v) : p;
                };

                opfsUtil.getDirForFilename = async function f(
                  absFilename,
                  createDirs = false,
                ) {
                  const path = opfsUtil.getResolvedPath(absFilename, true);
                  const filename = path.pop();
                  let dh = opfsUtil.rootDirectory;
                  for (const dirName of path) {
                    if (dirName) {
                      dh = await dh.getDirectoryHandle(dirName, {
                        create: !!createDirs,
                      });
                    }
                  }
                  return [dh, filename];
                };

                opfsUtil.mkdir = async function (absDirName) {
                  try {
                    await opfsUtil.getDirForFilename(
                      absDirName + '/filepart',
                      true,
                    );
                    return true;
                  } catch (e) {
                    return false;
                  }
                };

                opfsUtil.entryExists = async function (fsEntryName) {
                  try {
                    const [dh, fn] = await opfsUtil.getDirForFilename(fsEntryName);
                    await dh.getFileHandle(fn);
                    return true;
                  } catch (e) {
                    return false;
                  }
                };

                opfsUtil.randomFilename = randomFilename;

                opfsUtil.registerVfs = (asDefault = false) => {
                  return wasm.exports.sqlite3_vfs_register(
                    opfsVfs.pointer,
                    asDefault ? 1 : 0,
                  );
                };

                opfsUtil.treeList = async function () {
                  const doDir = async function callee(dirHandle, tgt) {
                    tgt.name = dirHandle.name;
                    tgt.dirs = [];
                    tgt.files = [];
                    for await (const handle of dirHandle.values()) {
                      if ('directory' === handle.kind) {
                        const subDir = Object.create(null);
                        tgt.dirs.push(subDir);
                        await callee(handle, subDir);
                      } else {
                        tgt.files.push(handle.name);
                      }
                    }
                  };
                  const root = Object.create(null);
                  await doDir(opfsUtil.rootDirectory, root);
                  return root;
                };

                opfsUtil.rmfr = async function () {
                  const dir = opfsUtil.rootDirectory,
                    opt = { recurse: true };
                  for await (const handle of dir.values()) {
                    dir.removeEntry(handle.name, opt);
                  }
                };

                opfsUtil.unlink = async function (
                  fsEntryName,
                  recursive = false,
                  throwOnError = false,
                ) {
                  try {
                    const [hDir, filenamePart] = await opfsUtil.getDirForFilename(
                      fsEntryName,
                      false,
                    );
                    await hDir.removeEntry(filenamePart, { recursive });
                    return true;
                  } catch (e) {
                    if (throwOnError) {
                      throw new Error(
                        'unlink(',
                        arguments[0],
                        ') failed: ' + e.message,
                        {
                          cause: e,
                        },
                      );
                    }
                    return false;
                  }
                };

                opfsUtil.traverse = async function (opt) {
                  const defaultOpt = {
                    recursive: true,
                    directory: opfsUtil.rootDirectory,
                  };
                  if ('function' === typeof opt) {
                    opt = { callback: opt };
                  }
                  opt = Object.assign(defaultOpt, opt || {});
                  const doDir = async function callee(dirHandle, depth) {
                    for await (const handle of dirHandle.values()) {
                      if (false === opt.callback(handle, dirHandle, depth))
                        return false;
                      else if (opt.recursive && 'directory' === handle.kind) {
                        if (false === (await callee(handle, depth + 1))) break;
                      }
                    }
                  };
                  doDir(opt.directory, 0);
                };

                const importDbChunked = async function (filename, callback) {
                  const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                    filename,
                    true,
                  );
                  const hFile = await hDir.getFileHandle(fnamePart, {
                    create: true,
                  });
                  let sah = await hFile.createSyncAccessHandle();
                  let nWrote = 0,
                    chunk,
                    checkedHeader = false;
                  try {
                    sah.truncate(0);
                    while (undefined !== (chunk = await callback())) {
                      if (chunk instanceof ArrayBuffer)
                        chunk = new Uint8Array(chunk);
                      if (0 === nWrote && chunk.byteLength >= 15) {
                        util.affirmDbHeader(chunk);
                        checkedHeader = true;
                      }
                      sah.write(chunk, { at: nWrote });
                      nWrote += chunk.byteLength;
                    }
                    if (nWrote < 512 || 0 !== nWrote % 512) {
                      toss(
                        'Input size',
                        nWrote,
                        'is not correct for an SQLite database.',
                      );
                    }
                    if (!checkedHeader) {
                      const header = new Uint8Array(20);
                      sah.read(header, { at: 0 });
                      util.affirmDbHeader(header);
                    }
                    sah.write(new Uint8Array([1, 1]), { at: 18 });
                    return nWrote;
                  } catch (e) {
                    await sah.close();
                    sah = undefined;
                    await hDir.removeEntry(fnamePart).catch(() => {});
                    throw e;
                  } finally {
                    if (sah) await sah.close();
                  }
                };

                opfsUtil.importDb = async function (filename, bytes) {
                  if (bytes instanceof Function) {
                    return importDbChunked(filename, bytes);
                  }
                  if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                  util.affirmIsDb(bytes);
                  const n = bytes.byteLength;
                  const [hDir, fnamePart] = await opfsUtil.getDirForFilename(
                    filename,
                    true,
                  );
                  let sah,
                    nWrote = 0;
                  try {
                    const hFile = await hDir.getFileHandle(fnamePart, {
                      create: true,
                    });
                    sah = await hFile.createSyncAccessHandle();
                    sah.truncate(0);
                    nWrote = sah.write(bytes, { at: 0 });
                    if (nWrote != n) {
                      toss(
                        'Expected to write ' +
                          n +
                          ' bytes but wrote ' +
                          nWrote +
                          '.',
                      );
                    }
                    sah.write(new Uint8Array([1, 1]), { at: 18 });
                    return nWrote;
                  } catch (e) {
                    if (sah) {
                      await sah.close();
                      sah = undefined;
                    }
                    await hDir.removeEntry(fnamePart).catch(() => {});
                    throw e;
                  } finally {
                    if (sah) await sah.close();
                  }
                };

                if (sqlite3.oo1) {
                  const OpfsDb = function (...args) {
                    const opt = sqlite3.oo1.DB.dbCtorHelper.normalizeArgs(...args);
                    opt.vfs = opfsVfs.$zName;
                    sqlite3.oo1.DB.dbCtorHelper.call(this, opt);
                  };
                  OpfsDb.prototype = Object.create(sqlite3.oo1.DB.prototype);
                  sqlite3.oo1.OpfsDb = OpfsDb;
                  OpfsDb.importDb = opfsUtil.importDb;
                  sqlite3.oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                    opfsVfs.pointer,
                    function (oo1Db, sqlite3) {
                      sqlite3.capi.sqlite3_busy_timeout(oo1Db, 10000);
                      sqlite3.capi.sqlite3_exec(
                        oo1Db,
                        [
                          'pragma journal_mode=DELETE;',

                          'pragma cache_size=-16384;',
                        ],
                        0,
                        0,
                        0,
                      );
                    },
                  );
                }

                const sanityCheck = function () {
                  const scope = wasm.scopedAllocPush();
                  const sq3File = new sqlite3_file();
                  try {
                    const fid = sq3File.pointer;
                    const openFlags =
                      capi.SQLITE_OPEN_CREATE |
                      capi.SQLITE_OPEN_READWRITE |
                      capi.SQLITE_OPEN_MAIN_DB;
                    const pOut = wasm.scopedAlloc(8);
                    const dbFile = '/sanity/check/file' + randomFilename(8);
                    const zDbFile = wasm.scopedAllocCString(dbFile);
                    let rc;
                    state.s11n.serialize('This is ä string.');
                    rc = state.s11n.deserialize();
                    log('deserialize() says:', rc);
                    if ('This is ä string.' !== rc[0]) toss('String d13n error.');
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm.peek(pOut, 'i32');
                    log('xAccess(', dbFile, ') exists ?=', rc);
                    rc = vfsSyncWrappers.xOpen(
                      opfsVfs.pointer,
                      zDbFile,
                      fid,
                      openFlags,
                      pOut,
                    );
                    log(
                      'open rc =',
                      rc,
                      'state.sabOPView[xOpen] =',
                      state.sabOPView[state.opIds.xOpen],
                    );
                    if (0 !== rc) {
                      error('open failed with code', rc);
                      return;
                    }
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm.peek(pOut, 'i32');
                    if (!rc) toss('xAccess() failed to detect file.');
                    rc = ioSyncWrappers.xSync(sq3File.pointer, 0);
                    if (rc) toss('sync failed w/ rc', rc);
                    rc = ioSyncWrappers.xTruncate(sq3File.pointer, 1024);
                    if (rc) toss('truncate failed w/ rc', rc);
                    wasm.poke(pOut, 0, 'i64');
                    rc = ioSyncWrappers.xFileSize(sq3File.pointer, pOut);
                    if (rc) toss('xFileSize failed w/ rc', rc);
                    log('xFileSize says:', wasm.peek(pOut, 'i64'));
                    rc = ioSyncWrappers.xWrite(sq3File.pointer, zDbFile, 10, 1);
                    if (rc) toss('xWrite() failed!');
                    const readBuf = wasm.scopedAlloc(16);
                    rc = ioSyncWrappers.xRead(sq3File.pointer, readBuf, 6, 2);
                    wasm.poke(readBuf + 6, 0);
                    let jRead = wasm.cstrToJs(readBuf);
                    log('xRead() got:', jRead);
                    if ('sanity' !== jRead) toss('Unexpected xRead() value.');
                    if (vfsSyncWrappers.xSleep) {
                      log('xSleep()ing before close()ing...');
                      vfsSyncWrappers.xSleep(opfsVfs.pointer, 2000);
                      log('waking up from xSleep()');
                    }
                    rc = ioSyncWrappers.xClose(fid);
                    log('xClose rc =', rc, 'sabOPView =', state.sabOPView);
                    log('Deleting file:', dbFile);
                    vfsSyncWrappers.xDelete(opfsVfs.pointer, zDbFile, 0x1234);
                    vfsSyncWrappers.xAccess(opfsVfs.pointer, zDbFile, 0, pOut);
                    rc = wasm.peek(pOut, 'i32');
                    if (rc)
                      toss(
                        'Expecting 0 from xAccess(',
                        dbFile,
                        ') after xDelete().',
                      );
                    warn('End of OPFS sanity checks.');
                  } finally {
                    sq3File.dispose();
                    wasm.scopedAllocPop(scope);
                  }
                };

                W.onmessage = function ({ data }) {
                  switch (data.type) {
                    case 'opfs-unavailable':
                      promiseReject(new Error(data.payload.join(' ')));
                      break;
                    case 'opfs-async-loaded':
                      W.postMessage({ type: 'opfs-async-init', args: state });
                      break;
                    case 'opfs-async-inited': {
                      if (true === promiseWasRejected) {
                        break;
                      }
                      try {
                        sqlite3.vfs.installVfs({
                          io: { struct: opfsIoMethods, methods: ioSyncWrappers },
                          vfs: { struct: opfsVfs, methods: vfsSyncWrappers },
                        });
                        state.sabOPView = new Int32Array(state.sabOP);
                        state.sabFileBufView = new Uint8Array(
                          state.sabIO,
                          0,
                          state.fileBufferSize,
                        );
                        state.sabS11nView = new Uint8Array(
                          state.sabIO,
                          state.sabS11nOffset,
                          state.sabS11nSize,
                        );
                        initS11n();
                        if (options.sanityChecks) {
                          warn(
                            'Running sanity checks because of opfs-sanity-check URL arg...',
                          );
                          sanityCheck();
                        }
                        if (thisThreadHasOPFS()) {
                          navigator.storage
                            .getDirectory()
                            .then((d) => {
                              W.onerror = W._originalOnError;
                              delete W._originalOnError;
                              sqlite3.opfs = opfsUtil;
                              opfsUtil.rootDirectory = d;
                              log('End of OPFS sqlite3_vfs setup.', opfsVfs);
                              promiseResolve();
                            })
                            .catch(promiseReject);
                        } else {
                          promiseResolve();
                        }
                      } catch (e) {
                        error(e);
                        promiseReject(e);
                      }
                      break;
                    }
                    default: {
                      const errMsg =
                        'Unexpected message from the OPFS async worker: ' +
                        JSON.stringify(data);
                      error(errMsg);
                      promiseReject(new Error(errMsg));
                      break;
                    }
                  }
                };
              });
              return thePromise;
            };
            installOpfsVfs.defaultProxyUri = 'sqlite3-opfs-async-proxy.js';
            globalThis.sqlite3ApiBootstrap.initializersAsync.push(
              async (sqlite3) => {
                try {
                  let proxyJs = installOpfsVfs.defaultProxyUri;
                  if (sqlite3.scriptInfo.sqlite3Dir) {
                    installOpfsVfs.defaultProxyUri =
                      sqlite3.scriptInfo.sqlite3Dir + proxyJs;
                  }
                  return installOpfsVfs().catch((e) => {
                    sqlite3.config.warn(
                      'Ignoring inability to install OPFS sqlite3_vfs:',
                      e.message,
                    );
                  });
                } catch (e) {
                  sqlite3.config.error('installOpfsVfs() exception:', e);
                  return Promise.reject(e);
                }
              },
            );
          });

          globalThis.sqlite3ApiBootstrap.initializers.push(function (sqlite3) {
            const toss = sqlite3.util.toss;
            const toss3 = sqlite3.util.toss3;
            const initPromises = Object.create(null);
            const capi = sqlite3.capi;
            const util = sqlite3.util;
            const wasm = sqlite3.wasm;

            const SECTOR_SIZE = 4096;
            const HEADER_MAX_PATH_SIZE = 512;
            const HEADER_FLAGS_SIZE = 4;
            const HEADER_DIGEST_SIZE = 8;
            const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
            const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
            const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
            const HEADER_OFFSET_DATA = SECTOR_SIZE;

            const PERSISTENT_FILE_TYPES =
              capi.SQLITE_OPEN_MAIN_DB |
              capi.SQLITE_OPEN_MAIN_JOURNAL |
              capi.SQLITE_OPEN_SUPER_JOURNAL |
              capi.SQLITE_OPEN_WAL;

            const OPAQUE_DIR_NAME = '.opaque';

            const getRandomName = () => Math.random().toString(36).slice(2);

            const textDecoder = new TextDecoder();
            const textEncoder = new TextEncoder();

            const optionDefaults = Object.assign(Object.create(null), {
              name: 'opfs-sahpool',
              directory: undefined,
              initialCapacity: 6,
              clearOnInit: false,

              verbosity: 2,
            });

            const loggers = [
              sqlite3.config.error,
              sqlite3.config.warn,
              sqlite3.config.log,
            ];
            sqlite3.config.log;
            const warn = sqlite3.config.warn;
            sqlite3.config.error;

            const __mapVfsToPool = new Map();
            const getPoolForVfs = (pVfs) => __mapVfsToPool.get(pVfs);
            const setPoolForVfs = (pVfs, pool) => {
              if (pool) __mapVfsToPool.set(pVfs, pool);
              else __mapVfsToPool.delete(pVfs);
            };

            const __mapSqlite3File = new Map();
            const getPoolForPFile = (pFile) => __mapSqlite3File.get(pFile);
            const setPoolForPFile = (pFile, pool) => {
              if (pool) __mapSqlite3File.set(pFile, pool);
              else __mapSqlite3File.delete(pFile);
            };

            const ioMethods = {
              xCheckReservedLock: function (pFile, pOut) {
                const pool = getPoolForPFile(pFile);
                pool.log('xCheckReservedLock');
                pool.storeErr();
                wasm.poke32(pOut, 1);
                return 0;
              },
              xClose: function (pFile) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                if (file) {
                  try {
                    pool.log(`xClose ${file.path}`);
                    pool.mapS3FileToOFile(pFile, false);
                    file.sah.flush();
                    if (file.flags & capi.SQLITE_OPEN_DELETEONCLOSE) {
                      pool.deletePath(file.path);
                    }
                  } catch (e) {
                    return pool.storeErr(e, capi.SQLITE_IOERR);
                  }
                }
                return 0;
              },
              xDeviceCharacteristics: function (pFile) {
                return capi.SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
              },
              xFileControl: function (pFile, opId, pArg) {
                return capi.SQLITE_NOTFOUND;
              },
              xFileSize: function (pFile, pSz64) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xFileSize`);
                const file = pool.getOFileForS3File(pFile);
                const size = file.sah.getSize() - HEADER_OFFSET_DATA;

                wasm.poke64(pSz64, BigInt(size));
                return 0;
              },
              xLock: function (pFile, lockType) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xLock ${lockType}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                file.lockType = lockType;
                return 0;
              },
              xRead: function (pFile, pDest, n, offset64) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                pool.log(`xRead ${file.path} ${n} @ ${offset64}`);
                try {
                  const nRead = file.sah.read(
                    wasm.heap8u().subarray(pDest, pDest + n),
                    { at: HEADER_OFFSET_DATA + Number(offset64) },
                  );
                  if (nRead < n) {
                    wasm.heap8u().fill(0, pDest + nRead, pDest + n);
                    return capi.SQLITE_IOERR_SHORT_READ;
                  }
                  return 0;
                } catch (e) {
                  return pool.storeErr(e, capi.SQLITE_IOERR);
                }
              },
              xSectorSize: function (pFile) {
                return SECTOR_SIZE;
              },
              xSync: function (pFile, flags) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xSync ${flags}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);

                try {
                  file.sah.flush();
                  return 0;
                } catch (e) {
                  return pool.storeErr(e, capi.SQLITE_IOERR);
                }
              },
              xTruncate: function (pFile, sz64) {
                const pool = getPoolForPFile(pFile);
                pool.log(`xTruncate ${sz64}`);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);

                try {
                  file.sah.truncate(HEADER_OFFSET_DATA + Number(sz64));
                  return 0;
                } catch (e) {
                  return pool.storeErr(e, capi.SQLITE_IOERR);
                }
              },
              xUnlock: function (pFile, lockType) {
                const pool = getPoolForPFile(pFile);
                pool.log('xUnlock');
                const file = pool.getOFileForS3File(pFile);
                file.lockType = lockType;
                return 0;
              },
              xWrite: function (pFile, pSrc, n, offset64) {
                const pool = getPoolForPFile(pFile);
                pool.storeErr();
                const file = pool.getOFileForS3File(pFile);
                pool.log(`xWrite ${file.path} ${n} ${offset64}`);
                try {
                  const nBytes = file.sah.write(
                    wasm.heap8u().subarray(pSrc, pSrc + n),
                    { at: HEADER_OFFSET_DATA + Number(offset64) },
                  );
                  return n === nBytes ? 0 : toss('Unknown write() failure.');
                } catch (e) {
                  return pool.storeErr(e, capi.SQLITE_IOERR);
                }
              },
            };

            const opfsIoMethods = new capi.sqlite3_io_methods();
            opfsIoMethods.$iVersion = 1;
            sqlite3.vfs.installVfs({
              io: { struct: opfsIoMethods, methods: ioMethods },
            });

            const vfsMethods = {
              xAccess: function (pVfs, zName, flags, pOut) {
                const pool = getPoolForVfs(pVfs);
                pool.storeErr();
                try {
                  const name = pool.getPath(zName);
                  wasm.poke32(pOut, pool.hasFilename(name) ? 1 : 0);
                } catch (e) {
                  wasm.poke32(pOut, 0);
                }
                return 0;
              },
              xCurrentTime: function (pVfs, pOut) {
                wasm.poke(
                  pOut,
                  2440587.5 + new Date().getTime() / 86400000,
                  'double',
                );
                return 0;
              },
              xCurrentTimeInt64: function (pVfs, pOut) {
                wasm.poke(pOut, 2440587.5 * 86400000 + new Date().getTime(), 'i64');
                return 0;
              },
              xDelete: function (pVfs, zName, doSyncDir) {
                const pool = getPoolForVfs(pVfs);
                pool.log(`xDelete ${wasm.cstrToJs(zName)}`);
                pool.storeErr();
                try {
                  pool.deletePath(pool.getPath(zName));
                  return 0;
                } catch (e) {
                  pool.storeErr(e);
                  return capi.SQLITE_IOERR_DELETE;
                }
              },
              xFullPathname: function (pVfs, zName, nOut, pOut) {
                const i = wasm.cstrncpy(pOut, zName, nOut);
                return i < nOut ? 0 : capi.SQLITE_CANTOPEN;
              },
              xGetLastError: function (pVfs, nOut, pOut) {
                const pool = getPoolForVfs(pVfs);
                const e = pool.popErr();
                pool.log(`xGetLastError ${nOut} e =`, e);
                if (e) {
                  const scope = wasm.scopedAllocPush();
                  try {
                    const [cMsg, n] = wasm.scopedAllocCString(e.message, true);
                    wasm.cstrncpy(pOut, cMsg, nOut);
                    if (n > nOut) wasm.poke8(pOut + nOut - 1, 0);
                  } catch (e) {
                    return capi.SQLITE_NOMEM;
                  } finally {
                    wasm.scopedAllocPop(scope);
                  }
                }
                return e ? e.sqlite3Rc || capi.SQLITE_IOERR : 0;
              },

              xOpen: function f(pVfs, zName, pFile, flags, pOutFlags) {
                const pool = getPoolForVfs(pVfs);
                try {
                  pool.log(`xOpen ${wasm.cstrToJs(zName)} ${flags}`);

                  const path =
                    zName && wasm.peek8(zName)
                      ? pool.getPath(zName)
                      : getRandomName();
                  let sah = pool.getSAHForPath(path);
                  if (!sah && flags & capi.SQLITE_OPEN_CREATE) {
                    if (pool.getFileCount() < pool.getCapacity()) {
                      sah = pool.nextAvailableSAH();
                      pool.setAssociatedPath(sah, path, flags);
                    } else {
                      toss('SAH pool is full. Cannot create file', path);
                    }
                  }
                  if (!sah) {
                    toss('file not found:', path);
                  }

                  const file = { path, flags, sah };
                  pool.mapS3FileToOFile(pFile, file);
                  file.lockType = capi.SQLITE_LOCK_NONE;
                  const sq3File = new capi.sqlite3_file(pFile);
                  sq3File.$pMethods = opfsIoMethods.pointer;
                  sq3File.dispose();
                  wasm.poke32(pOutFlags, flags);
                  return 0;
                } catch (e) {
                  pool.storeErr(e);
                  return capi.SQLITE_CANTOPEN;
                }
              },
            };

            const createOpfsVfs = function (vfsName) {
              if (sqlite3.capi.sqlite3_vfs_find(vfsName)) {
                toss3('VFS name is already registered:', vfsName);
              }
              const opfsVfs = new capi.sqlite3_vfs();

              const pDVfs = capi.sqlite3_vfs_find(null);
              const dVfs = pDVfs ? new capi.sqlite3_vfs(pDVfs) : null;
              opfsVfs.$iVersion = 2;
              opfsVfs.$szOsFile = capi.sqlite3_file.structInfo.sizeof;
              opfsVfs.$mxPathname = HEADER_MAX_PATH_SIZE;
              opfsVfs.addOnDispose(
                (opfsVfs.$zName = wasm.allocCString(vfsName)),
                () => setPoolForVfs(opfsVfs.pointer, 0),
              );

              if (dVfs) {
                opfsVfs.$xRandomness = dVfs.$xRandomness;
                opfsVfs.$xSleep = dVfs.$xSleep;
                dVfs.dispose();
              }
              if (!opfsVfs.$xRandomness && !vfsMethods.xRandomness) {
                vfsMethods.xRandomness = function (pVfs, nOut, pOut) {
                  const heap = wasm.heap8u();
                  let i = 0;
                  for (; i < nOut; ++i)
                    heap[pOut + i] = (Math.random() * 255000) & 0xff;
                  return i;
                };
              }
              if (!opfsVfs.$xSleep && !vfsMethods.xSleep) {
                vfsMethods.xSleep = (pVfs, ms) => 0;
              }
              sqlite3.vfs.installVfs({
                vfs: { struct: opfsVfs, methods: vfsMethods },
              });
              return opfsVfs;
            };

            class OpfsSAHPool {
              vfsDir;

              #dhVfsRoot;

              #dhOpaque;

              #dhVfsParent;

              #mapSAHToName = new Map();

              #mapFilenameToSAH = new Map();

              #availableSAH = new Set();

              #mapS3FileToOFile_ = new Map();

              #apBody = new Uint8Array(HEADER_CORPUS_SIZE);

              #dvBody;

              #cVfs;

              #verbosity;

              constructor(options = Object.create(null)) {
                this.#verbosity = options.verbosity ?? optionDefaults.verbosity;
                this.vfsName = options.name || optionDefaults.name;
                this.#cVfs = createOpfsVfs(this.vfsName);
                setPoolForVfs(this.#cVfs.pointer, this);
                this.vfsDir = options.directory || '.' + this.vfsName;
                this.#dvBody = new DataView(
                  this.#apBody.buffer,
                  this.#apBody.byteOffset,
                );
                this.isReady = this.reset(
                  !!(options.clearOnInit ?? optionDefaults.clearOnInit),
                ).then(() => {
                  if (this.$error) throw this.$error;
                  return this.getCapacity()
                    ? Promise.resolve(undefined)
                    : this.addCapacity(
                        options.initialCapacity || optionDefaults.initialCapacity,
                      );
                });
              }

              #logImpl(level, ...args) {
                if (this.#verbosity > level)
                  loggers[level](this.vfsName + ':', ...args);
              }
              log(...args) {
                this.#logImpl(2, ...args);
              }
              warn(...args) {
                this.#logImpl(1, ...args);
              }
              error(...args) {
                this.#logImpl(0, ...args);
              }

              getVfs() {
                return this.#cVfs;
              }

              getCapacity() {
                return this.#mapSAHToName.size;
              }

              getFileCount() {
                return this.#mapFilenameToSAH.size;
              }

              getFileNames() {
                const rc = [];
                const iter = this.#mapFilenameToSAH.keys();
                for (const n of iter) rc.push(n);
                return rc;
              }

              async addCapacity(n) {
                for (let i = 0; i < n; ++i) {
                  const name = getRandomName();
                  const h = await this.#dhOpaque.getFileHandle(name, {
                    create: true,
                  });
                  const ah = await h.createSyncAccessHandle();
                  this.#mapSAHToName.set(ah, name);
                  this.setAssociatedPath(ah, '', 0);
                }
                return this.getCapacity();
              }

              async reduceCapacity(n) {
                let nRm = 0;
                for (const ah of Array.from(this.#availableSAH)) {
                  if (nRm === n || this.getFileCount() === this.getCapacity()) {
                    break;
                  }
                  const name = this.#mapSAHToName.get(ah);

                  ah.close();
                  await this.#dhOpaque.removeEntry(name);
                  this.#mapSAHToName.delete(ah);
                  this.#availableSAH.delete(ah);
                  ++nRm;
                }
                return nRm;
              }

              releaseAccessHandles() {
                for (const ah of this.#mapSAHToName.keys()) ah.close();
                this.#mapSAHToName.clear();
                this.#mapFilenameToSAH.clear();
                this.#availableSAH.clear();
              }

              async acquireAccessHandles(clearFiles) {
                const files = [];
                for await (const [name, h] of this.#dhOpaque) {
                  if ('file' === h.kind) {
                    files.push([name, h]);
                  }
                }
                return Promise.all(
                  files.map(async ([name, h]) => {
                    try {
                      const ah = await h.createSyncAccessHandle();
                      this.#mapSAHToName.set(ah, name);
                      if (clearFiles) {
                        ah.truncate(HEADER_OFFSET_DATA);
                        this.setAssociatedPath(ah, '', 0);
                      } else {
                        const path = this.getAssociatedPath(ah);
                        if (path) {
                          this.#mapFilenameToSAH.set(path, ah);
                        } else {
                          this.#availableSAH.add(ah);
                        }
                      }
                    } catch (e) {
                      this.storeErr(e);
                      this.releaseAccessHandles();
                      throw e;
                    }
                  }),
                );
              }

              getAssociatedPath(sah) {
                sah.read(this.#apBody, { at: 0 });

                const flags = this.#dvBody.getUint32(HEADER_OFFSET_FLAGS);
                if (
                  this.#apBody[0] &&
                  (flags & capi.SQLITE_OPEN_DELETEONCLOSE ||
                    (flags & PERSISTENT_FILE_TYPES) === 0)
                ) {
                  warn(
                    `Removing file with unexpected flags ${flags.toString(16)}`,
                    this.#apBody,
                  );
                  this.setAssociatedPath(sah, '', 0);
                  return '';
                }

                const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
                sah.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
                const compDigest = this.computeDigest(this.#apBody);
                if (fileDigest.every((v, i) => v === compDigest[i])) {
                  const pathBytes = this.#apBody.findIndex((v) => 0 === v);
                  if (0 === pathBytes) {
                    sah.truncate(HEADER_OFFSET_DATA);
                  }
                  return pathBytes
                    ? textDecoder.decode(this.#apBody.subarray(0, pathBytes))
                    : '';
                } else {
                  warn('Disassociating file with bad digest.');
                  this.setAssociatedPath(sah, '', 0);
                  return '';
                }
              }

              setAssociatedPath(sah, path, flags) {
                const enc = textEncoder.encodeInto(path, this.#apBody);
                if (HEADER_MAX_PATH_SIZE <= enc.written + 1) {
                  toss('Path too long:', path);
                }
                this.#apBody.fill(0, enc.written, HEADER_MAX_PATH_SIZE);
                this.#dvBody.setUint32(HEADER_OFFSET_FLAGS, flags);

                const digest = this.computeDigest(this.#apBody);
                sah.write(this.#apBody, { at: 0 });
                sah.write(digest, { at: HEADER_OFFSET_DIGEST });
                sah.flush();

                if (path) {
                  this.#mapFilenameToSAH.set(path, sah);
                  this.#availableSAH.delete(sah);
                } else {
                  sah.truncate(HEADER_OFFSET_DATA);
                  this.#availableSAH.add(sah);
                }
              }

              computeDigest(byteArray) {
                let h1 = 0xdeadbeef;
                let h2 = 0x41c6ce57;
                for (const v of byteArray) {
                  h1 = 31 * h1 + v * 307;
                  h2 = 31 * h2 + v * 307;
                }
                return new Uint32Array([h1 >>> 0, h2 >>> 0]);
              }

              async reset(clearFiles) {
                await this.isReady;
                let h = await navigator.storage.getDirectory();
                let prev;
                for (const d of this.vfsDir.split('/')) {
                  if (d) {
                    prev = h;
                    h = await h.getDirectoryHandle(d, { create: true });
                  }
                }
                this.#dhVfsRoot = h;
                this.#dhVfsParent = prev;
                this.#dhOpaque = await this.#dhVfsRoot.getDirectoryHandle(
                  OPAQUE_DIR_NAME,
                  { create: true },
                );
                this.releaseAccessHandles();
                return this.acquireAccessHandles(clearFiles);
              }

              getPath(arg) {
                if (wasm.isPtr(arg)) arg = wasm.cstrToJs(arg);
                return (
                  arg instanceof URL ? arg : new URL(arg, 'file://localhost/')
                ).pathname;
              }

              deletePath(path) {
                const sah = this.#mapFilenameToSAH.get(path);
                if (sah) {
                  this.#mapFilenameToSAH.delete(path);
                  this.setAssociatedPath(sah, '', 0);
                }
                return !!sah;
              }

              storeErr(e, code) {
                if (e) {
                  e.sqlite3Rc = code || capi.SQLITE_IOERR;
                  this.error(e);
                }
                this.$error = e;
                return code;
              }

              popErr() {
                const rc = this.$error;
                this.$error = undefined;
                return rc;
              }

              nextAvailableSAH() {
                const [rc] = this.#availableSAH.keys();
                return rc;
              }

              getOFileForS3File(pFile) {
                return this.#mapS3FileToOFile_.get(pFile);
              }

              mapS3FileToOFile(pFile, file) {
                if (file) {
                  this.#mapS3FileToOFile_.set(pFile, file);
                  setPoolForPFile(pFile, this);
                } else {
                  this.#mapS3FileToOFile_.delete(pFile);
                  setPoolForPFile(pFile, false);
                }
              }

              hasFilename(name) {
                return this.#mapFilenameToSAH.has(name);
              }

              getSAHForPath(path) {
                return this.#mapFilenameToSAH.get(path);
              }

              async removeVfs() {
                if (!this.#cVfs.pointer || !this.#dhOpaque) return false;
                capi.sqlite3_vfs_unregister(this.#cVfs.pointer);
                this.#cVfs.dispose();
                try {
                  this.releaseAccessHandles();
                  await this.#dhVfsRoot.removeEntry(OPAQUE_DIR_NAME, {
                    recursive: true,
                  });
                  this.#dhOpaque = undefined;
                  await this.#dhVfsParent.removeEntry(this.#dhVfsRoot.name, {
                    recursive: true,
                  });
                  this.#dhVfsRoot = this.#dhVfsParent = undefined;
                } catch (e) {
                  sqlite3.config.error(this.vfsName, 'removeVfs() failed:', e);
                }
                return true;
              }

              exportFile(name) {
                const sah =
                  this.#mapFilenameToSAH.get(name) || toss('File not found:', name);
                const n = sah.getSize() - HEADER_OFFSET_DATA;
                const b = new Uint8Array(n > 0 ? n : 0);
                if (n > 0) {
                  const nRead = sah.read(b, { at: HEADER_OFFSET_DATA });
                  if (nRead != n) {
                    toss(
                      'Expected to read ' + n + ' bytes but read ' + nRead + '.',
                    );
                  }
                }
                return b;
              }

              async importDbChunked(name, callback) {
                const sah =
                  this.#mapFilenameToSAH.get(name) ||
                  this.nextAvailableSAH() ||
                  toss('No available handles to import to.');
                sah.truncate(0);
                let nWrote = 0,
                  chunk,
                  checkedHeader = false;
                try {
                  while (undefined !== (chunk = await callback())) {
                    if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk);
                    if (0 === nWrote && chunk.byteLength >= 15) {
                      util.affirmDbHeader(chunk);
                      checkedHeader = true;
                    }
                    sah.write(chunk, { at: HEADER_OFFSET_DATA + nWrote });
                    nWrote += chunk.byteLength;
                  }
                  if (nWrote < 512 || 0 !== nWrote % 512) {
                    toss(
                      'Input size',
                      nWrote,
                      'is not correct for an SQLite database.',
                    );
                  }
                  if (!checkedHeader) {
                    const header = new Uint8Array(20);
                    sah.read(header, { at: 0 });
                    util.affirmDbHeader(header);
                  }
                  sah.write(new Uint8Array([1, 1]), {
                    at: HEADER_OFFSET_DATA + 18,
                  });
                } catch (e) {
                  this.setAssociatedPath(sah, '', 0);
                  throw e;
                }
                this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
                return nWrote;
              }

              importDb(name, bytes) {
                if (bytes instanceof ArrayBuffer) bytes = new Uint8Array(bytes);
                else if (bytes instanceof Function)
                  return this.importDbChunked(name, bytes);
                const sah =
                  this.#mapFilenameToSAH.get(name) ||
                  this.nextAvailableSAH() ||
                  toss('No available handles to import to.');
                const n = bytes.byteLength;
                if (n < 512 || n % 512 != 0) {
                  toss('Byte array size is invalid for an SQLite db.');
                }
                const header = 'SQLite format 3';
                for (let i = 0; i < header.length; ++i) {
                  if (header.charCodeAt(i) !== bytes[i]) {
                    toss('Input does not contain an SQLite database header.');
                  }
                }
                const nWrote = sah.write(bytes, { at: HEADER_OFFSET_DATA });
                if (nWrote != n) {
                  this.setAssociatedPath(sah, '', 0);
                  toss(
                    'Expected to write ' + n + ' bytes but wrote ' + nWrote + '.',
                  );
                } else {
                  sah.write(new Uint8Array([1, 1]), {
                    at: HEADER_OFFSET_DATA + 18,
                  });
                  this.setAssociatedPath(sah, name, capi.SQLITE_OPEN_MAIN_DB);
                }
                return nWrote;
              }
            }

            class OpfsSAHPoolUtil {
              #p;

              constructor(sahPool) {
                this.#p = sahPool;
                this.vfsName = sahPool.vfsName;
              }

              async addCapacity(n) {
                return this.#p.addCapacity(n);
              }

              async reduceCapacity(n) {
                return this.#p.reduceCapacity(n);
              }

              getCapacity() {
                return this.#p.getCapacity(this.#p);
              }

              getFileCount() {
                return this.#p.getFileCount();
              }
              getFileNames() {
                return this.#p.getFileNames();
              }

              async reserveMinimumCapacity(min) {
                const c = this.#p.getCapacity();
                return c < min ? this.#p.addCapacity(min - c) : c;
              }

              exportFile(name) {
                return this.#p.exportFile(name);
              }

              importDb(name, bytes) {
                return this.#p.importDb(name, bytes);
              }

              async wipeFiles() {
                return this.#p.reset(true);
              }

              unlink(filename) {
                return this.#p.deletePath(filename);
              }

              async removeVfs() {
                return this.#p.removeVfs();
              }
            }

            const apiVersionCheck = async () => {
              const dh = await navigator.storage.getDirectory();
              const fn = '.opfs-sahpool-sync-check-' + getRandomName();
              const fh = await dh.getFileHandle(fn, { create: true });
              const ah = await fh.createSyncAccessHandle();
              const close = ah.close();
              await close;
              await dh.removeEntry(fn);
              if (close?.then) {
                toss(
                  'The local OPFS API is too old for opfs-sahpool:',
                  'it has an async FileSystemSyncAccessHandle.close() method.',
                );
              }
              return true;
            };

            sqlite3.installOpfsSAHPoolVfs = async function (
              options = Object.create(null),
            ) {
              const vfsName = options.name || optionDefaults.name;
              if (initPromises[vfsName]) {
                return initPromises[vfsName];
              }
              if (
                !globalThis.FileSystemHandle ||
                !globalThis.FileSystemDirectoryHandle ||
                !globalThis.FileSystemFileHandle ||
                !globalThis.FileSystemFileHandle.prototype.createSyncAccessHandle ||
                !navigator?.storage?.getDirectory
              ) {
                return (initPromises[vfsName] = Promise.reject(
                  new Error('Missing required OPFS APIs.'),
                ));
              }

              return (initPromises[vfsName] = apiVersionCheck()
                .then(async function () {
                  if (options.$testThrowInInit) {
                    throw options.$testThrowInInit;
                  }
                  const thePool = new OpfsSAHPool(options);
                  return thePool.isReady
                    .then(async () => {
                      const poolUtil = new OpfsSAHPoolUtil(thePool);
                      if (sqlite3.oo1) {
                        const oo1 = sqlite3.oo1;
                        const theVfs = thePool.getVfs();
                        const OpfsSAHPoolDb = function (...args) {
                          const opt = oo1.DB.dbCtorHelper.normalizeArgs(...args);
                          opt.vfs = theVfs.$zName;
                          oo1.DB.dbCtorHelper.call(this, opt);
                        };
                        OpfsSAHPoolDb.prototype = Object.create(oo1.DB.prototype);

                        poolUtil.OpfsSAHPoolDb = OpfsSAHPoolDb;
                        oo1.DB.dbCtorHelper.setVfsPostOpenSql(
                          theVfs.pointer,
                          function (oo1Db, sqlite3) {
                            sqlite3.capi.sqlite3_exec(
                              oo1Db,
                              [
                                'pragma journal_mode=DELETE;',
                                'pragma cache_size=-16384;',
                              ],
                              0,
                              0,
                              0,
                            );
                          },
                        );
                      }
                      thePool.log('VFS initialized.');
                      return poolUtil;
                    })
                    .catch(async (e) => {
                      await thePool.removeVfs().catch(() => {});
                      return e;
                    });
                })
                .catch((err) => {
                  return (initPromises[vfsName] = Promise.reject(err));
                }));
            };
          });
          if ('undefined' !== typeof Module) {
            const SABC = Object.assign(
              Object.create(null),
              {
                exports:
                  'undefined' === typeof wasmExports ? Module['asm'] : wasmExports,
                memory: Module.wasmMemory,
              },
              globalThis.sqlite3ApiConfig || {},
            );

            globalThis.sqlite3ApiConfig = SABC;
            let sqlite3;
            try {
              sqlite3 = globalThis.sqlite3ApiBootstrap();
            } catch (e) {
              console.error('sqlite3ApiBootstrap() error:', e);
              throw e;
            } finally {
              delete globalThis.sqlite3ApiBootstrap;
              delete globalThis.sqlite3ApiConfig;
            }

            Module.sqlite3 = sqlite3;
          } else {
            console.warn(
              'This is not running in an Emscripten module context, so',
              'globalThis.sqlite3ApiBootstrap() is _not_ being called due to lack',
              'of config info for the WASM environment.',
              'It must be called manually.',
            );
          }
        });

        return sqlite3InitModule.ready;
      };
    })();

    const toExportForESM = (function () {
      const originalInit = sqlite3InitModule;
      if (!originalInit) {
        throw new Error(
          'Expecting globalThis.sqlite3InitModule to be defined by the Emscripten build.',
        );
      }

      const initModuleState = (globalThis.sqlite3InitModuleState = Object.assign(
        Object.create(null),
        {
          moduleScript: globalThis?.document?.currentScript,
          isWorker: 'undefined' !== typeof WorkerGlobalScope,
          location: globalThis.location,
          urlParams: globalThis?.location?.href
            ? new URL(globalThis.location.href).searchParams
            : new URLSearchParams(),
        },
      ));
      initModuleState.debugModule = initModuleState.urlParams.has(
        'sqlite3.debugModule',
      )
        ? (...args) => console.warn('sqlite3.debugModule:', ...args)
        : () => {};

      if (initModuleState.urlParams.has('sqlite3.dir')) {
        initModuleState.sqlite3Dir =
          initModuleState.urlParams.get('sqlite3.dir') + '/';
      } else if (initModuleState.moduleScript) {
        const li = initModuleState.moduleScript.src.split('/');
        li.pop();
        initModuleState.sqlite3Dir = li.join('/') + '/';
      }

      globalThis.sqlite3InitModule = function ff(...args) {
        return originalInit(...args)
          .then((EmscriptenModule) => {
            const s = EmscriptenModule.sqlite3;
            s.scriptInfo = initModuleState;

            if (ff.__isUnderTest) s.__isUnderTest = true;
            const f = s.asyncPostInit;
            delete s.asyncPostInit;
            return f();
          })
          .catch((e) => {
            console.error('Exception loading sqlite3 module:', e);
            throw e;
          });
      };
      globalThis.sqlite3InitModule.ready = originalInit.ready;

      if (globalThis.sqlite3InitModuleState.moduleScript) {
        const sim = globalThis.sqlite3InitModuleState;
        let src = sim.moduleScript.src.split('/');
        src.pop();
        sim.scriptDir = src.join('/') + '/';
      }
      initModuleState.debugModule('sqlite3InitModuleState =', initModuleState);
      return globalThis.sqlite3InitModule;
    })();
    sqlite3InitModule = toExportForESM;
    var sqlite3InitModule$1 = sqlite3InitModule;

    /*
      2022-08-24

      The author disclaims copyright to this source code.  In place of a
      legal notice, here is a blessing:

      *   May you do good and not evil.
      *   May you find forgiveness for yourself and forgive others.
      *   May you share freely, never taking more than you give.

      ***********************************************************************

      This file implements a Promise-based proxy for the sqlite3 Worker
      API #1. It is intended to be included either from the main thread or
      a Worker, but only if (A) the environment supports nested Workers
      and (B) it's _not_ a Worker which loads the sqlite3 WASM/JS
      module. This file's features will load that module and provide a
      slightly simpler client-side interface than the slightly-lower-level
      Worker API does.

      This script necessarily exposes one global symbol, but clients may
      freely `delete` that symbol after calling it.
    */

    globalThis.sqlite3Worker1Promiser = function callee(
      config = callee.defaultConfig,
    ) {
      if (1 === arguments.length && 'function' === typeof arguments[0]) {
        const f = config;
        config = Object.assign(Object.create(null), callee.defaultConfig);
        config.onready = f;
      } else {
        config = Object.assign(Object.create(null), callee.defaultConfig, config);
      }
      const handlerMap = Object.create(null);
      const noop = function () {};
      const err = config.onerror || noop;
      const debug = config.debug || noop;
      const idTypeMap = config.generateMessageId ? undefined : Object.create(null);
      const genMsgId =
        config.generateMessageId ||
        function (msg) {
          return (
            msg.type + '#' + (idTypeMap[msg.type] = (idTypeMap[msg.type] || 0) + 1)
          );
        };
      const toss = (...args) => {
        throw new Error(args.join(' '));
      };
      if (!config.worker) config.worker = callee.defaultConfig.worker;
      if ('function' === typeof config.worker) config.worker = config.worker();
      let dbId;
      config.worker.onmessage = function (ev) {
        ev = ev.data;
        debug('worker1.onmessage', ev);
        let msgHandler = handlerMap[ev.messageId];
        if (!msgHandler) {
          if (ev && 'sqlite3-api' === ev.type && 'worker1-ready' === ev.result) {
            if (config.onready) config.onready();
            return;
          }
          msgHandler = handlerMap[ev.type];
          if (msgHandler && msgHandler.onrow) {
            msgHandler.onrow(ev);
            return;
          }
          if (config.onunhandled) config.onunhandled(arguments[0]);
          else err('sqlite3Worker1Promiser() unhandled worker message:', ev);
          return;
        }
        delete handlerMap[ev.messageId];
        switch (ev.type) {
          case 'error':
            msgHandler.reject(ev);
            return;
          case 'open':
            if (!dbId) dbId = ev.dbId;
            break;
          case 'close':
            if (ev.dbId === dbId) dbId = undefined;
            break;
        }
        try {
          msgHandler.resolve(ev);
        } catch (e) {
          msgHandler.reject(e);
        }
      };
      return function () {
        let msg;
        if (1 === arguments.length) {
          msg = arguments[0];
        } else if (2 === arguments.length) {
          msg = Object.create(null);
          msg.type = arguments[0];
          msg.args = arguments[1];
          msg.dbId = msg.args.dbId;
        } else {
          toss('Invalid arugments for sqlite3Worker1Promiser()-created factory.');
        }
        if (!msg.dbId && msg.type !== 'open') msg.dbId = dbId;
        msg.messageId = genMsgId(msg);
        msg.departureTime = performance.now();
        const proxy = Object.create(null);
        proxy.message = msg;
        let rowCallbackId;
        if ('exec' === msg.type && msg.args) {
          if ('function' === typeof msg.args.callback) {
            rowCallbackId = msg.messageId + ':row';
            proxy.onrow = msg.args.callback;
            msg.args.callback = rowCallbackId;
            handlerMap[rowCallbackId] = proxy;
          } else if ('string' === typeof msg.args.callback) {
            toss(
              'exec callback may not be a string when using the Promise interface.',
            );
          }
        }

        let p = new Promise(function (resolve, reject) {
          proxy.resolve = resolve;
          proxy.reject = reject;
          handlerMap[msg.messageId] = proxy;
          debug(
            'Posting',
            msg.type,
            'message to Worker dbId=' + (dbId || 'default') + ':',
            msg,
          );
          config.worker.postMessage(msg);
        });
        if (rowCallbackId) p = p.finally(() => delete handlerMap[rowCallbackId]);
        return p;
      };
    };
    globalThis.sqlite3Worker1Promiser.defaultConfig = {
      worker: function () {
        return new Worker(
          new URL('sqlite3-worker1-bundler-friendly.mjs', (document.currentScript && document.currentScript.src || new URL('bundle.js', document.baseURI).href)),
          {
            type: 'module',
          },
        );
      },
      onerror: (...args) => console.error('worker1 promiser error', ...args),
    };

    const skillEvaluationMap = {
      "無し": {
        "0": 0,
        "1": 0,
        "2": 0,
        "3": 0,
        "4": 0,
        "5": 0,
        "6": 0,
        "7": 0
      },
      "火耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "水耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "雷耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "氷耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "龍耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "毒耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "麻痺耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "睡眠耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "爆破やられ耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "植生学": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "地質学": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "飛び込み": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "陽動": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "泥雪耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "満足感": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "腹減り耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "剥ぎ取り鉄人": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "防御": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 4,
        "6": 5,
        "7": 6
      },
      "火属性攻撃強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "水属性攻撃強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "雷属性攻撃強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "氷属性攻撃強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "龍属性攻撃強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "ボマー": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "滑走強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "毒属性強化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "スタミナ奪取": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "笛吹き名人": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "回復速度": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "砥石使用高速化": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "風圧耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "ひるみ軽減": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "ブレ抑制": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "気絶耐性": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "装填速度": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "反動軽減": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "不屈": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "乗り名人": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "体術": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "体力回復量UP": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "アイテム使用強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 4,
        "4": 6,
        "5": 8,
        "6": 8,
        "7": 10
      },
      "翔蟲使い": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "壁面移動": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 4,
        "4": 6,
        "5": 8,
        "6": 8,
        "7": 10
      },
      "精霊の加護": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "早食い": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "属性やられ耐性": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "破壊王": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "広域化": {
        "0": 0,
        "1": 2,
        "2": 3,
        "3": 3,
        "4": 4,
        "5": 6,
        "6": 6,
        "7": 7
      },
      "KO術": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "納刀術": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "回避性能": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "回避距離UP": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "抜刀術【力】": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "泡沫の舞": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "逆襲": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "耐震": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "鈍器使い": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "高速変形": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "見切り": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "攻撃": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "渾身": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "強化持続": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "スタミナ急速回復": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "ガード性能": {
        "0": 0,
        "1": 2,
        "2": 3,
        "3": 5,
        "4": 6,
        "5": 8,
        "6": 9,
        "7": 11
      },
      "ガード強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "砲弾装填": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "特殊射撃強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "火事場力": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "心眼": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "集中": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "ランナー": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "砲術": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "会心撃【属性】": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "弾導強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "超会心": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "弱点特効": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "挑戦者": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "フルチャージ": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "逆恨み": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "死中に活": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "力の解放": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "麻痺属性強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "睡眠属性強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "爆破属性強化": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "剛刃研磨": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "業物": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "弾丸節約": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "達人芸": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "耳栓": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "抜刀術【技】": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "キノコ大好き": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "攻めの守勢": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "装填拡張": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "通常弾・連射矢強化": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "貫通弾・貫通矢強化": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "散弾・拡散矢強化": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "速射強化": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "ジャンプ鉄人": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "鬼火纏": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "幸運": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "匠": {
        "0": 0,
        "1": 3,
        "2": 4,
        "3": 7,
        "4": 8,
        "5": 11,
        "6": 12,
        "7": 15
      },
      "壁面移動【翔】": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "刃鱗磨き": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "合気": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "疾之息吹": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "弓溜め段階解放": {
        "0": 0,
        "1": 4,
        "2": 8,
        "3": 12,
        "4": 16,
        "5": 20,
        "6": 24,
        "7": 28
      },
      "研磨術【鋭】": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "チューンアップ": {
        "0": 0,
        "1": 3,
        "2": 6,
        "3": 9,
        "4": 12,
        "5": 15,
        "6": 18,
        "7": 21
      },
      "チャージマスター": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "災禍転福": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "供応": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "顕如盤石": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      },
      "攻勢": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "連撃": {
        "0": 0,
        "1": 2,
        "2": 4,
        "3": 6,
        "4": 8,
        "5": 10,
        "6": 12,
        "7": 14
      },
      "霞皮の恩恵": {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7
      }
    };

    class MHRiseCharmManager {
        constructor(options = {}) {
            this.dbName = 'mhrise-charm-manager';
            this.tableName = 'charms';
            this.db = null; // SQLite WASM
            this.indexeddb = null; // IndexedDB
            this.charms = null;
            this.workers = {};
            if (options.isDemoMode) {
                this.tableName = 'demoCharms';
            }
            this._init();
        }
        sql(query) {
            const params = !query.startsWith('select') ? {} : {
                rowMode: 'object',
                returnValue: 'resultRows',
            };
            console.log({ query, params });
            return this.db.exec(query, params);
        }
        // TODO: use placeholder
        async _init() {
            // this.db = window.openDatabase(this.dbName, '', 'MHRise charm manager', 5000)
            const sqlite3 = await sqlite3InitModule$1();
            // this.db = new sqlite3.oo1.DB(`${this.dbName}.sqlite3`, 'ct')
            // this.db = new sqlite3.oo1.DB('file:local?vfs=kvvfs', 'ct')
            this.db = new sqlite3.oo1.JsStorageDb('local');
            console.log('DB open: ', this.db.isOpen());
            await this._createTable();
            // this.sql(`alter table ${this.tableName} add column imagename varchar(128)`).catch(() => {}) // for old schema
            this.indexeddb = new Dexie(this.tableName);
            this.indexeddb.version(1).stores({ images: 'name' });
            this.updateCharmArray();
        }
        reset() {
            this.sql(`drop table if exists ${this.tableName}`);
            this._createTable();
        }
        registerCharm(charm, screenshot) {
            this.saveScreenshot(screenshot, charm.imageName);
            this.registerCharms([charm]); // TODO: impl
        }
        registerCharms(charms) {
            const values = charms
                .map((c) => {
                if (!Array.isArray(c.slots)) {
                    console.log('!!!!!! slots is not array !!!!!!');
                }
                const slots = c.slots.join(', ');
                const image = c.imageName ? `'${c.imageName}'` : 'NULL';
                return '(' + [
                    `'${c.skills[0]}'`,
                    c.skillLevels[0],
                    `'${c.skills[1]}'`,
                    c.skillLevels[1],
                    slots,
                    image,
                ].join(', ') + ')';
            })
                .join(',\n');
            console.log(values);
            this.sql(`
      insert or ignore into ${this.tableName}
      (skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3, imagename)
      values
      ${values}
    `);
            (() => {
                clearTimeout(this._timer);
                const self = this;
                this._timer = setTimeout(() => self.updateCharmArray(), 1000);
            })();
        }
        saveScreenshot(screenshot, imageName) {
            this.indexeddb.images.put({
                name: imageName,
                rows: screenshot.rows,
                cols: screenshot.cols,
                type: screenshot.type(),
                data: screenshot.data.slice(0),
            });
        }
        searchCharms(query) {
            const result = this.sql(query);
            // console.log({result})
            return result;
        }
        _createTable() {
            this.sql(`create table if not exists ${this.tableName}(
               skill1      varchar(20),
               skill1Level int,
               skill2      varchar(20),
               skill2Level int,
               slot1       int,
               slot2       int,
               slot3       int,
               imagename   varchar(128),
               unique (skill1, skill1Level, skill2, skill2Level, slot1, slot2, slot3))`);
            this.sql(`create index if not exists '${this.tableName}.skill1' on ${this.tableName}(skill1, skill1Level)`);
            this.sql(`create index if not exists '${this.tableName}.skill2' on ${this.tableName}(skill2, skill2Level)`);
            this.sql(`create index if not exists '${this.tableName}.slots'  on ${this.tableName}(slot1, slot2, slot3)`);
        }
        async getScreenshot(name) {
            const result = await this.indexeddb.images.get(name);
            const img = cv__default['default'].matFromArray(result.rows, result.cols, result.type, result.data);
            return img;
        }
        updateCharmArray() {
            this.charms = this.searchCharms(`select rowid,* from ${this.tableName}`)
                .map(row => {
                if (skillEvaluationMap[row.skill1] != null && skillEvaluationMap[row.skill2] != null) {
                    row.evaluation = skillEvaluationMap[row.skill1][row.skill1Level]
                        + skillEvaluationMap[row.skill2][row.skill2Level]
                        + row.slot1
                        + row.slot2
                        + row.slot3;
                }
                return row;
            });
            this.searchSubstitutableCharms();
        }
        async searchSubstitutableCharms() {
            // while ( typeof Module.getSubstitutesAll !== 'function' ) {
            //   await new Promise(r => setTimeout(r, 100))
            // }
            // const res = Module.getSubstitutesAll( JSON.stringify(this.charms) ) // use wasm module
            // const substitutes = JSON.parse(res)
            // for (const i in this.charms) {
            //   const [baseId, upperIds] = substitutes[0] || [Number.MAX_SAFE_INTEGER, []]
            //   if ( this.charms[i].rowid > baseId ) {
            //     console.log('internal error')
            //   }
            //   else if ( this.charms[i].rowid < baseId ) {
            //     this.charms[i].substitutableCharms = []
            //   }
            //   else {
            //     this.charms[i].substitutableCharms = upperIds.map((u: number) => this.charms[u - 1])
            //     substitutes.shift()
            //   }
            // }
            const workerName = 'substitutable-charm-searcher';
            if (this.workers[workerName] == null) {
                this.workers[workerName] = new Worker('mhrise-charm-substitution-search.worker.js');
            }
            this.workers[workerName].addEventListener('message', (e) => {
                console.log(e);
                const substitutes = JSON.parse(e.data.result);
                this._applySubstitutableCharmsUpdate(substitutes);
            });
            this.workers[workerName].postMessage({ charmsJson: JSON.stringify(this.charms) });
            // for (const [baseId, upperIds] of substitutes) {
            //   charms[baseId - 1].substitutableCharms = upperIds.map(i => charms[i - 1])
            // }
        }
        _applySubstitutableCharmsUpdate(substitutes) {
            var _a;
            for (const charm of this.charms) {
                const [baseId, upperIds] = (_a = substitutes[0]) !== null && _a !== void 0 ? _a : [Number.MAX_SAFE_INTEGER, []];
                if (charm.rowid > baseId) {
                    // baseId はソートされているので小さくなることはない
                    console.log('internal error');
                }
                else if (charm.rowid < baseId) {
                    // ID が出現しない護石は互換護石が見付からなかったもの. 明示的に空配列を入れておく
                    charm.substitutableCharms = [];
                }
                else {
                    charm.substitutableCharms = upperIds.map((upperId) => this.charms.find(i => i.rowid === upperId));
                    substitutes.shift();
                }
            }
            this.charms = [...this.charms];
        }
        // async exportIdx() {
        //   const blob = await exportDB(this.indexeddb, {
        //     filter: (table) => table === 'images'
        //   })
        // }
        // async importIdx() {
        // }
        // TODO: charm class 作ってコンストラクタでやる
        _row2obj(row) {
            return {
                skills: [row.skill1, row.skill2],
                skillLevels: [row.skill1Level, row.skill2Level],
                slots: [row.slot1, row.slot2, row.slot3],
            };
        }
        _isSameCharm(a, b) {
            return JSON.stringify(a) === JSON.stringify(b);
        }
    }

    /* src/App.svelte generated by Svelte v3.38.2 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let main;
    	let header;
    	let hamburger;
    	let updating_isOpen;
    	let t0;
    	let h1;
    	let t2;
    	let div0;
    	let nav;
    	let t3;
    	let div1;
    	let current;

    	function hamburger_isOpen_binding(value) {
    		/*hamburger_isOpen_binding*/ ctx[1](value);
    	}

    	let hamburger_props = {};

    	if (/*isNavigationOpen*/ ctx[0] !== void 0) {
    		hamburger_props.isOpen = /*isNavigationOpen*/ ctx[0];
    	}

    	hamburger = new Hamburger({ props: hamburger_props, $$inline: true });
    	binding_callbacks.push(() => bind(hamburger, "isOpen", hamburger_isOpen_binding));

    	nav = new Nav({
    			props: {
    				isNavigationOpen: /*isNavigationOpen*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			header = element("header");
    			create_component(hamburger.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = `${TITLE}`;
    			t2 = space();
    			div0 = element("div");
    			create_component(nav.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = `v${VERSION}`;
    			attr_dev(h1, "class", "svelte-1kyfeff");
    			add_location(h1, file, 41, 3, 1735);
    			attr_dev(header, "class", "svelte-1kyfeff");
    			add_location(header, file, 39, 2, 1675);
    			attr_dev(div0, "id", "nav-wrapper");
    			attr_dev(div0, "class", "svelte-1kyfeff");
    			add_location(div0, file, 51, 2, 2177);
    			attr_dev(div1, "id", "version");
    			attr_dev(div1, "class", "svelte-1kyfeff");
    			add_location(div1, file, 54, 2, 2242);
    			attr_dev(main, "class", "svelte-1kyfeff");
    			add_location(main, file, 38, 0, 1666);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, header);
    			mount_component(hamburger, header, null);
    			append_dev(header, t0);
    			append_dev(header, h1);
    			append_dev(main, t2);
    			append_dev(main, div0);
    			mount_component(nav, div0, null);
    			append_dev(main, t3);
    			append_dev(main, div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const hamburger_changes = {};

    			if (!updating_isOpen && dirty & /*isNavigationOpen*/ 1) {
    				updating_isOpen = true;
    				hamburger_changes.isOpen = /*isNavigationOpen*/ ctx[0];
    				add_flush_callback(() => updating_isOpen = false);
    			}

    			hamburger.$set(hamburger_changes);
    			const nav_changes = {};
    			if (dirty & /*isNavigationOpen*/ 1) nav_changes.isNavigationOpen = /*isNavigationOpen*/ ctx[0];
    			nav.$set(nav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hamburger.$$.fragment, local);
    			transition_in(nav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hamburger.$$.fragment, local);
    			transition_out(nav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(hamburger);
    			destroy_component(nav);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const TITLE = "MHRise Charm Scanner";
    const VERSION = "0.9.0";

    function instance($$self, $$props, $$invalidate) {
    	let $charmManager;
    	let $isAppReady;
    	validate_store(charmManager, "charmManager");
    	component_subscribe($$self, charmManager, $$value => $$invalidate(2, $charmManager = $$value));
    	validate_store(isAppReady, "isAppReady");
    	component_subscribe($$self, isAppReady, $$value => $$invalidate(3, $isAppReady = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);

    	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    		function adopt(value) {
    			return value instanceof P
    			? value
    			: new P(function (resolve) {
    						resolve(value);
    					});
    		}

    		return new (P || (P = Promise))(function (resolve, reject) {
    				function fulfilled(value) {
    					try {
    						step(generator.next(value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function rejected(value) {
    					try {
    						step(generator["throw"](value));
    					} catch(e) {
    						reject(e);
    					}
    				}

    				function step(result) {
    					result.done
    					? resolve(result.value)
    					: adopt(result.value).then(fulfilled, rejected);
    				}

    				step((generator = generator.apply(thisArg, _arguments || [])).next());
    			});
    	};

    	// let isDemoMode       = false
    	let isNavigationOpen = true;

    	window.addEventListener("load", () => __awaiter(void 0, void 0, void 0, function* () {
    		set_store_value(charmManager, $charmManager = new MHRiseCharmManager(), $charmManager);
    		yield MHRiseCharmScanner.init();
    		set_store_value(isAppReady, $isAppReady = true, $isAppReady);
    	}));

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function hamburger_isOpen_binding(value) {
    		isNavigationOpen = value;
    		$$invalidate(0, isNavigationOpen);
    	}

    	$$self.$capture_state = () => ({
    		__awaiter,
    		Nav,
    		Hamburger,
    		MHRiseCharmScanner,
    		MHRiseCharmManager,
    		charmManager,
    		isAppReady,
    		TITLE,
    		VERSION,
    		isNavigationOpen,
    		$charmManager,
    		$isAppReady
    	});

    	$$self.$inject_state = $$props => {
    		if ("__awaiter" in $$props) __awaiter = $$props.__awaiter;
    		if ("isNavigationOpen" in $$props) $$invalidate(0, isNavigationOpen = $$props.isNavigationOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isNavigationOpen, hamburger_isOpen_binding];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    // import * as Sentry from "@sentry/browser";
    const app = new App({
        target: document.body,
        props: {
        // name: 'world'
        }
    });

    return app;

}(cv));
//# sourceMappingURL=bundle.js.map
